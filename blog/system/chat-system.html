<!DOCTYPE html><html lang="en-us" class="__variable_dd5b2f scroll-smooth"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/36966cca54120369-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/c890694439b2475b.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/1ea5cf861ee12a80.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/a9b9096fa657c0d0.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-8506c16620cf39fb.js"/><script src="/_next/static/chunks/fd9d1056-30760135124e6678.js" async=""></script><script src="/_next/static/chunks/23-44b8024386371b46.js" async=""></script><script src="/_next/static/chunks/main-app-06a10a1bb45617e8.js" async=""></script><script src="/_next/static/chunks/ebde5ed1-51545511fe0d5050.js" async=""></script><script src="/_next/static/chunks/231-34a6a67d2da26855.js" async=""></script><script src="/_next/static/chunks/827-69594f61c16b8a9c.js" async=""></script><script src="/_next/static/chunks/850-ecf153581cc02044.js" async=""></script><script src="/_next/static/chunks/app/layout-54bebb918ae7f176.js" async=""></script><script src="/_next/static/chunks/app/blog/%5B...slug%5D/page-bd056182432da53b.js" async=""></script><script src="https://us.umami.is/script.js" async=""></script><title>从零开始：如何设计一个现代化聊天系统</title><meta name="description" content="博客介绍了一种可扩展且可靠的聊天系统架构，该架构支持一对一和小群聊，并有可能扩展到处理媒体文件。该系统采用客户端-服务器架构，由聊天服务器、Presence 服务器、推送通知服务器、键值存储和 API 服务器组成。它利用了 WebSocket、服务发现、消息传递、在线状态管理和推送通知等技术。该架构具有可扩展性、高可用性和易用性等优点，使其适用于各种规模的聊天应用程序。"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.mainjay.cloudns.ch/blog/system/chat-system"/><link rel="alternate" type="application/rss+xml" href="https://blog.mainjay.cloudns.ch/feed.xml"/><meta property="og:title" content="从零开始：如何设计一个现代化聊天系统"/><meta property="og:description" content="博客介绍了一种可扩展且可靠的聊天系统架构，该架构支持一对一和小群聊，并有可能扩展到处理媒体文件。该系统采用客户端-服务器架构，由聊天服务器、Presence 服务器、推送通知服务器、键值存储和 API 服务器组成。它利用了 WebSocket、服务发现、消息传递、在线状态管理和推送通知等技术。该架构具有可扩展性、高可用性和易用性等优点，使其适用于各种规模的聊天应用程序。"/><meta property="og:url" content="https://blog.mainjay.cloudns.ch/blog/system/chat-system"/><meta property="og:site_name" content="MainJayLai Blog"/><meta property="og:locale" content="en_US"/><meta property="og:image" content="https://pngimg.com/uploads/github/github_PNG80.png"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2024-07-02T00:00:00.000Z"/><meta property="article:modified_time" content="2024-07-02T00:00:00.000Z"/><meta property="article:author" content="mainJayLai"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="从零开始：如何设计一个现代化聊天系统"/><meta name="twitter:description" content="博客介绍了一种可扩展且可靠的聊天系统架构，该架构支持一对一和小群聊，并有可能扩展到处理媒体文件。该系统采用客户端-服务器架构，由聊天服务器、Presence 服务器、推送通知服务器、键值存储和 API 服务器组成。它利用了 WebSocket、服务发现、消息传递、在线状态管理和推送通知等技术。该架构具有可扩展性、高可用性和易用性等优点，使其适用于各种规模的聊天应用程序。"/><meta name="twitter:image" content="https://pngimg.com/uploads/github/github_PNG80.png"/><meta name="next-size-adjust"/><link rel="icon" type="image/png" href="https://mainjaylai.github.io/favicon.png"/><link rel="manifest" href="/static/favicons/manifest.json"/><meta name="msapplication-TileColor" content="#000000"/><meta name="theme-color" media="(prefers-color-scheme: light)" content="#fff"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000"/><meta name="referrer" content="no-referrer"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@200..900&amp;display=swap" rel="stylesheet"/><link href="https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&amp;family=ZCOOL+QingKe+HuangYou&amp;family=ZCOOL+XiaoWei&amp;display=swap" rel="stylesheet"/><script src="https://cdn.jsdelivr.net/gh/ashishagarwal2023/freegptjs@1.0.2/src/freegpt.min.js"></script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="bg-white pl-[calc(100vw-100%)] text-black antialiased dark:bg-gray-950 dark:text-white"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&false)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}else{c.add('light')}if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'light'}catch(e){}}()</script><section class="mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0"><div class="flex h-screen flex-col justify-between font-sans"><header class="flex items-center justify-between py-5"><div><a aria-label="Blog" href="/"><div class="flex items-center justify-between"><div class="mr-3"><img alt="logo" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" style="color:transparent" src="https://mainjaylai.github.io/favicon.png"/></div><div class="hidden h-[44px] text-center text-3xl font-semibold leading-10 sm:block">Blog</div></div></a></div><div class="flex items-center space-x-4 leading-5 sm:space-x-6"><a class="navbar-item hidden font-medium text-gray-900 dark:text-gray-100 sm:block" href="/blog">Blog</a><a class="navbar-item hidden font-medium text-gray-900 dark:text-gray-100 sm:block" href="/tags">Tags</a><a target="_blank" rel="noopener noreferrer" href="https://mainjaylai.github.io" class="navbar-item hidden font-medium text-gray-900 dark:text-gray-100 sm:block">About</a><button aria-label="Search"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="h-6 w-6 text-gray-900 dark:text-gray-100"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></button><div class="mr-8"><div class="relative inline-block text-left" data-headlessui-state=""><div><button id="headlessui-menu-button-:R5pkqja:" type="button" aria-haspopup="menu" aria-expanded="false" data-headlessui-state=""><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="h-6 w-6 text-gray-900 dark:text-gray-100"><path fill-rule="evenodd" d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" clip-rule="evenodd"></path></svg></button></div></div></div><button aria-label="AI Chat" class="flex items-center justify-center rounded-full p-1.5 text-gray-800 transition-all hover:bg-gray-100 dark:text-gray-200 dark:hover:bg-gray-800"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path><path d="M8 9h8"></path><path d="M8 13h6"></path></svg></button><div class="mr-5"><div class="relative inline-block text-left" data-headlessui-state=""><div><button class="flex items-center" id="headlessui-menu-button-:R6pkqja:" type="button" aria-haspopup="menu" aria-expanded="false" data-headlessui-state=""><div class="mr-2">简体中文</div><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1616" width="15" height="15"><path d="M670.72 325.696L511.552 152l87.68-87.872 360.96 389.504L832 453.76v0.64H64V325.76h606.72z m-318.4 382.08l157.248 172.8-94.976 79.552L63.872 579.84l147.712-0.704v-0.128H960v128.768H352.32z" fill="#262626" p-id="1617"></path></svg></button></div></div></div><button aria-label="Toggle Menu" class="sm:hidden"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="h-8 w-8 text-gray-900 dark:text-gray-100"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg></button><div class="opacity-98 fixed left-0 top-0 z-10 h-full w-full transform bg-white duration-300 ease-in-out dark:bg-gray-950 dark:opacity-[0.98] translate-x-full"><div class="flex justify-end"><button class="mr-8 mt-8 h-8 w-8" aria-label="Toggle Menu"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="text-gray-900 dark:text-gray-100"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><nav class="fixed mt-8 h-full"><div class="px-12 py-4"><a class="text-2xl font-bold tracking-widest text-gray-900 opacity-80 dark:text-gray-100" href="/">Home</a></div><div class="px-12 py-4"><a class="text-2xl font-bold tracking-widest text-gray-900 opacity-80 dark:text-gray-100" href="/blog">Blog</a></div><div class="px-12 py-4"><a class="text-2xl font-bold tracking-widest text-gray-900 opacity-80 dark:text-gray-100" href="/tags">Tags</a></div><div class="px-12 py-4"><a target="_blank" rel="noopener noreferrer" href="https://mainjaylai.github.io" class="text-2xl font-bold tracking-widest text-gray-900 opacity-80 dark:text-gray-100">About</a></div></nav></div></div></header><main class="mb-auto"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","headline":"从零开始：如何设计一个现代化聊天系统","datePublished":"2024-07-02T00:00:00.000Z","dateModified":"2024-07-02T00:00:00.000Z","description":"博客介绍了一种可扩展且可靠的聊天系统架构，该架构支持一对一和小群聊，并有可能扩展到处理媒体文件。该系统采用客户端-服务器架构，由聊天服务器、Presence 服务器、推送通知服务器、键值存储和 API 服务器组成。它利用了 WebSocket、服务发现、消息传递、在线状态管理和推送通知等技术。该架构具有可扩展性、高可用性和易用性等优点，使其适用于各种规模的聊天应用程序。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/system/chat-system","author":[{"@type":"Person","name":"mainJayLai"}]}</script><section class="mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0"><div class="fixed bottom-8 right-8 hidden flex-col gap-3 md:hidden"><button aria-label="Scroll To Comment" class="rounded-full bg-gray-200 p-2 text-gray-500 transition-all hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-400 dark:hover:bg-gray-600"><svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10c0 3.866-3.582 7-8 7a8.841 8.841 0 01-4.083-.98L2 17l1.338-3.123C2.493 12.767 2 11.434 2 10c0-3.866 3.582-7 8-7s8 3.134 8 7zM7 9H5v2h2V9zm8 0h-2v2h2V9zM9 9h2v2H9V9z" clip-rule="evenodd"></path></svg></button><button aria-label="Scroll To Top" class="rounded-full bg-gray-200 p-2 text-gray-500 transition-all hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-400 dark:hover:bg-gray-600"><svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg></button></div><article><div><header><div class="space-y-1 border-b border-gray-200 pb-10 text-center dark:border-gray-700"><div class="beautiful-chinese-title"><h1 class="text-3xl font-extrabold leading-9 tracking-tight text-gray-900 dark:text-gray-100 sm:text-4xl sm:leading-10 md:text-5xl md:leading-14">从零开始：如何设计一个现代化聊天系统</h1></div><dl><div><dt class="sr-only">Published on</dt><dd class="text-base font-medium leading-6 text-gray-500 dark:text-gray-400"><time dateTime="2024-07-02T00:00:00.000Z">July 2, 2024</time></dd></div></dl></div></header><div class="grid-rows-[auto_1fr] divide-y divide-gray-200 pb-8 dark:divide-gray-700 xl:divide-y-0"><div class="divide-y divide-gray-200 dark:divide-gray-700 xl:col-span-3 xl:row-span-2 xl:pb-0"><div class="beautiful-chinese-content prose max-w-none pb-8 pt-10 dark:prose-invert"><p>在当今数字化时代，聊天系统已成为我们日常生活和工作中不可或缺的一部分。从个人交流到团队协作，从客户服务到社交网络，聊天应用程序在各个领域都发挥着重要作用。正因如此，理解并掌握聊天系统的设计原理对于软件工程师来说尤为重要。</p><p>该博客将深入探讨聊天系统的设计，涵盖从基础架构到高级功能的各个方面。我们将分析当前市场上流行的聊天应用，研究它们的成功之处，并探讨如何将这些经验应用到我们自己的设计中。</p><p>图1呈现了目前市场上最受欢迎的几款聊天应用。这些应用之所以能够脱颖而出，不仅因为它们满足了用户的基本通讯需求，还因为它们在用户体验、功能创新和技术实现上都有独到之处。通过学习这些成功案例，我们可以更好地理解用户需求，把握技术趋势，从而设计出更加优秀的聊天系统。</p><div class="flex flex-col items-center justify-center text-center"><div><img alt="Maple" loading="lazy" width="640" height="196" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/system/chat-system/picture1.webp"/> 图 1</div></div><p>在开始设计聊天系统之前，明确系统的具体需求是至关重要的。聊天应用的多样性意味着它们可以服务于广泛的用途和用户群体，因此在设计过程中，我们需要特别注意以下几点：</p><ol><li>明确目标用户： 是面向普通消费者的即时通讯工具，还是针对企业内部沟通的协作平台？了解目标用户群体有助于确定核心功能和用户界面设计。</li><li>确定主要使用场景： 是以一对一聊天为主，还是以群组交流为重点？不同的使用场景会影响系统的架构设计和功能优先级。</li><li>功能需求分析： 除了基本的文字聊天，是否需要支持语音通话、视频会议、文件传输等功能？每增加一项功能都会影响系统的复杂度和资源需求。</li><li>性能要求： 系统需要支持多少同时在线用户？消息传递的延迟要求是什么？这些因素会直接影响到系统的架构设计和技术选型。</li><li>安全性和隐私考虑： 是否需要端到端加密？如何保护用户数据？在某些应用场景中，这可能是最关键的需求之一。</li><li>可扩展性： 系统是否需要能够快速扩展以适应用户增长？这将影响到底层架构的设计。</li><li>跨平台支持： 是否需要支持多种设备和操作系统？这会影响到客户端的开发策略。</li><li>集成需求： 是否需要与其他系统或服务集成？例如，与社交媒体平台或企业管理系统的集成。</li></ol><p>好的系统设计始于对需求的深入理解。在实际工作中，这个阶段可能需要多次迭代和讨论。通过仔细分析和明确需求，我们可以为接下来的设计过程奠定坚实的基础，最终交付一个既满足用户需求又技术先进的聊天系统。</p><h2 class="content-header" id="第一步---理解问题并确立设计范围"><a href="#第一步---理解问题并确立设计范围" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>第一步 - 理解问题并确立设计范围</h2><p>确定要设计的聊天应用类型至关重要。市场上有各种类型的聊天应用，如专注于一对一聊天的Facebook Messenger、微信和WhatsApp，侧重群聊的办公应用Slack，以及注重大群交互和低延迟语音聊天的游戏聊天应用Discord。</p><p>在该博客中，我们专注于设计一个类似Facebook Messenger的聊天应用，重点关注以下功能：</p><ul><li>低延迟的一对一聊天</li><li>小型群聊（最多100人）</li><li>在线状态显示</li><li>多设备支持。同一账户可以同时登录多个设备。</li><li>推送通知</li></ul><p>确定设计规模也很重要。我们将设计一个支持5000万日活跃用户的系统。这些需求为我们的设计提供了清晰的框架和边界。通过明确这些关键点，我们可以更有针对性地进行系统设计，避免在不必要的功能上浪费时间，同时确保能够满足核心需求和性能指标。</p><p>在实际的系统设计中，这个阶段的重要性往往被低估。然而，正是这个阶段的深入讨论和明确定义，为后续的架构设计和技术选型奠定了基础。它不仅有助于我们集中精力于最关键的功能，还能帮助我们预见可能遇到的挑战和瓶颈。例如，知道系统需要支持5000万日活跃用户，我们就可以开始考虑如何设计一个高度可扩展的架构。了解到需要支持多设备登录，我们就需要考虑如何同步不同设备间的消息和状态。而&quot;永久存储聊天历史&quot;这一需求则提醒我们需要设计一个高效的数据存储和检索系统。</p><p>通过这个过程，我们不仅明确了设计目标，还初步勾勒出了系统的轮廓。这为接下来的详细设计和技术讨论提供了明确的方向，使我们能够更有效地进行后续的设计工作。</p><h2 class="content-header" id="第二步---提出高层设计并获得认可"><a href="#第二步---提出高层设计并获得认可" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>第二步 - 提出高层设计并获得认可</h2><p>要开发高质量的设计，我们应该对客户端和服务器如何通信有基本的了解。在聊天系统中，客户端可以是移动应用或网页应用。客户端之间不直接通信，而是每个客户端连接到一个支持上述所有功能的聊天服务。让我们专注于基本操作。聊天服务必须支持以下功能：</p><ul><li>接收来自其他客户端的消息。</li><li>为每条消息找到正确的接收者并将消息转发给接收者。</li><li>如果接收者不在线，则在服务器上保留该接收者的消息，直到他们上线。</li></ul><p>图2展示了客户端（发送者和接收者）与聊天服务之间的关系。</p><div class="flex flex-col items-center justify-center text-center"><div><img alt="Maple" loading="lazy" width="640" height="114" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/system/chat-system/picture2.webp"/> 图 2</div></div><p>当客户端打算开始聊天时，它使用一个或多个网络协议连接聊天服务。对于聊天服务来说，网络协议的选择很重要。</p><p>对于大多数客户端/服务器应用程序，请求是由客户端发起的。这对聊天应用的发送方也是如此。在图2中，当发送者通过聊天服务向接收者发送消息时，它使用经过时间考验的HTTP协议，这是最常见的网络协议。在这种情况下，客户端与聊天服务建立HTTP连接并发送消息，通知服务将消息发送给接收者。这里使用keep-alive很有效，因为keep-alive头允许客户端与聊天服务保持持久连接，同时也减少了TCP握手的次数。HTTP在发送方是一个不错的选择，许多流行的聊天应用，如Facebook，最初就使用HTTP发送消息。</p><p>然而，接收方的情况稍微复杂一些。由于HTTP是客户端发起的，从服务器发送消息并不简单。多年来，许多技术被用来模拟服务器发起的连接：轮询（polling）、长轮询（long polling）和WebSocket。这些都是系统设计面试中广泛使用的重要技术，让我们逐一研究。</p><h3 class="content-header" id="轮询polling"><a href="#轮询polling" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>轮询（Polling）</h3><p>如图3所示，轮询是一种客户端定期询问服务器是否有可用消息的技术。根据轮询频率的不同，轮询可能会消耗大量资源。它可能会消耗宝贵的服务器资源来回答一个大多数时候答案都是&quot;否&quot;的问题。</p><div class="flex flex-col items-center justify-center text-center"><div><img alt="Maple" loading="lazy" width="601" height="641" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/system/chat-system/picture3.svg"/> 图 3</div></div><ol><li><strong>工作原理</strong>：<ul><li>客户端以固定的时间间隔向服务器发送HTTP请求。</li><li>服务器立即响应，无论是否有新的消息可用。</li><li>如果有新消息，服务器会在响应中包含这些消息。</li><li>如果没有新消息，服务器会发送一个空响应。</li></ul></li><li><strong>优点</strong>：<ul><li>实现简单：客户端和服务器端的逻辑都相对直接。</li><li>兼容性好：几乎所有的浏览器和服务器都支持这种方式。</li><li>防火墙友好：使用标准的HTTP请求，不会被防火墙阻挡。</li></ul></li><li><strong>缺点</strong>：<ul><li>资源浪费：即使没有新消息，也会频繁发送请求，浪费带宽和服务器资源。</li><li>实时性差：消息的接收存在延迟，取决于轮询间隔。</li><li>服务器负载高：当有大量客户端同时轮询时，可能会给服务器带来巨大压力。</li></ul></li><li><strong>优化策略</strong>：<ul><li>自适应轮询间隔：根据消息频率动态调整轮询间隔。</li><li>批量获取消息：每次轮询获取多条消息，减少请求次数。</li><li>结合其他技术：例如，可以用轮询来检查是否有新消息，有的话再建立更高效的连接获取消息内容。</li></ul></li></ol><p>在设计聊天系统时，轮询可能会作为一种降级策略或备用方案使用，例如当WebSocket连接失败时。但对于主要的消息传递机制，我们通常会选择更高效的方法，如WebSocket或长轮询。</p><h3 class="content-header" id="长轮询long-polling"><a href="#长轮询long-polling" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>长轮询（Long Polling）</h3><p>由于轮询可能效率低下，下一个进展是长轮询（如图4所示）。</p><div class="flex flex-col items-center justify-center text-center"><div><img alt="Maple" loading="lazy" width="711" height="641" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/system/chat-system/picture4.svg"/> 图 4</div></div><p>在长轮询中，客户端保持连接打开，直到实际有新消息可用或达到超时阈值。一旦客户端接收到新消息，它立即向服务器发送另一个请求，重新启动这个过程。长轮询有几个缺点：</p><ul><li>发送者和接收者可能不会连接到同一个聊天服务器。基于HTTP的服务器通常是无状态的。如果您使用轮询（Round Robin）进行负载均衡，接收消息的服务器可能与接收消息的客户端没有长轮询连接。</li><li>服务器没有好的方法来判断客户端是否已断开连接。</li><li>它是低效的。如果用户不经常聊天，长轮询仍会在超时后定期建立连接。</li></ul><ol><li><strong>工作原理</strong>：<ul><li>客户端向服务器发送HTTP请求。</li><li>如果服务器没有可用的新数据，不会立即发送响应，而是保持请求打开。</li><li>当新数据可用时，服务器立即响应该请求。</li><li>客户端收到响应后，立即发送新的请求，重新开始这个过程。</li></ul></li><li><strong>优点</strong>：<ul><li>相比简单轮询，减少了不必要的请求和响应。</li><li>能够更接近实时地接收消息。</li><li>使用标准的HTTP协议，兼容性好。</li></ul></li><li><strong>缺点</strong>：<ul><li>服务器资源消耗：长时间保持连接可能会占用服务器资源。</li><li>可能的延迟：如果消息恰好在一个长轮询请求结束后到达，需要等待下一个请求才能接收。</li><li>连接管理复杂：需要处理连接超时、重连等情况。</li></ul></li><li><strong>分布式系统中的挑战</strong>：<ul><li>消息路由：在多服务器环境中，接收消息的服务器可能不是持有长轮询连接的服务器。</li><li>需要额外的机制（如消息队列或发布-订阅系统）来确保消息能正确地路由到持有客户端连接的服务器。</li></ul></li><li><strong>优化策略</strong>：<ul><li>使用超时机制：设置合理的超时时间，平衡实时性和资源消耗。</li><li>自适应超时：根据用户活跃度动态调整超时时间。</li><li>批量处理：在一个响应中返回多条消息，提高效率。</li></ul></li></ol><p>在设计聊天系统时，长轮询可能是一个折中的选择，特别是在不支持WebSocket的环境中。然而，对于大规模、高并发的聊天应用，WebSocket通常是更好的选择。理解长轮询的这些特性和局限性，有助于我们在系统设计中做出更informed的决策，选择最适合特定需求和约束的技术方案。</p><h3 class="content-header" id="websocket"><a href="#websocket" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>WebSocket</h3><p>WebSocket是从服务器向客户端发送异步更新最常用的解决方案。图5展示了它的工作原理。</p><div class="flex flex-col items-center justify-center text-center"><div><img alt="Maple" loading="lazy" width="521" height="321" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/system/chat-system/picture5.svg"/> 图 5</div></div><p>WebSocket连接由客户端发起。它是双向的且持久的。它最初作为HTTP连接开始，然后通过一些定义良好的握手过程&quot;升级&quot;为WebSocket连接。通过这个持久连接，服务器可以向客户端发送更新。WebSocket连接通常即使在有防火墙的情况下也能工作。这是因为它们使用80或443端口，这也是HTTP/HTTPS连接使用的端口。</p><p>早些时候我们说在发送方使用HTTP协议就足够了，但由于WebSocket是双向的，从技术上讲没有强烈的理由不也将其用于发送。图6展示了如何在发送方和接收方都使用WebSocket（ws）。</p><div class="flex flex-col items-center justify-center text-center"><div><img alt="Maple" loading="lazy" width="384" height="220" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/system/chat-system/picture6.webp"/> 图 6</div></div><p>通过在发送和接收两端都使用WebSocket，可以简化设计并使客户端和服务器端的实现更加直接。由于WebSocket连接是持久的，在服务器端进行高效的连接管理至关重要。</p><ol><li><strong>工作原理</strong>：<ul><li>客户端初始化WebSocket连接请求。</li><li>服务器响应并升级连接从HTTP到WebSocket。</li><li>建立全双工、持久的连接通道。</li><li>客户端和服务器可以随时互相发送消息。</li></ul></li><li><strong>优点</strong>：<ul><li>实时性强：消息可以立即双向传递。</li><li>效率高：相比HTTP，减少了连接建立和头部信息的开销。</li><li>支持推送：服务器可以主动向客户端推送消息。</li><li>跨平台：广泛支持，包括Web、移动和桌面应用。</li></ul></li><li><strong>在聊天系统中的应用</strong>：<ul><li>即时消息传递：消息可以立即发送和接收。</li><li>在线状态更新：可以实时通知用户状态变化。</li><li>多设备同步：可以轻松实现跨设备的消息同步。</li></ul></li><li><strong>性能考虑</strong>：<ul><li>连接管理：需要有效管理大量并发的长连接。</li><li>心跳机制：实现心跳来保持连接活跃并检测断开。</li><li>重连策略：在连接断开时实现智能重连机制。</li></ul></li><li><strong>安全性</strong>：<ul><li>加密：WebSocket支持WSS（WebSocket Secure），类似于HTTPS。</li><li>认证：初始连接时可以进行身份验证。</li><li>消息验证：可以实现消息级别的安全检查。</li></ul></li><li><strong>扩展性设计</strong>：<ul><li>负载均衡：使用专门的WebSocket负载均衡器。</li><li>集群化：实现WebSocket服务器的集群以提高可用性。</li><li>消息队列：使用消息队列系统来处理大量并发消息。</li></ul></li><li><strong>客户端实现注意事项</strong>：<ul><li>断线重连：实现自动重连机制。</li><li>消息缓存：在断线期间缓存消息，重连后发送。</li><li>状态同步：重连后同步离线期间的状态变化。</li></ul></li><li><strong>服务器端实现注意事项</strong>：<ul><li>连接池管理：高效管理大量并发连接。</li><li>资源限制：设置合理的连接数限制和超时机制。</li><li>消息路由：在分布式系统中正确路由消息到指定的接收者。</li></ul></li><li><strong>移动端特殊考虑</strong>：<ul><li>电池影响：保持长连接可能增加电池消耗，需要智能管理连接。</li><li>网络切换：在网络状态变化时（如从WiFi切换到4G）保持连接的策略。</li></ul></li></ol><p>在设计大规模聊天系统时，WebSocket通常是首选的技术。它提供了实时性、效率和灵活性。然而，成功实施WebSocket还需要考虑诸多因素，包括连接管理、扩展性、安全性和异常处理等。通过仔细设计和优化这些方面，可以构建出高效、可靠的实时聊天系统。</p><h3 class="content-header" id="高层设计"><a href="#高层设计" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>高层设计</h3><p>我们刚才提到选择WebSocket作为客户端和服务器之间的主要通信协议，因为它支持双向通信。但重要的是要注意，其他所有功能并不一定都要使用WebSocket。实际上，聊天应用的大多数功能（如注册、登录、用户资料等）都可以使用传统的HTTP请求/响应方法。让我们深入探讨一下系统的高层组件。</p><p>如图7所示，聊天系统被分为三大类：无状态服务、有状态服务和第三方集成。</p><div class="flex flex-col items-center justify-center text-center"><div><img alt="Maple" loading="lazy" width="640" height="828" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/system/chat-system/picture7.webp"/> 图 7</div></div><h4 class="content-header" id="无状态服务"><a href="#无状态服务" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>无状态服务</h4><p>无状态服务是传统的面向公众的请求/响应服务，用于管理登录、注册、用户资料等。这些是许多网站和应用程序中常见的功能。</p><p>无状态服务位于负载均衡器之后，负载均衡器的工作是根据请求路径将请求路由到正确的服务。这些服务可以是单体的或独立的微服务。我们不需要自己构建许多这些无状态服务，因为市场上有可以轻松集成的服务。我们将在深入探讨中更多讨论的一个服务是服务发现。它的主要工作是为客户端提供一个客户端可以连接的聊天服务器的DNS主机名列表。</p><ol><li><p><strong>特征</strong>：</p><ul><li>不保存客户端会话状态。</li><li>每个请求都是独立的，包含处理该请求所需的所有信息。</li><li>可以轻松扩展，因为任何服务器都可以处理任何请求。</li></ul></li><li><p><strong>常见的无状态服务</strong>：</p><p>a) <strong>认证服务</strong>：</p><ul><li>处理用户登录和注册。</li><li>可能使用JWT（JSON Web Tokens）来管理用户会话。</li><li>集成第三方认证（如OAuth）。</li></ul><p>b) <strong>用户资料服务</strong>：</p><ul><li>管理用户个人信息。</li><li>处理资料更新请求。</li><li>可能集成头像存储和处理功能。</li></ul><p>c) <strong>好友管理服务</strong>：</p><ul><li>处理添加、删除、阻止好友的请求。</li><li>管理好友列表。</li></ul><p>d) <strong>消息历史服务</strong>：</p><ul><li>提供历史消息的存储和检索。</li><li>可能涉及分页和搜索功能。</li></ul><p>e) <strong>文件传输服务</strong>：</p><ul><li>处理文件上传和下载。</li><li>可能集成云存储服务。</li></ul></li><li><p><strong>服务发现</strong>：</p><ul><li>为客户端提供可用聊天服务器的列表。</li><li>可以使用DNS轮询或更复杂的服务发现机制。</li><li>帮助实现负载均衡和故障转移。</li></ul></li></ol><h4 class="content-header" id="有状态服务"><a href="#有状态服务" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>有状态服务</h4><p>唯一的有状态服务是聊天服务。这个服务是有状态的，因为每个客户端都与一个聊天服务器保持持久的网络连接。在这个服务中，只要服务器仍然可用，客户端通常不会切换到另一个聊天服务器。服务发现与聊天服务密切协调，以避免服务器过载。我们将在深入探讨中详细介绍。</p><ol><li><p><strong>特征</strong>：</p><ul><li>维护客户端的会话状态。</li><li>使用持久连接（通常是WebSocket）。</li><li>每个客户端通常与特定服务器实例保持长期连接。</li></ul></li><li><p><strong>聊天服务的核心功能</strong>：</p><p>a) <strong>连接管理</strong>：</p><ul><li>建立和维护WebSocket连接。</li><li>处理连接的认证和授权。</li><li>实现心跳机制以检测连接状态。</li></ul><p>b) <strong>消息路由</strong>：</p><ul><li>接收来自客户端的消息并转发给正确的接收者。</li><li>处理一对一聊天和群组聊天的消息分发。</li></ul><p>c) <strong>在线状态跟踪</strong>：</p><ul><li>实时更新和广播用户的在线/离线状态。</li><li>管理用户的&quot;正在输入&quot;状态。</li></ul><p>d) <strong>消息持久化</strong>：</p><ul><li>将消息存储到数据库以供历史记录查询。</li><li>处理离线消息的存储和后续发送。</li></ul></li><li><p><strong>服务发现与负载均衡</strong>：</p><ul><li>与服务发现组件协作，动态分配客户端到合适的服务器。</li><li>实现智能负载均衡策略，考虑服务器负载、地理位置等因素。</li></ul></li><li><p><strong>扩展性考虑</strong>：</p><p>a) <strong>水平扩展</strong>：</p><ul><li>增加服务器实例以处理更多并发连接。</li><li>实现无状态的会话管理，允许在服务器之间迁移连接。</li></ul><p>b) <strong>分片</strong>：</p><ul><li>基于用户ID或聊天室ID进行数据分片。</li><li>确保相关的用户或群组被路由到同一服务器或服务器组。</li></ul></li><li><p><strong>高可用性</strong>：</p><ul><li>实现故障检测和自动故障转移机制。</li><li>使用多区域部署以提高可用性和减少延迟。</li></ul></li><li><p><strong>性能优化</strong>：</p><ul><li>使用内存数据库（如Redis）存储临时数据和状态信息。</li><li>实现消息的批处理和异步处理。</li><li>优化数据库操作，如使用写入缓冲和读取缓存。</li></ul></li><li><p><strong>安全性</strong>：</p><ul><li>实现端到端加密以保护消息内容。</li><li>使用安全的WebSocket连接（WSS）。</li><li>实施速率限制以防止滥用。</li></ul></li></ol><h4 class="content-header" id="第三方集成"><a href="#第三方集成" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>第三方集成</h4><p>对于聊天应用来说，推送通知是最重要的第三方集成。它是一种在应用程序未运行时也能通知用户有新消息到达的方式。正确集成推送通知至关重要。</p><ol><li><p><strong>推送通知系统</strong>：</p><p>a) 重要性：</p><ul><li>保持用户参与度。</li><li>确保重要消息及时送达。</li><li>提高用户回复率和应用使用频率。</li></ul><p>b) 主要功能：</p><ul><li>发送新消息通知。</li><li>群组活动提醒。</li><li>系统公告和更新通知。</li></ul><p>c) 实现考虑：</p><ul><li>集成主要平台的推送服务：<ul><li>iOS: Apple Push Notification Service (APNS)</li><li>Android: Firebase Cloud Messaging (FCM)</li></ul></li><li>处理不同设备类型和操作系统版本。</li><li>实现智能通知策略，避免过度打扰用户。</li><li>支持富媒体通知（如图片、动作按钮等）。</li></ul><p>d) 挑战：</p><ul><li>确保通知的及时性和可靠性。</li><li>处理设备令牌更新和失效。</li><li>遵守平台特定的限制和最佳实践。</li></ul><p>e) 优化：</p><ul><li>实现批量推送以提高效率。</li><li>使用本地化内容增强用户体验。</li><li>提供通知设置，允许用户自定义通知偏好。</li></ul></li><li><p><strong>其他潜在的第三方集成</strong>：</p><p>a) <strong>身份验证服务</strong>：</p><ul><li>集成如 OAuth、OpenID Connect 的标准协议。</li><li>支持社交媒体登录（如 Facebook、Google、Twitter）。</li></ul><p>b) <strong>内容审核服务</strong>：</p><ul><li>使用 AI 驱动的内容审核服务来过滤不当内容。</li><li>实现实时文本和图像审核。</li></ul><p>c) <strong>语音和视频通话</strong>：</p><ul><li>集成如 Twilio、Agora 或 WebRTC 的服务。</li><li>支持一对一和群组音视频通话。</li></ul><p>d) <strong>文件存储和共享</strong>：</p><ul><li>使用云存储服务如 AWS S3、Google Cloud Storage。</li><li>支持大文件传输和多媒体内容分享。</li></ul><p>e) <strong>翻译服务</strong>：</p><ul><li>集成如 Google Translate 或 DeepL 的 API。</li><li>提供实时消息翻译功能。</li></ul><p>f) <strong>分析和监控</strong>：</p><ul><li>使用如 Google Analytics、Mixpanel 的服务跟踪用户行为。</li><li>集成错误追踪工具如 Sentry 或 Crashlytics。</li></ul><p>g) <strong>支付系统</strong>：</p><ul><li>如果应用涉及电子商务功能，集成支付网关。</li></ul><p>h) <strong>地理位置服务</strong>：</p><ul><li>集成地图服务如 Google Maps 或 Mapbox。</li><li>支持位置共享功能。</li></ul></li></ol><h4 class="content-header" id="可扩展性"><a href="#可扩展性" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>可扩展性</h4><ol><li><p><strong>单服务器的理论可能性</strong>：从理论上讲，即使是为100万并发用户设计的系统，也可能在一个现代云服务器上容纳所有用户连接。假设每个用户连接需要10KB的服务器内存，100万用户仅需要约10GB内存。这个估算确实展示了现代硬件的强大能力。</p></li><li><p><strong>单服务器设计的问题</strong>：尽管理论上可行，但在实际的系统设计中，单服务器方案确实会引起严重的担忧。您正确地指出，没有技术专家会为如此规模的系统设计单服务器方案。主要问题包括：</p><ul><li>单点故障：这是最大的问题。服务器故障将导致整个系统瘫痪。</li><li>可扩展性限制：难以应对突发流量或未来增长。</li><li>维护困难：升级或维护需要停机。</li><li>性能瓶颈：单服务器的处理能力和I/O终将成为瓶颈。</li><li>地理分布：难以为全球用户提供低延迟服务。</li></ul></li><li><p><strong>从单服务器开始的策略</strong>：在系统设计面试中，从单服务器设计开始是一个很好的策略，只要确保面试官知道这只是起点。这种方法有几个优点：</p><ul><li>简化初始讨论，聚焦于核心功能。</li><li>展示您理解系统的基本需求。</li><li>为后续的扩展讨论奠定基础。</li></ul></li><li><p><strong>调整后的高层设计</strong>： 图8展示的调整后的高层设计很好地体现了一个可扩展的聊天系统架构。让我们详细分析一下每个组件：</p><div class="flex flex-col items-center justify-center text-center"><div><img alt="Maple" loading="lazy" width="750" height="820" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/system/chat-system/picture8.webp"/> 图 8</div></div><p>a) <strong>客户端与WebSocket连接</strong>：</p><ul><li>使用WebSocket保持与聊天服务器的持久连接，实现实时消息传递。</li><li>考虑客户端的重连逻辑和离线消息同步机制。</li></ul><p>b) <strong>聊天服务器</strong>：</p><ul><li>处理消息的发送和接收。</li><li>可以水平扩展以处理更多并发连接。</li><li>考虑使用服务发现机制动态分配客户端到服务器。</li></ul><p>c) <strong>存在服务器</strong>：</p><ul><li>管理用户的在线/离线状态。</li><li>可以使用分布式缓存（如Redis）来提高性能。</li></ul><p>d) <strong>API服务器</strong>：</p><ul><li>处理非实时请求，如登录、注册、资料更改等。</li><li>无状态设计，易于扩展。</li></ul><p>e) <strong>通知服务器</strong>：</p><ul><li>发送推送通知。</li><li>集成各平台的推送服务（如APNS, FCM）。</li></ul><p>f) <strong>键值存储</strong>：</p><ul><li>存储聊天历史。</li><li>选择适合大规模读写的数据库（如Cassandra或HBase）。</li><li>考虑数据分片策略以提高性能。</li></ul></li><li><p><strong>扩展性考虑</strong>：</p><p>a) <strong>负载均衡</strong>：</p><ul><li>在各层服务之前添加负载均衡器。</li><li>对WebSocket连接使用特殊的负载均衡策略。</li></ul><p>b) <strong>数据库扩展</strong>：</p><ul><li>实现读写分离。</li><li>使用数据分片处理大规模数据。</li></ul><p>c) <strong>缓存策略</strong>：</p><ul><li>引入分布式缓存层减轻数据库负载。</li><li>缓存热门对话和频繁访问的用户数据。</li></ul><p>d) <strong>异步处理</strong>：</p><ul><li>使用消息队列（如Kafka）处理非实时任务。</li></ul><p>e) <strong>微服务架构</strong>：</p><ul><li>考虑将大型服务拆分为微服务，提高系统的模块性和可维护性。</li></ul><p>f) <strong>全球化部署</strong>：</p><ul><li>使用CDN加速静态资源交付。</li><li>考虑多区域部署以降低延迟。</li></ul></li><li><p><strong>监控和警报</strong>：</p><ul><li>实施全面的监控系统，跟踪关键指标。</li><li>设置自动警报以快速响应问题。</li></ul></li><li><p><strong>安全性考虑</strong>：</p><ul><li>实现端到端加密。</li><li>使用适当的认证和授权机制。</li><li>防御DDoS攻击和其他安全威胁。</li></ul></li></ol><p>这种分布式设计解决了单服务器方案的主要问题，提供了高可用性、可扩展性和容错能力。它允许系统根据需求独立扩展不同的组件，同时保持整体架构的灵活性。在实际实现中，可能还需要根据具体需求和约束进行进一步的优化和调整。</p><h4 class="content-header" id="存储"><a href="#存储" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>存储</h4><p>现在，服务器已经搭建完毕，服务正在运行，第三方集成也已完成。在整个技术栈的最底层，就是数据存储部分。选择正确的数据存储方式至关重要。本小节将探讨聊天系统中应该使用哪种类型的数据库：关系型数据库还是非关系型数据库？</p><p>聊天系统通常包含两种类型的数据。第一种是通用数据，例如用户资料、设置、好友列表等。这些数据需要存储在稳定可靠的关系型数据库中。通常会采用复制和分片等技术来满足可用性和可扩展性的需求；第二种数据是聊天历史记录，这是聊天系统独有的数据类型。理解其读写模式非常重要。</p><p>聊天系统的聊天记录数据量会非常庞大。研究表明，Facebook Messenger 和 Whatsapp 每天处理的消息数量高达 600 亿条。然而，用户频繁访问的只有最近的聊天记录。他们通常不会去查找很久之前的聊天记录。</p><p>虽然大多数情况下用户查看的都是最近的聊天记录，但一些功能还是需要随机访问历史数据，例如搜索、查看@ 提及、跳转到特定消息等。数据访问层需要支持这些场景。对于一对一聊天的应用来说，读写比例大约是 1:1。</p><p>选择合适的存储系统来支持所有用例至关重要。我们推荐使用键值存储 (<strong>Key-Value Store</strong>) 来存储聊天记录，原因如下：</p><ul><li>键值存储易于水平扩展。</li><li>键值存储提供极低的访问延迟。</li><li>关系型数据库在处理长尾数据时效率低下。当索引变得庞大时，随机访问的成本会很高。</li><li>键值存储已经被其他可靠的聊天应用所采用。例如，Facebook Messenger 使用 HBase，Discord 使用 Cassandra。</li></ul><h3 class="content-header" id="数据模型"><a href="#数据模型" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>数据模型</h3><p>刚才我们讨论了使用键值存储作为数据存储层。其中最重要的数据就是消息数据，下面让我们仔细看一下 1 对 1 聊天的消息表结构。</p><h4 class="content-header" id="1-对-1-聊天消息表"><a href="#1-对-1-聊天消息表" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>1 对 1 聊天消息表</h4><p>表格展示了 1 对 1 聊天消息的表格结构。主键是 <code class="custom-code">message_id</code>，它用于确定消息的顺序。我们不能仅仅依赖 <code class="custom-code">created_at</code> 字段来判断消息顺序，因为有可能出现两条消息同时创建的情况。</p><div class="w-full overflow-x-auto"><table><thead><tr><th>字段名</th><th>数据类型</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code class="custom-code">message_id</code></td><td>字符串</td><td>消息的唯一标识符</td><td>主键</td></tr><tr><td><code class="custom-code">from_user_id</code></td><td>字符串</td><td>发送消息的用户 ID</td><td>外键，引用用户表</td></tr><tr><td><code class="custom-code">to_user_id</code></td><td>字符串</td><td>接收消息的用户 ID</td><td>外键，引用用户表</td></tr><tr><td><code class="custom-code">content</code></td><td>字符串</td><td>消息内容</td><td>文本内容或其他格式数据</td></tr><tr><td><code class="custom-code">created_at</code></td><td>时间戳</td><td>消息创建时间</td><td></td></tr></tbody></table></div><h4 class="content-header" id="群聊消息表"><a href="#群聊消息表" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>群聊消息表</h4><p>表格10 展示了群聊消息的表格结构。复合主键是 <code class="custom-code">(channel_id, message_id)</code>。这里 channel 和 group 代表相同的含义，<code class="custom-code">channel_id</code> 是分区键，因为群聊中的所有查询都针对特定的频道进行。</p><div class="w-full overflow-x-auto"><table><thead><tr><th>字段名</th><th>数据类型</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code class="custom-code">channel_id</code></td><td>字符串</td><td>频道的唯一标识符</td><td>复合主键的一部分</td></tr><tr><td><code class="custom-code">message_id</code></td><td>字符串</td><td>消息的唯一标识符</td><td>复合主键的一部分</td></tr><tr><td><code class="custom-code">from_user_id</code></td><td>字符串</td><td>发送消息的用户 ID</td><td>外键，引用用户表</td></tr><tr><td><code class="custom-code">content</code></td><td>字符串</td><td>消息内容</td><td>文本内容或其他格式数据</td></tr><tr><td><code class="custom-code">created_at</code></td><td>时间戳</td><td>消息创建时间</td><td></td></tr></tbody></table></div><h4 class="content-header" id="消息-id-生成"><a href="#消息-id-生成" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>消息 ID 生成</h4><p>如何生成 <code class="custom-code">message_id</code> 是一个值得探讨的有趣话题。<code class="custom-code">message_id</code> 承担着确保消息顺序的重任，为了实现消息排序，<code class="custom-code">message_id</code> 需要满足以下两个要求：</p><ol><li><strong>唯一性</strong>: 每个消息的 ID 必须是唯一的。</li><li><strong>时间可排序</strong>: ID 应该具有时间顺序，即较新的消息的 ID 应该大于较旧的消息的 ID。</li></ol><p>那么如何才能满足这两个保证呢？</p><ul><li><p><strong>方案一：自增主键 (Auto-increment)</strong></p><p>这是最直观的想法，在关系型数据库中我们可以使用 MySQL 的 <code class="custom-code">auto_increment</code> 特性来实现。但是，NoSQL 数据库通常不提供类似的功能。</p></li><li><p><strong>方案二：全局递增序列号生成器</strong></p><p>另一种方案是使用全局的 64 位序列号生成器，例如 Snowflake提供的这类服务。这种方式在 “分布式系统中设计唯一 ID 生成器” 章节中有详细讨论。</p></li><li><p><strong>方案三：本地递增序列号生成器</strong></p><p>最后一种方案是使用本地递增序列号生成器。这里的 “本地” 意味着 ID 在某个组内是唯一的。之所以本地 ID 可以工作，是因为我们只需要保证一对一聊天或群聊频道内的消息顺序即可。与全局 ID 实现相比，这种方式更加易于实现。</p></li></ul><h2 class="content-header" id="第三步---系统设计深度剖析"><a href="#第三步---系统设计深度剖析" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>第三步 - 系统设计深度剖析</h2><p>在系统设计面试中，通常会要求你深入探讨高级设计中的一些组件。对于聊天系统来说，服务发现、消息流和在线/离线指示器值得更深入地研究。</p><h3 class="content-header" id="服务发现-service-discovery"><a href="#服务发现-service-discovery" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>服务发现 (Service Discovery)</h3><p>服务发现的主要作用是根据地理位置、服务器容量等标准，为客户端推荐最合适的聊天服务器。它可以注册所有可用的聊天服务器，并根据预定义的标准为客户端挑选最合适的服务器。它是帮助应用程序定位其他服务的机制。在聊天系统中，可能有多个微服务协同工作，例如用户服务、消息服务和推送服务。服务发现使应用程序不必关心底层基础设施细节，例如服务的主机名和端口号。Apache Zookeeper是一个流行的开源服务发现解决方案。</p><p>以下是一些常用的服务发现技术：</p><ul><li><strong>DNS (Domain Name System)</strong>: 传统且广泛使用的服务发现方式，可以通过域名解析服务将服务名称转换为 IP 地址和端口号。</li><li><strong>ZooKeeper</strong> : 一个集中式的分布式协调服务，可用于存储和检索服务元数据。</li><li><strong>Consul</strong> : 功能类似于 ZooKeeper 的开源服务发现工具，提供服务注册、健康检查和 KV 存储等功能。</li><li><strong>etcd</strong> : 由 CoreOS 开发的开源分布式键值存储，常用于服务发现和配置管理。</li></ul><p>图 11 展示了服务发现 (Zookeeper) 的工作流程：</p><div class="flex flex-col items-center justify-center text-center"><div><img alt="Maple" loading="lazy" width="640" height="623" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/system/chat-system/picture11.webp"/> 图 11</div></div><ol><li>用户 A 尝试登录应用。</li><li>负载均衡器将登录请求发送到 API 服务器。</li><li>后台验证用户之后，服务发现会为用户 A 找到最合适的聊天服务器。在这个例子中，选择了服务器 2，并将其信息返回给用户 A。</li><li>用户 A 通过 WebSocket 连接到聊天服务器 2。</li></ol><h3 class="content-header" id="消息流-messaging-flows"><a href="#消息流-messaging-flows" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>消息流 (Messaging Flows)</h3><p>消息流是指消息在聊天系统中从发送方传递到接收方的过程。它通常涉及以下步骤：</p><h4 class="content-header" id="1-对-1-聊天"><a href="#1-对-1-聊天" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>1 对 1 聊天</h4><div class="flex flex-col items-center justify-center text-center"><div><img alt="Maple" loading="lazy" width="640" height="678" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/system/chat-system/picture12.webp"/> 图 12</div></div><p><strong>用户 A 发送聊天消息到聊天服务器 1</strong></p><ul><li>用户 A 在聊天界面输入消息并点击发送按钮。</li><li>用户 A 的客户端应用将消息内容、接收方用户 ID 等信息封装成消息对象。</li><li>通过 WebSocket 连接，客户端应用将消息对象发送到聊天服务器 1。</li></ul><p><strong>聊天服务器 1 获取消息 ID</strong></p><ul><li>聊天服务器 1 调用消息 ID 生成器 (如上文讨论的几种方案) 获取一个唯一的消息 ID。</li><li>消息 ID 将被附加到消息对象上，用于后续的消息跟踪和排序。</li></ul><p><strong>聊天服务器 1 发送消息到消息同步队列</strong></p><ul><li>聊天服务器 1 将包含消息内容、消息 ID、发送方和接收方信息等数据的完整消息对象放入消息同步队列。</li><li>消息同步队列可以是内存队列或持久化队列，具体取决于系统的需求。例如，内存队列处理速度快，但容易丢失数据；持久化队列可以保证消息可靠性，但处理速度可能稍慢。</li></ul><p><strong>消息存储到键值存储</strong></p><ul><li>聊天服务器 1 将包含完整消息数据的消息对象存储到键值存储中。</li><li>键值存储可以高效地存储和检索消息数据，并支持根据不同的键进行查询（例如根据 <code class="custom-code">message_id</code> 查询消息内容）。</li></ul><p><strong>消息传递到接收方</strong></p><ul><li><p>根据接收方用户 (用户 B) 的在线状态，</p><p>聊天系统采用不同的策略传递消息：</p><ul><li>a. 用户 B 在线<ul><li>聊天服务器 1 通过服务发现 (Zookeeper 等) 找到用户 B 当前连接的聊天服务器 (假设为服务器 2)。</li><li>聊天服务器 1 将消息对象转发到聊天服务器 2。</li></ul></li><li>b. 用户 B 离线<ul><li>聊天服务器 1 不会直接将消息发送到离线用户。</li><li>聊天服务器 1 将消息的概要信息 (例如发送方昵称、消息摘要) 发送到推送通知 (PN) 服务器。</li><li>PN 服务器根据用户 B 的设备信息，通过推送通知服务将消息概要信息发送到用户 B 的设备。</li></ul></li></ul></li></ul><p><strong>接收方收到消息</strong></p><ul><li>a. 用户 B 在线<ul><li>用户 B 的客户端通过 WebSocket 连接一直监听聊天服务器 2 发送的消息。</li><li>当聊天服务器 2 转发消息对象过来时，用户 B 的客户端收到消息并将其展示在聊天界面上。</li></ul></li><li>b. 用户 B 离线<ul><li>用户 B 需要通过其他方式 (例如打开应用) 拉取最新的消息记录，才能看到完整的聊天消息内容。</li></ul></li></ul><h4 class="content-header" id="消息同步多个设备"><a href="#消息同步多个设备" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>消息同步多个设备</h4><p>许多用户在使用多个设备进行聊天。下面我们将介绍如何在多个设备之间同步消息，确保用户在任何设备上看到的聊天记录都是一致的。</p><p>图 13 展示了消息同步的一个示例。图中，用户 A 拥有手机和笔记本电脑两个设备。当用户 A 用手机登录聊天应用时，手机会通过 WebSocket 连接到聊天服务器 1。同样，笔记本电脑也会建立与其的连接。</p><div class="flex flex-col items-center justify-center text-center"><div><img alt="Maple" loading="lazy" width="640" height="454" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/system/chat-system/picture13.webp"/> 图 13</div></div><p><strong>1. 客户端游标 (cur_max_message_id)</strong></p><p>每个设备都会维护一个变量，称为 <code class="custom-code">cur_max_message_id</code>。它用来跟踪设备上本地存储的最新消息 ID。</p><p><strong>2. 新消息识别</strong></p><p>系统会根据以下两个条件来判断一条消息是否对当前设备而言是新消息：</p><ul><li>消息的接收方用户 ID 与当前登录的用户 ID 相等。</li><li>消息在键值存储中的 ID 大于设备上存储的 <code class="custom-code">cur_max_message_id</code>。</li></ul><p><strong>3. 消息拉取</strong></p><p>由于每个设备的 <code class="custom-code">cur_max_message_id</code> 都不同，因此消息同步变得简单。每个设备都可以从键值存储中拉取满足上述条件的消息，即消息的接收方为自己且 ID 大于本地存储的最新消息 ID 的消息。</p><p><strong>4. 更新游标</strong></p><p>当设备成功拉取到新消息后，会将 <code class="custom-code">cur_max_message_id</code> 更新为拉取到的最大消息 ID，以便后续仅拉取新消息。</p><p><strong>5. 消息展示</strong></p><p>拉取到的新消息将会展示在聊天界面上。</p><h4 class="content-header" id="小型群聊消息流"><a href="#小型群聊消息流" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>小型群聊消息流</h4><p>与一对一聊天相比，群聊的逻辑更加复杂。图 14 和图 15 展示了群聊消息的发送和接收流程。</p><div class="flex flex-col items-center justify-center text-center"><div><img alt="Maple" loading="lazy" width="640" height="557" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/system/chat-system/picture14.webp"/> 图 14</div></div><p>图 14 展示了用户 A 在群聊中发送消息时的流程，假设群聊中有 3 个成员（用户 A、用户 B 和用户 C）。</p><ol><li>用户 A 的客户端将消息内容、群聊 ID 等信息封装成消息对象。</li><li>聊天服务器 1 将消息对象复制一份，并分别放入用户 B 和用户 C 的消息同步队列中。</li><li>每个群成员都可以通过自己对应的消息同步队列接收来自不同发送方的消息。</li></ol><p><strong>设计选择</strong>: 这种将消息拷贝一份到每个群成员的消息同步队列的方案适用于小型群聊，原因如下：</p><ul><li>简化消息同步流程：每个客户端只需要检查自己的消息同步队列即可获取新消息，降低了复杂性。</li><li>小型群聊成员数量较少，为每个成员存储一份消息副本的代价可以接受。</li></ul><p><strong>局限性</strong>: 微信也采用了类似的方案，并且将群聊人数限制在了 500 人以内。但是，对于拥有大量成员的群聊来说，为每个成员存储一份消息的副本将造成非常大的存储开销，变得不可接受。</p><div class="flex flex-col items-center justify-center text-center"><div><img alt="Maple" loading="lazy" width="640" height="557" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/system/chat-system/picture15.webp"/> 图 15</div></div><h3 class="content-header" id="在线离线状态管理"><a href="#在线离线状态管理" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>在线/离线状态管理</h3><p>在线/离线指示器是许多聊天应用必不可少的功能，通常用户可以在其他用户的名字或头像旁边看到一个绿色的点，表示该用户是否在线。本节将介绍在线/离线指示器背后的实现原理。</p><p>在高级设计中，<strong>Presence Server</strong> (存在感服务器) 负责管理用户的在线状态，并通过 WebSocket 与客户端进行通信。以下是一些会触发用户在线状态改变的常见场景：</p><h4 class="content-header" id="用户登录"><a href="#用户登录" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>用户登录</h4><p>用户登录流程已经在 “服务发现” 章节有所提及。当客户端通过服务发现找到合适的聊天服务器并建立 WebSocket 连接后，用户 A 的在线状态和最后活跃时间戳 (<code class="custom-code">last_active_at</code>) 会被保存到键值存储中。此时，Presence Server 会通知客户端更新界面，显示用户 A 为在线状态。</p><div class="flex flex-col items-center justify-center text-center"><div><img alt="Maple" loading="lazy" width="640" height="165" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/system/chat-system/picture16.webp"/> 图 16</div></div><h4 class="content-header" id="用户登出"><a href="#用户登出" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>用户登出</h4><p>图 17 展示了用户登出时的流程。</p><ol><li>用户点击退出按钮，客户端向 Presence Server 发送下线消息。</li><li>Presence Server 收到下线消息后，会将该用户的状态更新为离线，并将其从在线用户列表中移除。</li><li>Presence Server 会向其他在线用户推送该用户下线的消息，更新其他用户的好友列表中的在线状态。</li><li>键值存储中，该用户的在线状态和最后活跃时间戳 (<code class="custom-code">last_active_at</code>) 也将被更新为反映离线状态。</li><li>客户端断开与 Presence Server 的 WebSocket 连接。</li></ol><div class="flex flex-col items-center justify-center text-center"><div><img alt="Maple" loading="lazy" width="640" height="130" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/system/chat-system/picture17.webp"/> 图 17</div></div><h4 class="content-header" id="用户断线"><a href="#用户断线" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>用户断线</h4><p>网络连接并不总是可靠稳定的。用户断线后，客户端与服务器之间会失去连接。一种简单粗暴的处理方式是将用户直接标记为离线，当重连后又将其标记为在线。然而，这种方式存在着明显的缺陷：</p><ul><li>用户在短时间内频繁断线和重连的情况很常见，例如在穿过隧道时网络信号可能会断断续续。</li><li>如果在线状态跟随每一次断线/重连进行更新，则 Presence 指示器将频繁闪烁，带来糟糕的用户体验。</li></ul><p>为了解决这个问题，我们引入了心跳检测机制。</p><ul><li>在线客户端会定期向 Presence Server 发送心跳包。</li><li>Presence Server 会记录收到心跳包的最后时间。</li><li>如果在 <strong>预设的超时时间</strong> (例如 x 秒) 内没有收到该用户的<strong>心跳包</strong>，Presence Server 会将该用户的状态标记为<strong>离线</strong>，并将其从在线用户列表中移除。</li><li>同时，Presence Server 会向其他在线用户推送该用户下线的消息，更新其他用户的好友列表中的在线状态。</li></ul><p>图 18 展示了一个示例：</p><div class="flex flex-col items-center justify-center text-center"><div><img alt="Maple" loading="lazy" width="782" height="623" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/system/chat-system/picture18.svg"/> 图 18</div></div><ul><li>客户端每隔 5 秒向服务器发送一个心跳包。</li><li>在发送了 3 个心跳包之后，客户端断线，并且在 <strong>超时时间 x = 30 秒</strong> 内没有重新连接 (此数值仅用于演示逻辑，实际超时时间需要根据具体情况设定)。</li><li>此时，Presence Server 会检测到心跳包超時，并将该用户的状态标记为离线。</li></ul><h4 class="content-header" id="在线状态推送"><a href="#在线状态推送" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>在线状态推送</h4><p>上文介绍了 Presence Server 如何跟踪用户在线状态，那么其他用户如何得知好友的在线状态更新呢？图 19 展示了常见的一种实现方式。</p><div class="flex flex-col items-center justify-center text-center"><div><img alt="Maple" loading="lazy" width="640" height="300" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/system/chat-system/picture19.webp"/> 图 19</div></div><p>Presence Server 采用发布-订阅 (Publish-Subscribe) 的模式来实现在线状态的推送。</p><ul><li>每个好友对之间会维护一个唯一的频道 (channel)。</li><li>当用户 A 的在线状态发生改变时，Presence Server 会将这个事件发布到与其相关的频道，例如 A-B、A-C 和 A-D 频道。</li><li>用户 B、C 和 D 分别订阅了与之对应的频道，因此他们可以及时收到好友 A 的在线状态更新消息。</li><li>客户端和服务器之间的通信通过实时的 WebSocket 连接进行。</li></ul><p>这种方案对于用户规模较小的场景是比较高效的。例如，微信将群聊人数限制在了 500 人以内，也采用了类似的发布-订阅模型进行在线状态推送。</p><p><strong>局限性</strong>:</p><p>对于用户规模较大的场景，例如一个拥有 100,000 名成员的群聊，当一名成员的在线状态发生变化时，需要向所有成员推送消息，会产生大量的事件 (100,000 个)，带来严重的性能瓶颈。</p><p><strong>解决方法</strong>:</p><ul><li>拉取在线状态 (Pull Updates): 仅在用户进入群聊或手动刷新好友列表时，再向服务器请求好友的在线状态。</li><li>其他优化方案: 还可以采用分级推送、批量更新等方式来优化在线状态推送的性能。</li></ul><h2 class="content-header" id="第四步---系统设计总结"><a href="#第四步---系统设计总结" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>第四步 - 系统设计总结</h2><p>该博客介绍了一个支持一对一聊天和小群聊的聊天系统架构。WebSocket 用于客户端和服务器之间的实时通信。聊天系统包含以下组件：</p><ul><li>用于实时消息传递的聊天服务器</li><li>用于管理在线状态的 Presence 服务器</li><li>用于发送推送通知的推送通知服务器</li><li>用于保存聊天历史记录的键值存储</li><li>用于提供其他功能的 API 服务器</li></ul><p>如果您在面试结束时还有额外的时间，可以讨论以下附加话题：</p><ul><li><strong>支持媒体文件</strong> 扩展聊天应用程序以支持照片和视频等媒体文件。媒体文件的大小远大于文本，我们可以讨论压缩、云存储和缩略图等相关技术。</li><li><strong>端到端加密</strong> Whatsapp 支持消息的端到端加密，只有发送者和接收者可以阅读消息。</li><li><strong>客户端缓存</strong> 在客户端缓存消息可以有效减少客户端和服务器之间的数据传输。</li><li><strong>优化加载时间</strong> Slack 构建了一个地理分布式网络来缓存用户的數據、频道等信息，从而改善加载时间。</li><li>错误处理<ul><li>聊天服务器错误：聊天服务器可能需要处理成千上万的持久连接。如果聊天服务器宕机，服务发现 (Zookeeper) 将为客户端提供新的聊天服务器以建立新的连接。</li><li>消息重发机制：重试和队列是常见的用于消息重发的技术。</li></ul></li></ul><p>恭喜您走到这一步！为自己的出色表现鼓掌吧！</p></div></div><div class="pb-6 pt-6 text-center text-gray-700 dark:text-gray-300" id="comment"></div><footer><div class="flex flex-col text-sm font-medium sm:flex-row sm:justify-between sm:text-base"><div class="pt-4 xl:pt-8"><a class="text-primary-500 hover:text-primary-600 dark:hover:text-primary-400" aria-label="Previous post: 从零到百万用户的扩展之路" href="/blog/system/design-system">← <!-- -->从零到百万用户的扩展之路</a></div><div class="pt-4 xl:pt-8"><a class="text-primary-500 hover:text-primary-600 dark:hover:text-primary-400" aria-label="Next post: JavaScript秘技：15个惊艳功能" href="/blog/frontend/javascript-trick">JavaScript秘技：15个惊艳功能<!-- --> →</a></div></div></footer></div></div></article></section></main><footer><div class="mt-16 flex flex-col items-center"><div class="mb-3 flex space-x-4"><a class="text-sm !text-gray-500 transition hover:text-gray-600" target="_blank" rel="noopener noreferrer" href="mailto:mainjaylai@outlook.com"><span class="sr-only">mail</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" class="fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6"><path d="M2.003 5.884L10 9.882l7.997-3.998A2 2 0 0016 4H4a2 2 0 00-1.997 1.884z"></path><path d="M18 8.118l-8 4-8-4V14a2 2 0 002 2h12a2 2 0 002-2V8.118z"></path></svg></a><a class="text-sm !text-gray-500 transition hover:text-gray-600" target="_blank" rel="noopener noreferrer" href="https://github.com/mainjaylai"><span class="sr-only">github</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6"><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg></a><a class="text-sm !text-gray-500 transition hover:text-gray-600" target="_blank" rel="noopener noreferrer" href="https://gitlab.com/JayMain"><span class="sr-only">gitlab</span><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6" width="200" height="200"><path d="M1022.08 579.712l-57.258667-176.426667-113.664-349.397333a19.413333 19.413333 0 0 0-36.992 0L700.501333 403.2H323.498667L209.877333 53.888C204.074667 35.84 178.56 35.84 172.8 53.76L59.136 403.157333 1.877333 579.712a39.424 39.424 0 0 0 14.122667 43.648L512 983.637333l496-360.234666a39.253333 39.253333 0 0 0 14.08-43.690667"></path></svg></a><a class="text-sm !text-gray-500 transition hover:text-gray-600" target="_blank" rel="noopener noreferrer" href="https://gitee.com/lmj2001"><span class="sr-only">gitee</span><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6" width="200" height="200"><path d="M512 992C246.895625 992 32 777.104375 32 512S246.895625 32 512 32s480 214.895625 480 480-214.895625 480-480 480z m242.9521875-533.3278125h-272.56875a23.7121875 23.7121875 0 0 0-23.71125 23.7121875l-0.024375 59.255625c0 13.08 10.6078125 23.7121875 23.6878125 23.7121875h165.96c13.104375 0 23.7121875 10.6078125 23.7121875 23.6878125v11.855625a71.1121875 71.1121875 0 0 1-71.1121875 71.1121875h-225.215625a23.7121875 23.7121875 0 0 1-23.6878125-23.7121875V423.1278125a71.1121875 71.1121875 0 0 1 71.0878125-71.1121875h331.824375a23.7121875 23.7121875 0 0 0 23.6878125-23.71125l0.0721875-59.2565625a23.7121875 23.7121875 0 0 0-23.68875-23.7121875H423.08a177.76875 177.76875 0 0 0-177.76875 177.7921875V754.953125c0 13.1034375 10.60875 23.7121875 23.713125 23.7121875h349.63125a159.984375 159.984375 0 0 0 159.984375-159.984375V482.36a23.7121875 23.7121875 0 0 0-23.7121875-23.6878125z"></path></svg></a></div><div class="mb-2 flex space-x-2 text-sm text-gray-500 dark:text-gray-400"><div>MainJayLai</div><div> • </div><div>© 2025</div><div> • </div><a href="/">MainJayLai Blog</a></div></div></footer></div></section><script src="/_next/static/chunks/webpack-8506c16620cf39fb.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/36966cca54120369-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/c890694439b2475b.css\",\"style\"]\n3:HL[\"/_next/static/css/1ea5cf861ee12a80.css\",\"style\"]\n4:HL[\"/_next/static/css/a9b9096fa657c0d0.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"5:I[5751,[],\"\"]\n8:I[9275,[],\"\"]\na:I[1343,[],\"\"]\nb:I[8700,[\"599\",\"static/chunks/ebde5ed1-51545511fe0d5050.js\",\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"850\",\"static/chunks/850-ecf153581cc02044.js\",\"185\",\"static/chunks/app/layout-54bebb918ae7f176.js\"],\"ThemeProviders\"]\nc:I[4080,[\"599\",\"static/chunks/ebde5ed1-51545511fe0d5050.js\",\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"850\",\"static/chunks/850-ecf153581cc02044.js\",\"185\",\"static/chunks/app/layout-54bebb918ae7f176.js\"],\"\"]\nd:I[9032,[\"599\",\"static/chunks/ebde5ed1-51545511fe0d5050.js\",\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"850\",\"static/chunks/850-ecf153581cc02044.js\",\"185\",\"static/chunks/app/layout-54bebb918ae7f176.js\"],\"KBarSearchProvider\"]\ne:I[231,[\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"797\",\"static/chunks/app/blog/%5B...slug%5D/page-bd056182432da53b.js\"],\"\"]\nf:I[8173,[\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"797\",\"static/chunks/app/blog/%5B...slug%5D/page-bd056182432da53b.js\"],\"Image\"]\n10:I[509,[\"599\",\"static/chunks/ebde5ed1-51545511fe0d5050.js\",\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"850\",\"static/chunks/850-ecf153581cc02044.js\",\"185\",\"static/chunks/app/layout-54bebb918ae7f176.js\"],\"KBarButton\"]\n11:I[1398,[\"599\",\"static/chunks/ebde5ed1-51545511fe0d5050.js\",\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"850\",\"static/chunks/850-ecf153581cc02044.js\",\"185\",\"static/chunks/app/layout-54bebb918ae7f176.js\"],\"default\"]\n12:I[7606,[\"599\",\"static/chunks/ebde5ed1-51545511fe0d5050.js\",\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"850\",\"static/chunks/850-ecf153581cc02044.js\",\"185\",\"static/chunks/app/layout-54bebb918ae7f176.js\"],\"default\"]\n13:I[7510,[\"599\",\"static/chunks/ebde5ed1-5"])</script><script>self.__next_f.push([1,"1545511fe0d5050.js\",\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"850\",\"static/chunks/850-ecf153581cc02044.js\",\"185\",\"static/chunks/app/layout-54bebb918ae7f176.js\"],\"default\"]\n14:I[8976,[\"599\",\"static/chunks/ebde5ed1-51545511fe0d5050.js\",\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"850\",\"static/chunks/850-ecf153581cc02044.js\",\"185\",\"static/chunks/app/layout-54bebb918ae7f176.js\"],\"default\"]\n16:I[6130,[],\"\"]\n9:[\"slug\",\"system/chat-system\",\"c\"]\n17:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/c890694439b2475b.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/1ea5cf861ee12a80.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L5\",null,{\"buildId\":\"AO1lBacSEqBfLSl9iFzzQ\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/blog/system/chat-system\",\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"system/chat-system\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"system\\\",\\\"chat-system\\\"]}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"system/chat-system\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L6\",\"$L7\"],null],null]},[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"$9\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/a9b9096fa657c0d0.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]]}],null]},[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"en-us\",\"className\":\"__variable_dd5b2f scroll-smooth\",\"suppressHydrationWarning\":true,\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"href\":\"https://mainjaylai.github.io/favicon.png\"}],[\"$\",\"link\",null,{\"rel\":\"manifest\",\"href\":\"/static/favicons/manifest.json\"}],[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#000000\"}],[\"$\",\"link\",null,{\"href\":\"https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@200..900\u0026display=swap\",\"rel\":\"stylesheet\"}],[\"$\",\"link\",null,{\"href\":\"https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe\u0026family=ZCOOL+QingKe+HuangYou\u0026family=ZCOOL+XiaoWei\u0026display=swap\",\"rel\":\"stylesheet\"}],[\"$\",\"script\",null,{\"src\":\"https://us.umami.is/script.js\",\"async\":true}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"media\":\"(prefers-color-scheme: light)\",\"content\":\"#fff\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"media\":\"(prefers-color-scheme: dark)\",\"content\":\"#000\"}],[\"$\",\"meta\",null,{\"name\":\"referrer\",\"content\":\"no-referrer\"}],[\"$\",\"script\",null,{\"src\":\"https://cdn.jsdelivr.net/gh/ashishagarwal2023/freegptjs@1.0.2/src/freegpt.min.js\"}],[\"$\",\"link\",null,{\"rel\":\"alternate\",\"type\":\"application/rss+xml\",\"href\":\"/feed.xml\"}]]}],[\"$\",\"body\",null,{\"className\":\"bg-white pl-[calc(100vw-100%)] text-black antialiased dark:bg-gray-950 dark:text-white\",\"suppressHydrationWarning\":true,\"children\":[\"$\",\"$Lb\",null,{\"children\":[[\"$undefined\",\"$undefined\",\"$undefined\",[\"$\",\"$Lc\",null,{\"async\":true,\"defer\":true,\"data-website-id\":\"bbe21cb3-3de3-4ba7-b6de-453053bc6ae8\",\"src\":\"https://us.umami.is/script.js\"}],\"$undefined\",\"$undefined\"],[\"$\",\"section\",null,{\"className\":\"mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex h-screen flex-col justify-between font-sans\",\"children\":[[\"$\",\"$Ld\",null,{\"kbarConfig\":{\"searchDocumentsPath\":\"/search.json\"},\"children\":[[\"$\",\"header\",null,{\"className\":\"flex items-center justify-between py-5\",\"children\":[[\"$\",\"div\",null,{\"children\":[\"$\",\"$Le\",null,{\"href\":\"/\",\"aria-label\":\"Blog\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex items-center justify-between\",\"children\":[[\"$\",\"div\",null,{\"className\":\"mr-3\",\"children\":[\"$\",\"$Lf\",null,{\"src\":\"https://mainjaylai.github.io/favicon.png\",\"width\":44,\"height\":44,\"alt\":\"logo\"}]}],[\"$\",\"div\",null,{\"className\":\"hidden h-[44px] text-center text-3xl font-semibold leading-10 sm:block\",\"children\":\"Blog\"}]]}]}]}],[\"$\",\"div\",null,{\"className\":\"flex items-center space-x-4 leading-5 sm:space-x-6\",\"children\":[[[\"$\",\"$Le\",null,{\"href\":\"/blog\",\"className\":\"navbar-item hidden font-medium text-gray-900 dark:text-gray-100 sm:block\",\"children\":\"Blog\"}],[\"$\",\"$Le\",null,{\"href\":\"/tags\",\"className\":\"navbar-item hidden font-medium text-gray-900 dark:text-gray-100 sm:block\",\"children\":\"Tags\"}],[\"$\",\"a\",null,{\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"href\":\"https://mainjaylai.github.io\",\"className\":\"navbar-item hidden font-medium text-gray-900 dark:text-gray-100 sm:block\",\"children\":\"About\"}]],[\"$\",\"$L10\",null,{\"aria-label\":\"Search\",\"children\":[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"fill\":\"none\",\"viewBox\":\"0 0 24 24\",\"strokeWidth\":1.5,\"stroke\":\"currentColor\",\"className\":\"h-6 w-6 text-gray-900 dark:text-gray-100\",\"children\":[\"$\",\"path\",null,{\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"d\":\"M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z\"}]}]}],[\"$\",\"$L11\",null,{}],[\"$\",\"$L12\",null,{}],[\"$\",\"$L13\",null,{}],[\"$\",\"$L14\",null,{}]]}]]}],[\"$\",\"main\",null,{\"className\":\"mb-auto\",\"children\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"flex flex-col items-start justify-start md:mt-24 md:flex-row md:items-center md:justify-center md:space-x-6\",\"children\":[[\"$\",\"div\",null,{\"className\":\"space-x-2 pb-8 pt-6 md:space-y-5\",\"children\":[\"$\",\"h1\",null,{\"className\":\"text-6xl font-extrabold leading-9 tracking-tight text-gray-900 dark:text-gray-100 md:border-r-2 md:px-6 md:text-8xl md:leading-14\",\"children\":\"404\"}]}],[\"$\",\"div\",null,{\"className\":\"max-w-md\",\"children\":[[\"$\",\"p\",null,{\"className\":\"mb-4 text-xl font-bold leading-normal md:text-2xl\",\"children\":\"Sorry we couldn't find this page.\"}],[\"$\",\"p\",null,{\"className\":\"mb-8\",\"children\":\"But dont worry, you can find plenty of other things on our homepage.\"}],[\"$\",\"$Le\",null,{\"href\":\"/\",\"className\":\"focus:shadow-outline-blue inline rounded-lg border border-transparent bg-blue-600 px-4 py-2 text-sm font-medium leading-5 text-white shadow transition-colors duration-150 hover:bg-blue-700 focus:outline-none dark:hover:bg-blue-500\",\"children\":\"Back to homepage\"}]]}]]}],\"notFoundStyles\":[],\"styles\":null}]}]]}],[\"$\",\"footer\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"mt-16 flex flex-col items-center\",\"children\":[[\"$\",\"div\",null,{\"className\":\"mb-3 flex space-x-4\",\"children\":[[\"$\",\"a\",null,{\"className\":\"text-sm !text-gray-500 transition hover:text-gray-600\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"href\":\"mailto:mainjaylai@outlook.com\",\"children\":[[\"$\",\"span\",null,{\"className\":\"sr-only\",\"children\":\"mail\"}],[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"viewBox\":\"0 0 20 20\",\"className\":\"fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M2.003 5.884L10 9.882l7.997-3.998A2 2 0 0016 4H4a2 2 0 00-1.997 1.884z\"}],[\"$\",\"path\",null,{\"d\":\"M18 8.118l-8 4-8-4V14a2 2 0 002 2h12a2 2 0 002-2V8.118z\"}]]}]]}],[\"$\",\"a\",null,{\"className\":\"text-sm !text-gray-500 transition hover:text-gray-600\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"href\":\"https://github.com/mainjaylai\",\"children\":[[\"$\",\"span\",null,{\"className\":\"sr-only\",\"children\":\"github\"}],[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"viewBox\":\"0 0 24 24\",\"className\":\"fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6\",\"children\":[\"$\",\"path\",null,{\"d\":\"M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12\"}]}]]}],[\"$\",\"a\",null,{\"className\":\"text-sm !text-gray-500 transition hover:text-gray-600\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"href\":\"https://gitlab.com/JayMain\",\"children\":[[\"$\",\"span\",null,{\"className\":\"sr-only\",\"children\":\"gitlab\"}],[\"$\",\"svg\",null,{\"viewBox\":\"0 0 1024 1024\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"className\":\"fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6\",\"width\":\"200\",\"height\":\"200\",\"children\":[\"$\",\"path\",null,{\"d\":\"M1022.08 579.712l-57.258667-176.426667-113.664-349.397333a19.413333 19.413333 0 0 0-36.992 0L700.501333 403.2H323.498667L209.877333 53.888C204.074667 35.84 178.56 35.84 172.8 53.76L59.136 403.157333 1.877333 579.712a39.424 39.424 0 0 0 14.122667 43.648L512 983.637333l496-360.234666a39.253333 39.253333 0 0 0 14.08-43.690667\"}]}]]}],[\"$\",\"a\",null,{\"className\":\"text-sm !text-gray-500 transition hover:text-gray-600\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"href\":\"https://gitee.com/lmj2001\",\"children\":[[\"$\",\"span\",null,{\"className\":\"sr-only\",\"children\":\"gitee\"}],[\"$\",\"svg\",null,{\"viewBox\":\"0 0 1024 1024\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"className\":\"fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6\",\"width\":\"200\",\"height\":\"200\",\"children\":[\"$\",\"path\",null,{\"d\":\"M512 992C246.895625 992 32 777.104375 32 512S246.895625 32 512 32s480 214.895625 480 480-214.895625 480-480 480z m242.9521875-533.3278125h-272.56875a23.7121875 23.7121875 0 0 0-23.71125 23.7121875l-0.024375 59.255625c0 13.08 10.6078125 23.7121875 23.6878125 23.7121875h165.96c13.104375 0 23.7121875 10.6078125 23.7121875 23.6878125v11.855625a71.1121875 71.1121875 0 0 1-71.1121875 71.1121875h-225.215625a23.7121875 23.7121875 0 0 1-23.6878125-23.7121875V423.1278125a71.1121875 71.1121875 0 0 1 71.0878125-71.1121875h331.824375a23.7121875 23.7121875 0 0 0 23.6878125-23.71125l0.0721875-59.2565625a23.7121875 23.7121875 0 0 0-23.68875-23.7121875H423.08a177.76875 177.76875 0 0 0-177.76875 177.7921875V754.953125c0 13.1034375 10.60875 23.7121875 23.713125 23.7121875h349.63125a159.984375 159.984375 0 0 0 159.984375-159.984375V482.36a23.7121875 23.7121875 0 0 0-23.7121875-23.6878125z\"}]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"mb-2 flex space-x-2 text-sm text-gray-500 dark:text-gray-400\",\"children\":[[\"$\",\"div\",null,{\"children\":\"MainJayLai\"}],[\"$\",\"div\",null,{\"children\":\" • \"}],[\"$\",\"div\",null,{\"children\":\"© 2025\"}],[\"$\",\"div\",null,{\"children\":\" • \"}],[\"$\",\"$Le\",null,{\"href\":\"/\",\"children\":\"MainJayLai Blog\"}]]}]]}]}]]}]}]]}]}]]}],null],null],\"couldBeIntercepted\":false,\"initialHead\":[false,\"$L15\"],\"globalErrorComponent\":\"$16\",\"missingSlots\":\"$W17\"}]]\n"])</script><script>self.__next_f.push([1,"18:I[4347,[\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"797\",\"static/chunks/app/blog/%5B...slug%5D/page-bd056182432da53b.js\"],\"default\"]\n19:I[9629,[\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"797\",\"static/chunks/app/blog/%5B...slug%5D/page-bd056182432da53b.js\"],\"default\"]\n"])</script><script>self.__next_f.push([1,"7:[[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"BlogPosting\\\",\\\"headline\\\":\\\"从零开始：如何设计一个现代化聊天系统\\\",\\\"datePublished\\\":\\\"2024-07-02T00:00:00.000Z\\\",\\\"dateModified\\\":\\\"2024-07-02T00:00:00.000Z\\\",\\\"description\\\":\\\"博客介绍了一种可扩展且可靠的聊天系统架构，该架构支持一对一和小群聊，并有可能扩展到处理媒体文件。该系统采用客户端-服务器架构，由聊天服务器、Presence 服务器、推送通知服务器、键值存储和 API 服务器组成。它利用了 WebSocket、服务发现、消息传递、在线状态管理和推送通知等技术。该架构具有可扩展性、高可用性和易用性等优点，使其适用于各种规模的聊天应用程序。\\\",\\\"image\\\":\\\"https://pngimg.com/uploads/github/github_PNG80.png\\\",\\\"url\\\":\\\"https://blog.mainjay.cloudns.ch/blog/system/chat-system\\\",\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"mainJayLai\\\"}]}\"}}],[\"$\",\"section\",null,{\"className\":\"mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0\",\"children\":[[\"$\",\"$L18\",null,{}],[\"$\",\"article\",null,{\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"header\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"space-y-1 border-b border-gray-200 pb-10 text-center dark:border-gray-700\",\"children\":[[\"$\",\"div\",null,{\"className\":\"beautiful-chinese-title\",\"children\":[\"$\",\"h1\",null,{\"className\":\"text-3xl font-extrabold leading-9 tracking-tight text-gray-900 dark:text-gray-100 sm:text-4xl sm:leading-10 md:text-5xl md:leading-14\",\"children\":\"从零开始：如何设计一个现代化聊天系统\"}]}],[\"$\",\"dl\",null,{\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"dt\",null,{\"className\":\"sr-only\",\"children\":\"Published on\"}],[\"$\",\"dd\",null,{\"className\":\"text-base font-medium leading-6 text-gray-500 dark:text-gray-400\",\"children\":[\"$\",\"time\",null,{\"dateTime\":\"2024-07-02T00:00:00.000Z\",\"children\":\"July 2, 2024\"}]}]]}]}]]}]}],[\"$\",\"div\",null,{\"className\":\"grid-rows-[auto_1fr] divide-y divide-gray-200 pb-8 dark:divide-gray-700 xl:divide-y-0\",\"children\":[[\"$\",\"div\",null,{\"className\":\"divide-y divide-gray-200 dark:divide-gray-700 xl:col-span-3 xl:row-span-2 xl:pb-0\",\"children\":[\"$\",\"div\",null,{\"className\":\"beautiful-chinese-content prose max-w-none pb-8 pt-10 dark:prose-invert\",\"children\":[[\"$\",\"p\",null,{\"children\":\"在当今数字化时代，聊天系统已成为我们日常生活和工作中不可或缺的一部分。从个人交流到团队协作，从客户服务到社交网络，聊天应用程序在各个领域都发挥着重要作用。正因如此，理解并掌握聊天系统的设计原理对于软件工程师来说尤为重要。\"}],[\"$\",\"p\",null,{\"children\":\"该博客将深入探讨聊天系统的设计，涵盖从基础架构到高级功能的各个方面。我们将分析当前市场上流行的聊天应用，研究它们的成功之处，并探讨如何将这些经验应用到我们自己的设计中。\"}],[\"$\",\"p\",null,{\"children\":\"图1呈现了目前市场上最受欢迎的几款聊天应用。这些应用之所以能够脱颖而出，不仅因为它们满足了用户的基本通讯需求，还因为它们在用户体验、功能创新和技术实现上都有独到之处。通过学习这些成功案例，我们可以更好地理解用户需求，把握技术趋势，从而设计出更加优秀的聊天系统。\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Lf\",null,{\"src\":\"/static/images/system/chat-system/picture1.webp\",\"alt\":\"Maple\",\"width\":\"640\",\"height\":\"196\"}],\" 图 1\"]}]}],[\"$\",\"p\",null,{\"children\":\"在开始设计聊天系统之前，明确系统的具体需求是至关重要的。聊天应用的多样性意味着它们可以服务于广泛的用途和用户群体，因此在设计过程中，我们需要特别注意以下几点：\"}],[\"$\",\"ol\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"明确目标用户： 是面向普通消费者的即时通讯工具，还是针对企业内部沟通的协作平台？了解目标用户群体有助于确定核心功能和用户界面设计。\"}],[\"$\",\"li\",null,{\"children\":\"确定主要使用场景： 是以一对一聊天为主，还是以群组交流为重点？不同的使用场景会影响系统的架构设计和功能优先级。\"}],[\"$\",\"li\",null,{\"children\":\"功能需求分析： 除了基本的文字聊天，是否需要支持语音通话、视频会议、文件传输等功能？每增加一项功能都会影响系统的复杂度和资源需求。\"}],[\"$\",\"li\",null,{\"children\":\"性能要求： 系统需要支持多少同时在线用户？消息传递的延迟要求是什么？这些因素会直接影响到系统的架构设计和技术选型。\"}],[\"$\",\"li\",null,{\"children\":\"安全性和隐私考虑： 是否需要端到端加密？如何保护用户数据？在某些应用场景中，这可能是最关键的需求之一。\"}],[\"$\",\"li\",null,{\"children\":\"可扩展性： 系统是否需要能够快速扩展以适应用户增长？这将影响到底层架构的设计。\"}],[\"$\",\"li\",null,{\"children\":\"跨平台支持： 是否需要支持多种设备和操作系统？这会影响到客户端的开发策略。\"}],[\"$\",\"li\",null,{\"children\":\"集成需求： 是否需要与其他系统或服务集成？例如，与社交媒体平台或企业管理系统的集成。\"}]]}],[\"$\",\"p\",null,{\"children\":\"好的系统设计始于对需求的深入理解。在实际工作中，这个阶段可能需要多次迭代和讨论。通过仔细分析和明确需求，我们可以为接下来的设计过程奠定坚实的基础，最终交付一个既满足用户需求又技术先进的聊天系统。\"}],[\"$\",\"h2\",null,{\"className\":\"content-header\",\"id\":\"第一步---理解问题并确立设计范围\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#第一步---理解问题并确立设计范围\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"第一步 - 理解问题并确立设计范围\"]}],[\"$\",\"p\",null,{\"children\":\"确定要设计的聊天应用类型至关重要。市场上有各种类型的聊天应用，如专注于一对一聊天的Facebook Messenger、微信和WhatsApp，侧重群聊的办公应用Slack，以及注重大群交互和低延迟语音聊天的游戏聊天应用Discord。\"}],[\"$\",\"p\",null,{\"children\":\"在该博客中，我们专注于设计一个类似Facebook Messenger的聊天应用，重点关注以下功能：\"}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"低延迟的一对一聊天\"}],[\"$\",\"li\",null,{\"children\":\"小型群聊（最多100人）\"}],[\"$\",\"li\",null,{\"children\":\"在线状态显示\"}],[\"$\",\"li\",null,{\"children\":\"多设备支持。同一账户可以同时登录多个设备。\"}],[\"$\",\"li\",null,{\"children\":\"推送通知\"}]]}],[\"$\",\"p\",null,{\"children\":\"确定设计规模也很重要。我们将设计一个支持5000万日活跃用户的系统。这些需求为我们的设计提供了清晰的框架和边界。通过明确这些关键点，我们可以更有针对性地进行系统设计，避免在不必要的功能上浪费时间，同时确保能够满足核心需求和性能指标。\"}],[\"$\",\"p\",null,{\"children\":\"在实际的系统设计中，这个阶段的重要性往往被低估。然而，正是这个阶段的深入讨论和明确定义，为后续的架构设计和技术选型奠定了基础。它不仅有助于我们集中精力于最关键的功能，还能帮助我们预见可能遇到的挑战和瓶颈。例如，知道系统需要支持5000万日活跃用户，我们就可以开始考虑如何设计一个高度可扩展的架构。了解到需要支持多设备登录，我们就需要考虑如何同步不同设备间的消息和状态。而\\\"永久存储聊天历史\\\"这一需求则提醒我们需要设计一个高效的数据存储和检索系统。\"}],[\"$\",\"p\",null,{\"children\":\"通过这个过程，我们不仅明确了设计目标，还初步勾勒出了系统的轮廓。这为接下来的详细设计和技术讨论提供了明确的方向，使我们能够更有效地进行后续的设计工作。\"}],[\"$\",\"h2\",null,{\"className\":\"content-header\",\"id\":\"第二步---提出高层设计并获得认可\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#第二步---提出高层设计并获得认可\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"第二步 - 提出高层设计并获得认可\"]}],[\"$\",\"p\",null,{\"children\":\"要开发高质量的设计，我们应该对客户端和服务器如何通信有基本的了解。在聊天系统中，客户端可以是移动应用或网页应用。客户端之间不直接通信，而是每个客户端连接到一个支持上述所有功能的聊天服务。让我们专注于基本操作。聊天服务必须支持以下功能：\"}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"接收来自其他客户端的消息。\"}],[\"$\",\"li\",null,{\"children\":\"为每条消息找到正确的接收者并将消息转发给接收者。\"}],[\"$\",\"li\",null,{\"children\":\"如果接收者不在线，则在服务器上保留该接收者的消息，直到他们上线。\"}]]}],[\"$\",\"p\",null,{\"children\":\"图2展示了客户端（发送者和接收者）与聊天服务之间的关系。\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Lf\",null,{\"src\":\"/static/images/system/chat-system/picture2.webp\",\"alt\":\"Maple\",\"width\":\"640\",\"height\":\"114\"}],\" 图 2\"]}]}],[\"$\",\"p\",null,{\"children\":\"当客户端打算开始聊天时，它使用一个或多个网络协议连接聊天服务。对于聊天服务来说，网络协议的选择很重要。\"}],[\"$\",\"p\",null,{\"children\":\"对于大多数客户端/服务器应用程序，请求是由客户端发起的。这对聊天应用的发送方也是如此。在图2中，当发送者通过聊天服务向接收者发送消息时，它使用经过时间考验的HTTP协议，这是最常见的网络协议。在这种情况下，客户端与聊天服务建立HTTP连接并发送消息，通知服务将消息发送给接收者。这里使用keep-alive很有效，因为keep-alive头允许客户端与聊天服务保持持久连接，同时也减少了TCP握手的次数。HTTP在发送方是一个不错的选择，许多流行的聊天应用，如Facebook，最初就使用HTTP发送消息。\"}],[\"$\",\"p\",null,{\"children\":\"然而，接收方的情况稍微复杂一些。由于HTTP是客户端发起的，从服务器发送消息并不简单。多年来，许多技术被用来模拟服务器发起的连接：轮询（polling）、长轮询（long polling）和WebSocket。这些都是系统设计面试中广泛使用的重要技术，让我们逐一研究。\"}],[\"$\",\"h3\",null,{\"className\":\"content-header\",\"id\":\"轮询polling\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#轮询polling\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"轮询（Polling）\"]}],[\"$\",\"p\",null,{\"children\":\"如图3所示，轮询是一种客户端定期询问服务器是否有可用消息的技术。根据轮询频率的不同，轮询可能会消耗大量资源。它可能会消耗宝贵的服务器资源来回答一个大多数时候答案都是\\\"否\\\"的问题。\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Lf\",null,{\"src\":\"/static/images/system/chat-system/picture3.svg\",\"alt\":\"Maple\",\"width\":\"601\",\"height\":\"641\"}],\" 图 3\"]}]}],[\"$\",\"ol\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"工作原理\"}],\"：\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"客户端以固定的时间间隔向服务器发送HTTP请求。\"}],[\"$\",\"li\",null,{\"children\":\"服务器立即响应，无论是否有新的消息可用。\"}],[\"$\",\"li\",null,{\"children\":\"如果有新消息，服务器会在响应中包含这些消息。\"}],[\"$\",\"li\",null,{\"children\":\"如果没有新消息，服务器会发送一个空响应。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"优点\"}],\"：\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"实现简单：客户端和服务器端的逻辑都相对直接。\"}],[\"$\",\"li\",null,{\"children\":\"兼容性好：几乎所有的浏览器和服务器都支持这种方式。\"}],[\"$\",\"li\",null,{\"children\":\"防火墙友好：使用标准的HTTP请求，不会被防火墙阻挡。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"缺点\"}],\"：\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"资源浪费：即使没有新消息，也会频繁发送请求，浪费带宽和服务器资源。\"}],[\"$\",\"li\",null,{\"children\":\"实时性差：消息的接收存在延迟，取决于轮询间隔。\"}],[\"$\",\"li\",null,{\"children\":\"服务器负载高：当有大量客户端同时轮询时，可能会给服务器带来巨大压力。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"优化策略\"}],\"：\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"自适应轮询间隔：根据消息频率动态调整轮询间隔。\"}],[\"$\",\"li\",null,{\"children\":\"批量获取消息：每次轮询获取多条消息，减少请求次数。\"}],[\"$\",\"li\",null,{\"children\":\"结合其他技术：例如，可以用轮询来检查是否有新消息，有的话再建立更高效的连接获取消息内容。\"}]]}]]}]]}],[\"$\",\"p\",null,{\"children\":\"在设计聊天系统时，轮询可能会作为一种降级策略或备用方案使用，例如当WebSocket连接失败时。但对于主要的消息传递机制，我们通常会选择更高效的方法，如WebSocket或长轮询。\"}],[\"$\",\"h3\",null,{\"className\":\"content-header\",\"id\":\"长轮询long-polling\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#长轮询long-polling\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"长轮询（Long Polling）\"]}],[\"$\",\"p\",null,{\"children\":\"由于轮询可能效率低下，下一个进展是长轮询（如图4所示）。\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Lf\",null,{\"src\":\"/static/images/system/chat-system/picture4.svg\",\"alt\":\"Maple\",\"width\":\"711\",\"height\":\"641\"}],\" 图 4\"]}]}],[\"$\",\"p\",null,{\"children\":\"在长轮询中，客户端保持连接打开，直到实际有新消息可用或达到超时阈值。一旦客户端接收到新消息，它立即向服务器发送另一个请求，重新启动这个过程。长轮询有几个缺点：\"}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"发送者和接收者可能不会连接到同一个聊天服务器。基于HTTP的服务器通常是无状态的。如果您使用轮询（Round Robin）进行负载均衡，接收消息的服务器可能与接收消息的客户端没有长轮询连接。\"}],[\"$\",\"li\",null,{\"children\":\"服务器没有好的方法来判断客户端是否已断开连接。\"}],[\"$\",\"li\",null,{\"children\":\"它是低效的。如果用户不经常聊天，长轮询仍会在超时后定期建立连接。\"}]]}],[\"$\",\"ol\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"工作原理\"}],\"：\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"客户端向服务器发送HTTP请求。\"}],[\"$\",\"li\",null,{\"children\":\"如果服务器没有可用的新数据，不会立即发送响应，而是保持请求打开。\"}],[\"$\",\"li\",null,{\"children\":\"当新数据可用时，服务器立即响应该请求。\"}],[\"$\",\"li\",null,{\"children\":\"客户端收到响应后，立即发送新的请求，重新开始这个过程。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"优点\"}],\"：\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"相比简单轮询，减少了不必要的请求和响应。\"}],[\"$\",\"li\",null,{\"children\":\"能够更接近实时地接收消息。\"}],[\"$\",\"li\",null,{\"children\":\"使用标准的HTTP协议，兼容性好。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"缺点\"}],\"：\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"服务器资源消耗：长时间保持连接可能会占用服务器资源。\"}],[\"$\",\"li\",null,{\"children\":\"可能的延迟：如果消息恰好在一个长轮询请求结束后到达，需要等待下一个请求才能接收。\"}],[\"$\",\"li\",null,{\"children\":\"连接管理复杂：需要处理连接超时、重连等情况。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"分布式系统中的挑战\"}],\"：\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"消息路由：在多服务器环境中，接收消息的服务器可能不是持有长轮询连接的服务器。\"}],[\"$\",\"li\",null,{\"children\":\"需要额外的机制（如消息队列或发布-订阅系统）来确保消息能正确地路由到持有客户端连接的服务器。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"优化策略\"}],\"：\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"使用超时机制：设置合理的超时时间，平衡实时性和资源消耗。\"}],[\"$\",\"li\",null,{\"children\":\"自适应超时：根据用户活跃度动态调整超时时间。\"}],[\"$\",\"li\",null,{\"children\":\"批量处理：在一个响应中返回多条消息，提高效率。\"}]]}]]}]]}],[\"$\",\"p\",null,{\"children\":\"在设计聊天系统时，长轮询可能是一个折中的选择，特别是在不支持WebSocket的环境中。然而，对于大规模、高并发的聊天应用，WebSocket通常是更好的选择。理解长轮询的这些特性和局限性，有助于我们在系统设计中做出更informed的决策，选择最适合特定需求和约束的技术方案。\"}],[\"$\",\"h3\",null,{\"className\":\"content-header\",\"id\":\"websocket\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#websocket\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"WebSocket\"]}],[\"$\",\"p\",null,{\"children\":\"WebSocket是从服务器向客户端发送异步更新最常用的解决方案。图5展示了它的工作原理。\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Lf\",null,{\"src\":\"/static/images/system/chat-system/picture5.svg\",\"alt\":\"Maple\",\"width\":\"521\",\"height\":\"321\"}],\" 图 5\"]}]}],[\"$\",\"p\",null,{\"children\":\"WebSocket连接由客户端发起。它是双向的且持久的。它最初作为HTTP连接开始，然后通过一些定义良好的握手过程\\\"升级\\\"为WebSocket连接。通过这个持久连接，服务器可以向客户端发送更新。WebSocket连接通常即使在有防火墙的情况下也能工作。这是因为它们使用80或443端口，这也是HTTP/HTTPS连接使用的端口。\"}],[\"$\",\"p\",null,{\"children\":\"早些时候我们说在发送方使用HTTP协议就足够了，但由于WebSocket是双向的，从技术上讲没有强烈的理由不也将其用于发送。图6展示了如何在发送方和接收方都使用WebSocket（ws）。\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Lf\",null,{\"src\":\"/static/images/system/chat-system/picture6.webp\",\"alt\":\"Maple\",\"width\":\"384\",\"height\":\"220\"}],\" 图 6\"]}]}],[\"$\",\"p\",null,{\"children\":\"通过在发送和接收两端都使用WebSocket，可以简化设计并使客户端和服务器端的实现更加直接。由于WebSocket连接是持久的，在服务器端进行高效的连接管理至关重要。\"}],[\"$\",\"ol\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"工作原理\"}],\"：\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"客户端初始化WebSocket连接请求。\"}],[\"$\",\"li\",null,{\"children\":\"服务器响应并升级连接从HTTP到WebSocket。\"}],[\"$\",\"li\",null,{\"children\":\"建立全双工、持久的连接通道。\"}],[\"$\",\"li\",null,{\"children\":\"客户端和服务器可以随时互相发送消息。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"优点\"}],\"：\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"实时性强：消息可以立即双向传递。\"}],[\"$\",\"li\",null,{\"children\":\"效率高：相比HTTP，减少了连接建立和头部信息的开销。\"}],[\"$\",\"li\",null,{\"children\":\"支持推送：服务器可以主动向客户端推送消息。\"}],[\"$\",\"li\",null,{\"children\":\"跨平台：广泛支持，包括Web、移动和桌面应用。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"在聊天系统中的应用\"}],\"：\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"即时消息传递：消息可以立即发送和接收。\"}],[\"$\",\"li\",null,{\"children\":\"在线状态更新：可以实时通知用户状态变化。\"}],[\"$\",\"li\",null,{\"children\":\"多设备同步：可以轻松实现跨设备的消息同步。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"性能考虑\"}],\"：\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"连接管理：需要有效管理大量并发的长连接。\"}],[\"$\",\"li\",null,{\"children\":\"心跳机制：实现心跳来保持连接活跃并检测断开。\"}],[\"$\",\"li\",null,{\"children\":\"重连策略：在连接断开时实现智能重连机制。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"安全性\"}],\"：\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"加密：WebSocket支持WSS（WebSocket Secure），类似于HTTPS。\"}],[\"$\",\"li\",null,{\"children\":\"认证：初始连接时可以进行身份验证。\"}],[\"$\",\"li\",null,{\"children\":\"消息验证：可以实现消息级别的安全检查。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"扩展性设计\"}],\"：\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"负载均衡：使用专门的WebSocket负载均衡器。\"}],[\"$\",\"li\",null,{\"children\":\"集群化：实现WebSocket服务器的集群以提高可用性。\"}],[\"$\",\"li\",null,{\"children\":\"消息队列：使用消息队列系统来处理大量并发消息。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"客户端实现注意事项\"}],\"：\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"断线重连：实现自动重连机制。\"}],[\"$\",\"li\",null,{\"children\":\"消息缓存：在断线期间缓存消息，重连后发送。\"}],[\"$\",\"li\",null,{\"children\":\"状态同步：重连后同步离线期间的状态变化。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"服务器端实现注意事项\"}],\"：\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"连接池管理：高效管理大量并发连接。\"}],[\"$\",\"li\",null,{\"children\":\"资源限制：设置合理的连接数限制和超时机制。\"}],[\"$\",\"li\",null,{\"children\":\"消息路由：在分布式系统中正确路由消息到指定的接收者。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"移动端特殊考虑\"}],\"：\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"电池影响：保持长连接可能增加电池消耗，需要智能管理连接。\"}],[\"$\",\"li\",null,{\"children\":\"网络切换：在网络状态变化时（如从WiFi切换到4G）保持连接的策略。\"}]]}]]}]]}],[\"$\",\"p\",null,{\"children\":\"在设计大规模聊天系统时，WebSocket通常是首选的技术。它提供了实时性、效率和灵活性。然而，成功实施WebSocket还需要考虑诸多因素，包括连接管理、扩展性、安全性和异常处理等。通过仔细设计和优化这些方面，可以构建出高效、可靠的实时聊天系统。\"}],[\"$\",\"h3\",null,{\"className\":\"content-header\",\"id\":\"高层设计\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#高层设计\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"高层设计\"]}],[\"$\",\"p\",null,{\"children\":\"我们刚才提到选择WebSocket作为客户端和服务器之间的主要通信协议，因为它支持双向通信。但重要的是要注意，其他所有功能并不一定都要使用WebSocket。实际上，聊天应用的大多数功能（如注册、登录、用户资料等）都可以使用传统的HTTP请求/响应方法。让我们深入探讨一下系统的高层组件。\"}],[\"$\",\"p\",null,{\"children\":\"如图7所示，聊天系统被分为三大类：无状态服务、有状态服务和第三方集成。\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Lf\",null,{\"src\":\"/static/images/system/chat-system/picture7.webp\",\"alt\":\"Maple\",\"width\":\"640\",\"height\":\"828\"}],\" 图 7\"]}]}],[\"$\",\"h4\",null,{\"className\":\"content-header\",\"id\":\"无状态服务\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#无状态服务\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"无状态服务\"]}],[\"$\",\"p\",null,{\"children\":\"无状态服务是传统的面向公众的请求/响应服务，用于管理登录、注册、用户资料等。这些是许多网站和应用程序中常见的功能。\"}],[\"$\",\"p\",null,{\"children\":\"无状态服务位于负载均衡器之后，负载均衡器的工作是根据请求路径将请求路由到正确的服务。这些服务可以是单体的或独立的微服务。我们不需要自己构建许多这些无状态服务，因为市场上有可以轻松集成的服务。我们将在深入探讨中更多讨论的一个服务是服务发现。它的主要工作是为客户端提供一个客户端可以连接的聊天服务器的DNS主机名列表。\"}],[\"$\",\"ol\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":[[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"特征\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"不保存客户端会话状态。\"}],[\"$\",\"li\",null,{\"children\":\"每个请求都是独立的，包含处理该请求所需的所有信息。\"}],[\"$\",\"li\",null,{\"children\":\"可以轻松扩展，因为任何服务器都可以处理任何请求。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"常见的无状态服务\"}],\"：\"]}],[\"$\",\"p\",null,{\"children\":[\"a) \",[\"$\",\"strong\",null,{\"children\":\"认证服务\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"处理用户登录和注册。\"}],[\"$\",\"li\",null,{\"children\":\"可能使用JWT（JSON Web Tokens）来管理用户会话。\"}],[\"$\",\"li\",null,{\"children\":\"集成第三方认证（如OAuth）。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"b) \",[\"$\",\"strong\",null,{\"children\":\"用户资料服务\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"管理用户个人信息。\"}],[\"$\",\"li\",null,{\"children\":\"处理资料更新请求。\"}],[\"$\",\"li\",null,{\"children\":\"可能集成头像存储和处理功能。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"c) \",[\"$\",\"strong\",null,{\"children\":\"好友管理服务\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"处理添加、删除、阻止好友的请求。\"}],[\"$\",\"li\",null,{\"children\":\"管理好友列表。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"d) \",[\"$\",\"strong\",null,{\"children\":\"消息历史服务\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"提供历史消息的存储和检索。\"}],[\"$\",\"li\",null,{\"children\":\"可能涉及分页和搜索功能。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"e) \",[\"$\",\"strong\",null,{\"children\":\"文件传输服务\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"处理文件上传和下载。\"}],[\"$\",\"li\",null,{\"children\":\"可能集成云存储服务。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"服务发现\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"为客户端提供可用聊天服务器的列表。\"}],[\"$\",\"li\",null,{\"children\":\"可以使用DNS轮询或更复杂的服务发现机制。\"}],[\"$\",\"li\",null,{\"children\":\"帮助实现负载均衡和故障转移。\"}]]}]]}]]}],[\"$\",\"h4\",null,{\"className\":\"content-header\",\"id\":\"有状态服务\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#有状态服务\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"有状态服务\"]}],[\"$\",\"p\",null,{\"children\":\"唯一的有状态服务是聊天服务。这个服务是有状态的，因为每个客户端都与一个聊天服务器保持持久的网络连接。在这个服务中，只要服务器仍然可用，客户端通常不会切换到另一个聊天服务器。服务发现与聊天服务密切协调，以避免服务器过载。我们将在深入探讨中详细介绍。\"}],[\"$\",\"ol\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":[[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"特征\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"维护客户端的会话状态。\"}],[\"$\",\"li\",null,{\"children\":\"使用持久连接（通常是WebSocket）。\"}],[\"$\",\"li\",null,{\"children\":\"每个客户端通常与特定服务器实例保持长期连接。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"聊天服务的核心功能\"}],\"：\"]}],[\"$\",\"p\",null,{\"children\":[\"a) \",[\"$\",\"strong\",null,{\"children\":\"连接管理\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"建立和维护WebSocket连接。\"}],[\"$\",\"li\",null,{\"children\":\"处理连接的认证和授权。\"}],[\"$\",\"li\",null,{\"children\":\"实现心跳机制以检测连接状态。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"b) \",[\"$\",\"strong\",null,{\"children\":\"消息路由\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"接收来自客户端的消息并转发给正确的接收者。\"}],[\"$\",\"li\",null,{\"children\":\"处理一对一聊天和群组聊天的消息分发。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"c) \",[\"$\",\"strong\",null,{\"children\":\"在线状态跟踪\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"实时更新和广播用户的在线/离线状态。\"}],[\"$\",\"li\",null,{\"children\":\"管理用户的\\\"正在输入\\\"状态。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"d) \",[\"$\",\"strong\",null,{\"children\":\"消息持久化\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"将消息存储到数据库以供历史记录查询。\"}],[\"$\",\"li\",null,{\"children\":\"处理离线消息的存储和后续发送。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"服务发现与负载均衡\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"与服务发现组件协作，动态分配客户端到合适的服务器。\"}],[\"$\",\"li\",null,{\"children\":\"实现智能负载均衡策略，考虑服务器负载、地理位置等因素。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"扩展性考虑\"}],\"：\"]}],[\"$\",\"p\",null,{\"children\":[\"a) \",[\"$\",\"strong\",null,{\"children\":\"水平扩展\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"增加服务器实例以处理更多并发连接。\"}],[\"$\",\"li\",null,{\"children\":\"实现无状态的会话管理，允许在服务器之间迁移连接。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"b) \",[\"$\",\"strong\",null,{\"children\":\"分片\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"基于用户ID或聊天室ID进行数据分片。\"}],[\"$\",\"li\",null,{\"children\":\"确保相关的用户或群组被路由到同一服务器或服务器组。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"高可用性\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"实现故障检测和自动故障转移机制。\"}],[\"$\",\"li\",null,{\"children\":\"使用多区域部署以提高可用性和减少延迟。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"性能优化\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"使用内存数据库（如Redis）存储临时数据和状态信息。\"}],[\"$\",\"li\",null,{\"children\":\"实现消息的批处理和异步处理。\"}],[\"$\",\"li\",null,{\"children\":\"优化数据库操作，如使用写入缓冲和读取缓存。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"安全性\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"实现端到端加密以保护消息内容。\"}],[\"$\",\"li\",null,{\"children\":\"使用安全的WebSocket连接（WSS）。\"}],[\"$\",\"li\",null,{\"children\":\"实施速率限制以防止滥用。\"}]]}]]}]]}],[\"$\",\"h4\",null,{\"className\":\"content-header\",\"id\":\"第三方集成\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#第三方集成\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"第三方集成\"]}],[\"$\",\"p\",null,{\"children\":\"对于聊天应用来说，推送通知是最重要的第三方集成。它是一种在应用程序未运行时也能通知用户有新消息到达的方式。正确集成推送通知至关重要。\"}],[\"$\",\"ol\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":[[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"推送通知系统\"}],\"：\"]}],[\"$\",\"p\",null,{\"children\":\"a) 重要性：\"}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"保持用户参与度。\"}],[\"$\",\"li\",null,{\"children\":\"确保重要消息及时送达。\"}],[\"$\",\"li\",null,{\"children\":\"提高用户回复率和应用使用频率。\"}]]}],[\"$\",\"p\",null,{\"children\":\"b) 主要功能：\"}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"发送新消息通知。\"}],[\"$\",\"li\",null,{\"children\":\"群组活动提醒。\"}],[\"$\",\"li\",null,{\"children\":\"系统公告和更新通知。\"}]]}],[\"$\",\"p\",null,{\"children\":\"c) 实现考虑：\"}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":[\"集成主要平台的推送服务：\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"iOS: Apple Push Notification Service (APNS)\"}],[\"$\",\"li\",null,{\"children\":\"Android: Firebase Cloud Messaging (FCM)\"}]]}]]}],[\"$\",\"li\",null,{\"children\":\"处理不同设备类型和操作系统版本。\"}],[\"$\",\"li\",null,{\"children\":\"实现智能通知策略，避免过度打扰用户。\"}],[\"$\",\"li\",null,{\"children\":\"支持富媒体通知（如图片、动作按钮等）。\"}]]}],[\"$\",\"p\",null,{\"children\":\"d) 挑战：\"}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"确保通知的及时性和可靠性。\"}],[\"$\",\"li\",null,{\"children\":\"处理设备令牌更新和失效。\"}],[\"$\",\"li\",null,{\"children\":\"遵守平台特定的限制和最佳实践。\"}]]}],[\"$\",\"p\",null,{\"children\":\"e) 优化：\"}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"实现批量推送以提高效率。\"}],[\"$\",\"li\",null,{\"children\":\"使用本地化内容增强用户体验。\"}],[\"$\",\"li\",null,{\"children\":\"提供通知设置，允许用户自定义通知偏好。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"其他潜在的第三方集成\"}],\"：\"]}],[\"$\",\"p\",null,{\"children\":[\"a) \",[\"$\",\"strong\",null,{\"children\":\"身份验证服务\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"集成如 OAuth、OpenID Connect 的标准协议。\"}],[\"$\",\"li\",null,{\"children\":\"支持社交媒体登录（如 Facebook、Google、Twitter）。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"b) \",[\"$\",\"strong\",null,{\"children\":\"内容审核服务\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"使用 AI 驱动的内容审核服务来过滤不当内容。\"}],[\"$\",\"li\",null,{\"children\":\"实现实时文本和图像审核。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"c) \",[\"$\",\"strong\",null,{\"children\":\"语音和视频通话\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"集成如 Twilio、Agora 或 WebRTC 的服务。\"}],[\"$\",\"li\",null,{\"children\":\"支持一对一和群组音视频通话。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"d) \",[\"$\",\"strong\",null,{\"children\":\"文件存储和共享\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"使用云存储服务如 AWS S3、Google Cloud Storage。\"}],[\"$\",\"li\",null,{\"children\":\"支持大文件传输和多媒体内容分享。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"e) \",[\"$\",\"strong\",null,{\"children\":\"翻译服务\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"集成如 Google Translate 或 DeepL 的 API。\"}],[\"$\",\"li\",null,{\"children\":\"提供实时消息翻译功能。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"f) \",[\"$\",\"strong\",null,{\"children\":\"分析和监控\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"使用如 Google Analytics、Mixpanel 的服务跟踪用户行为。\"}],[\"$\",\"li\",null,{\"children\":\"集成错误追踪工具如 Sentry 或 Crashlytics。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"g) \",[\"$\",\"strong\",null,{\"children\":\"支付系统\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[\"$\",\"li\",null,{\"children\":\"如果应用涉及电子商务功能，集成支付网关。\"}]}],[\"$\",\"p\",null,{\"children\":[\"h) \",[\"$\",\"strong\",null,{\"children\":\"地理位置服务\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"集成地图服务如 Google Maps 或 Mapbox。\"}],[\"$\",\"li\",null,{\"children\":\"支持位置共享功能。\"}]]}]]}]]}],[\"$\",\"h4\",null,{\"className\":\"content-header\",\"id\":\"可扩展性\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#可扩展性\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"可扩展性\"]}],[\"$\",\"ol\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"单服务器的理论可能性\"}],\"：从理论上讲，即使是为100万并发用户设计的系统，也可能在一个现代云服务器上容纳所有用户连接。假设每个用户连接需要10KB的服务器内存，100万用户仅需要约10GB内存。这个估算确实展示了现代硬件的强大能力。\"]}]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"单服务器设计的问题\"}],\"：尽管理论上可行，但在实际的系统设计中，单服务器方案确实会引起严重的担忧。您正确地指出，没有技术专家会为如此规模的系统设计单服务器方案。主要问题包括：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"单点故障：这是最大的问题。服务器故障将导致整个系统瘫痪。\"}],[\"$\",\"li\",null,{\"children\":\"可扩展性限制：难以应对突发流量或未来增长。\"}],[\"$\",\"li\",null,{\"children\":\"维护困难：升级或维护需要停机。\"}],[\"$\",\"li\",null,{\"children\":\"性能瓶颈：单服务器的处理能力和I/O终将成为瓶颈。\"}],[\"$\",\"li\",null,{\"children\":\"地理分布：难以为全球用户提供低延迟服务。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"从单服务器开始的策略\"}],\"：在系统设计面试中，从单服务器设计开始是一个很好的策略，只要确保面试官知道这只是起点。这种方法有几个优点：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"简化初始讨论，聚焦于核心功能。\"}],[\"$\",\"li\",null,{\"children\":\"展示您理解系统的基本需求。\"}],[\"$\",\"li\",null,{\"children\":\"为后续的扩展讨论奠定基础。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"调整后的高层设计\"}],\"： 图8展示的调整后的高层设计很好地体现了一个可扩展的聊天系统架构。让我们详细分析一下每个组件：\"]}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Lf\",null,{\"src\":\"/static/images/system/chat-system/picture8.webp\",\"alt\":\"Maple\",\"width\":\"750\",\"height\":\"820\"}],\" 图 8\"]}]}],[\"$\",\"p\",null,{\"children\":[\"a) \",[\"$\",\"strong\",null,{\"children\":\"客户端与WebSocket连接\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"使用WebSocket保持与聊天服务器的持久连接，实现实时消息传递。\"}],[\"$\",\"li\",null,{\"children\":\"考虑客户端的重连逻辑和离线消息同步机制。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"b) \",[\"$\",\"strong\",null,{\"children\":\"聊天服务器\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"处理消息的发送和接收。\"}],[\"$\",\"li\",null,{\"children\":\"可以水平扩展以处理更多并发连接。\"}],[\"$\",\"li\",null,{\"children\":\"考虑使用服务发现机制动态分配客户端到服务器。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"c) \",[\"$\",\"strong\",null,{\"children\":\"存在服务器\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"管理用户的在线/离线状态。\"}],[\"$\",\"li\",null,{\"children\":\"可以使用分布式缓存（如Redis）来提高性能。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"d) \",[\"$\",\"strong\",null,{\"children\":\"API服务器\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"处理非实时请求，如登录、注册、资料更改等。\"}],[\"$\",\"li\",null,{\"children\":\"无状态设计，易于扩展。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"e) \",[\"$\",\"strong\",null,{\"children\":\"通知服务器\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"发送推送通知。\"}],[\"$\",\"li\",null,{\"children\":\"集成各平台的推送服务（如APNS, FCM）。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"f) \",[\"$\",\"strong\",null,{\"children\":\"键值存储\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"存储聊天历史。\"}],[\"$\",\"li\",null,{\"children\":\"选择适合大规模读写的数据库（如Cassandra或HBase）。\"}],[\"$\",\"li\",null,{\"children\":\"考虑数据分片策略以提高性能。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"扩展性考虑\"}],\"：\"]}],[\"$\",\"p\",null,{\"children\":[\"a) \",[\"$\",\"strong\",null,{\"children\":\"负载均衡\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"在各层服务之前添加负载均衡器。\"}],[\"$\",\"li\",null,{\"children\":\"对WebSocket连接使用特殊的负载均衡策略。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"b) \",[\"$\",\"strong\",null,{\"children\":\"数据库扩展\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"实现读写分离。\"}],[\"$\",\"li\",null,{\"children\":\"使用数据分片处理大规模数据。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"c) \",[\"$\",\"strong\",null,{\"children\":\"缓存策略\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"引入分布式缓存层减轻数据库负载。\"}],[\"$\",\"li\",null,{\"children\":\"缓存热门对话和频繁访问的用户数据。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"d) \",[\"$\",\"strong\",null,{\"children\":\"异步处理\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[\"$\",\"li\",null,{\"children\":\"使用消息队列（如Kafka）处理非实时任务。\"}]}],[\"$\",\"p\",null,{\"children\":[\"e) \",[\"$\",\"strong\",null,{\"children\":\"微服务架构\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[\"$\",\"li\",null,{\"children\":\"考虑将大型服务拆分为微服务，提高系统的模块性和可维护性。\"}]}],[\"$\",\"p\",null,{\"children\":[\"f) \",[\"$\",\"strong\",null,{\"children\":\"全球化部署\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"使用CDN加速静态资源交付。\"}],[\"$\",\"li\",null,{\"children\":\"考虑多区域部署以降低延迟。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"监控和警报\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"实施全面的监控系统，跟踪关键指标。\"}],[\"$\",\"li\",null,{\"children\":\"设置自动警报以快速响应问题。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"安全性考虑\"}],\"：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"实现端到端加密。\"}],[\"$\",\"li\",null,{\"children\":\"使用适当的认证和授权机制。\"}],[\"$\",\"li\",null,{\"children\":\"防御DDoS攻击和其他安全威胁。\"}]]}]]}]]}],[\"$\",\"p\",null,{\"children\":\"这种分布式设计解决了单服务器方案的主要问题，提供了高可用性、可扩展性和容错能力。它允许系统根据需求独立扩展不同的组件，同时保持整体架构的灵活性。在实际实现中，可能还需要根据具体需求和约束进行进一步的优化和调整。\"}],[\"$\",\"h4\",null,{\"className\":\"content-header\",\"id\":\"存储\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#存储\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"存储\"]}],[\"$\",\"p\",null,{\"children\":\"现在，服务器已经搭建完毕，服务正在运行，第三方集成也已完成。在整个技术栈的最底层，就是数据存储部分。选择正确的数据存储方式至关重要。本小节将探讨聊天系统中应该使用哪种类型的数据库：关系型数据库还是非关系型数据库？\"}],[\"$\",\"p\",null,{\"children\":\"聊天系统通常包含两种类型的数据。第一种是通用数据，例如用户资料、设置、好友列表等。这些数据需要存储在稳定可靠的关系型数据库中。通常会采用复制和分片等技术来满足可用性和可扩展性的需求；第二种数据是聊天历史记录，这是聊天系统独有的数据类型。理解其读写模式非常重要。\"}],[\"$\",\"p\",null,{\"children\":\"聊天系统的聊天记录数据量会非常庞大。研究表明，Facebook Messenger 和 Whatsapp 每天处理的消息数量高达 600 亿条。然而，用户频繁访问的只有最近的聊天记录。他们通常不会去查找很久之前的聊天记录。\"}],[\"$\",\"p\",null,{\"children\":\"虽然大多数情况下用户查看的都是最近的聊天记录，但一些功能还是需要随机访问历史数据，例如搜索、查看@ 提及、跳转到特定消息等。数据访问层需要支持这些场景。对于一对一聊天的应用来说，读写比例大约是 1:1。\"}],[\"$\",\"p\",null,{\"children\":[\"选择合适的存储系统来支持所有用例至关重要。我们推荐使用键值存储 (\",[\"$\",\"strong\",null,{\"children\":\"Key-Value Store\"}],\") 来存储聊天记录，原因如下：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"键值存储易于水平扩展。\"}],[\"$\",\"li\",null,{\"children\":\"键值存储提供极低的访问延迟。\"}],[\"$\",\"li\",null,{\"children\":\"关系型数据库在处理长尾数据时效率低下。当索引变得庞大时，随机访问的成本会很高。\"}],[\"$\",\"li\",null,{\"children\":\"键值存储已经被其他可靠的聊天应用所采用。例如，Facebook Messenger 使用 HBase，Discord 使用 Cassandra。\"}]]}],[\"$\",\"h3\",null,{\"className\":\"content-header\",\"id\":\"数据模型\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#数据模型\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"数据模型\"]}],[\"$\",\"p\",null,{\"children\":\"刚才我们讨论了使用键值存储作为数据存储层。其中最重要的数据就是消息数据，下面让我们仔细看一下 1 对 1 聊天的消息表结构。\"}],[\"$\",\"h4\",null,{\"className\":\"content-header\",\"id\":\"1-对-1-聊天消息表\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#1-对-1-聊天消息表\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"1 对 1 聊天消息表\"]}],[\"$\",\"p\",null,{\"children\":[\"表格展示了 1 对 1 聊天消息的表格结构。主键是 \",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"message_id\"}],\"，它用于确定消息的顺序。我们不能仅仅依赖 \",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"created_at\"}],\" 字段来判断消息顺序，因为有可能出现两条消息同时创建的情况。\"]}],[\"$\",\"div\",null,{\"className\":\"w-full overflow-x-auto\",\"children\":[\"$\",\"table\",null,{\"children\":[[\"$\",\"thead\",null,{\"children\":[\"$\",\"tr\",null,{\"children\":[[\"$\",\"th\",null,{\"children\":\"字段名\"}],[\"$\",\"th\",null,{\"children\":\"数据类型\"}],[\"$\",\"th\",null,{\"children\":\"描述\"}],[\"$\",\"th\",null,{\"children\":\"备注\"}]]}]}],[\"$\",\"tbody\",null,{\"children\":[[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"message_id\"}]}],[\"$\",\"td\",null,{\"children\":\"字符串\"}],[\"$\",\"td\",null,{\"children\":\"消息的唯一标识符\"}],[\"$\",\"td\",null,{\"children\":\"主键\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"from_user_id\"}]}],[\"$\",\"td\",null,{\"children\":\"字符串\"}],[\"$\",\"td\",null,{\"children\":\"发送消息的用户 ID\"}],[\"$\",\"td\",null,{\"children\":\"外键，引用用户表\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"to_user_id\"}]}],[\"$\",\"td\",null,{\"children\":\"字符串\"}],[\"$\",\"td\",null,{\"children\":\"接收消息的用户 ID\"}],[\"$\",\"td\",null,{\"children\":\"外键，引用用户表\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"content\"}]}],[\"$\",\"td\",null,{\"children\":\"字符串\"}],[\"$\",\"td\",null,{\"children\":\"消息内容\"}],[\"$\",\"td\",null,{\"children\":\"文本内容或其他格式数据\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"created_at\"}]}],[\"$\",\"td\",null,{\"children\":\"时间戳\"}],[\"$\",\"td\",null,{\"children\":\"消息创建时间\"}],[\"$\",\"td\",null,{}]]}]]}]]}]}],[\"$\",\"h4\",null,{\"className\":\"content-header\",\"id\":\"群聊消息表\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#群聊消息表\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"群聊消息表\"]}],[\"$\",\"p\",null,{\"children\":[\"表格10 展示了群聊消息的表格结构。复合主键是 \",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"(channel_id, message_id)\"}],\"。这里 channel 和 group 代表相同的含义，\",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"channel_id\"}],\" 是分区键，因为群聊中的所有查询都针对特定的频道进行。\"]}],[\"$\",\"div\",null,{\"className\":\"w-full overflow-x-auto\",\"children\":[\"$\",\"table\",null,{\"children\":[[\"$\",\"thead\",null,{\"children\":[\"$\",\"tr\",null,{\"children\":[[\"$\",\"th\",null,{\"children\":\"字段名\"}],[\"$\",\"th\",null,{\"children\":\"数据类型\"}],[\"$\",\"th\",null,{\"children\":\"描述\"}],[\"$\",\"th\",null,{\"children\":\"备注\"}]]}]}],[\"$\",\"tbody\",null,{\"children\":[[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"channel_id\"}]}],[\"$\",\"td\",null,{\"children\":\"字符串\"}],[\"$\",\"td\",null,{\"children\":\"频道的唯一标识符\"}],[\"$\",\"td\",null,{\"children\":\"复合主键的一部分\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"message_id\"}]}],[\"$\",\"td\",null,{\"children\":\"字符串\"}],[\"$\",\"td\",null,{\"children\":\"消息的唯一标识符\"}],[\"$\",\"td\",null,{\"children\":\"复合主键的一部分\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"from_user_id\"}]}],[\"$\",\"td\",null,{\"children\":\"字符串\"}],[\"$\",\"td\",null,{\"children\":\"发送消息的用户 ID\"}],[\"$\",\"td\",null,{\"children\":\"外键，引用用户表\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"content\"}]}],[\"$\",\"td\",null,{\"children\":\"字符串\"}],[\"$\",\"td\",null,{\"children\":\"消息内容\"}],[\"$\",\"td\",null,{\"children\":\"文本内容或其他格式数据\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"created_at\"}]}],[\"$\",\"td\",null,{\"children\":\"时间戳\"}],[\"$\",\"td\",null,{\"children\":\"消息创建时间\"}],[\"$\",\"td\",null,{}]]}]]}]]}]}],[\"$\",\"h4\",null,{\"className\":\"content-header\",\"id\":\"消息-id-生成\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#消息-id-生成\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"消息 ID 生成\"]}],[\"$\",\"p\",null,{\"children\":[\"如何生成 \",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"message_id\"}],\" 是一个值得探讨的有趣话题。\",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"message_id\"}],\" 承担着确保消息顺序的重任，为了实现消息排序，\",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"message_id\"}],\" 需要满足以下两个要求：\"]}],[\"$\",\"ol\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"唯一性\"}],\": 每个消息的 ID 必须是唯一的。\"]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"时间可排序\"}],\": ID 应该具有时间顺序，即较新的消息的 ID 应该大于较旧的消息的 ID。\"]}]]}],[\"$\",\"p\",null,{\"children\":\"那么如何才能满足这两个保证呢？\"}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":[[\"$\",\"p\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"方案一：自增主键 (Auto-increment)\"}]}],[\"$\",\"p\",null,{\"children\":[\"这是最直观的想法，在关系型数据库中我们可以使用 MySQL 的 \",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"auto_increment\"}],\" 特性来实现。但是，NoSQL 数据库通常不提供类似的功能。\"]}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"p\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"方案二：全局递增序列号生成器\"}]}],[\"$\",\"p\",null,{\"children\":\"另一种方案是使用全局的 64 位序列号生成器，例如 Snowflake提供的这类服务。这种方式在 “分布式系统中设计唯一 ID 生成器” 章节中有详细讨论。\"}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"p\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"方案三：本地递增序列号生成器\"}]}],[\"$\",\"p\",null,{\"children\":\"最后一种方案是使用本地递增序列号生成器。这里的 “本地” 意味着 ID 在某个组内是唯一的。之所以本地 ID 可以工作，是因为我们只需要保证一对一聊天或群聊频道内的消息顺序即可。与全局 ID 实现相比，这种方式更加易于实现。\"}]]}]]}],[\"$\",\"h2\",null,{\"className\":\"content-header\",\"id\":\"第三步---系统设计深度剖析\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#第三步---系统设计深度剖析\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"第三步 - 系统设计深度剖析\"]}],[\"$\",\"p\",null,{\"children\":\"在系统设计面试中，通常会要求你深入探讨高级设计中的一些组件。对于聊天系统来说，服务发现、消息流和在线/离线指示器值得更深入地研究。\"}],[\"$\",\"h3\",null,{\"className\":\"content-header\",\"id\":\"服务发现-service-discovery\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#服务发现-service-discovery\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"服务发现 (Service Discovery)\"]}],[\"$\",\"p\",null,{\"children\":\"服务发现的主要作用是根据地理位置、服务器容量等标准，为客户端推荐最合适的聊天服务器。它可以注册所有可用的聊天服务器，并根据预定义的标准为客户端挑选最合适的服务器。它是帮助应用程序定位其他服务的机制。在聊天系统中，可能有多个微服务协同工作，例如用户服务、消息服务和推送服务。服务发现使应用程序不必关心底层基础设施细节，例如服务的主机名和端口号。Apache Zookeeper是一个流行的开源服务发现解决方案。\"}],[\"$\",\"p\",null,{\"children\":\"以下是一些常用的服务发现技术：\"}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"DNS (Domain Name System)\"}],\": 传统且广泛使用的服务发现方式，可以通过域名解析服务将服务名称转换为 IP 地址和端口号。\"]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"ZooKeeper\"}],\" : 一个集中式的分布式协调服务，可用于存储和检索服务元数据。\"]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Consul\"}],\" : 功能类似于 ZooKeeper 的开源服务发现工具，提供服务注册、健康检查和 KV 存储等功能。\"]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"etcd\"}],\" : 由 CoreOS 开发的开源分布式键值存储，常用于服务发现和配置管理。\"]}]]}],[\"$\",\"p\",null,{\"children\":\"图 11 展示了服务发现 (Zookeeper) 的工作流程：\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Lf\",null,{\"src\":\"/static/images/system/chat-system/picture11.webp\",\"alt\":\"Maple\",\"width\":\"640\",\"height\":\"623\"}],\" 图 11\"]}]}],[\"$\",\"ol\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"用户 A 尝试登录应用。\"}],[\"$\",\"li\",null,{\"children\":\"负载均衡器将登录请求发送到 API 服务器。\"}],[\"$\",\"li\",null,{\"children\":\"后台验证用户之后，服务发现会为用户 A 找到最合适的聊天服务器。在这个例子中，选择了服务器 2，并将其信息返回给用户 A。\"}],[\"$\",\"li\",null,{\"children\":\"用户 A 通过 WebSocket 连接到聊天服务器 2。\"}]]}],[\"$\",\"h3\",null,{\"className\":\"content-header\",\"id\":\"消息流-messaging-flows\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#消息流-messaging-flows\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"消息流 (Messaging Flows)\"]}],[\"$\",\"p\",null,{\"children\":\"消息流是指消息在聊天系统中从发送方传递到接收方的过程。它通常涉及以下步骤：\"}],[\"$\",\"h4\",null,{\"className\":\"content-header\",\"id\":\"1-对-1-聊天\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#1-对-1-聊天\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"1 对 1 聊天\"]}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Lf\",null,{\"src\":\"/static/images/system/chat-system/picture12.webp\",\"alt\":\"Maple\",\"width\":\"640\",\"height\":\"678\"}],\" 图 12\"]}]}],[\"$\",\"p\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"用户 A 发送聊天消息到聊天服务器 1\"}]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"用户 A 在聊天界面输入消息并点击发送按钮。\"}],[\"$\",\"li\",null,{\"children\":\"用户 A 的客户端应用将消息内容、接收方用户 ID 等信息封装成消息对象。\"}],[\"$\",\"li\",null,{\"children\":\"通过 WebSocket 连接，客户端应用将消息对象发送到聊天服务器 1。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"聊天服务器 1 获取消息 ID\"}]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"聊天服务器 1 调用消息 ID 生成器 (如上文讨论的几种方案) 获取一个唯一的消息 ID。\"}],[\"$\",\"li\",null,{\"children\":\"消息 ID 将被附加到消息对象上，用于后续的消息跟踪和排序。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"聊天服务器 1 发送消息到消息同步队列\"}]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"聊天服务器 1 将包含消息内容、消息 ID、发送方和接收方信息等数据的完整消息对象放入消息同步队列。\"}],[\"$\",\"li\",null,{\"children\":\"消息同步队列可以是内存队列或持久化队列，具体取决于系统的需求。例如，内存队列处理速度快，但容易丢失数据；持久化队列可以保证消息可靠性，但处理速度可能稍慢。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"消息存储到键值存储\"}]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"聊天服务器 1 将包含完整消息数据的消息对象存储到键值存储中。\"}],[\"$\",\"li\",null,{\"children\":[\"键值存储可以高效地存储和检索消息数据，并支持根据不同的键进行查询（例如根据 \",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"message_id\"}],\" 查询消息内容）。\"]}]]}],[\"$\",\"p\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"消息传递到接收方\"}]}],[\"$\",\"ul\",null,{\"children\":[\"$\",\"li\",null,{\"children\":[[\"$\",\"p\",null,{\"children\":\"根据接收方用户 (用户 B) 的在线状态，\"}],[\"$\",\"p\",null,{\"children\":\"聊天系统采用不同的策略传递消息：\"}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":[\"a. 用户 B 在线\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"聊天服务器 1 通过服务发现 (Zookeeper 等) 找到用户 B 当前连接的聊天服务器 (假设为服务器 2)。\"}],[\"$\",\"li\",null,{\"children\":\"聊天服务器 1 将消息对象转发到聊天服务器 2。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[\"b. 用户 B 离线\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"聊天服务器 1 不会直接将消息发送到离线用户。\"}],[\"$\",\"li\",null,{\"children\":\"聊天服务器 1 将消息的概要信息 (例如发送方昵称、消息摘要) 发送到推送通知 (PN) 服务器。\"}],[\"$\",\"li\",null,{\"children\":\"PN 服务器根据用户 B 的设备信息，通过推送通知服务将消息概要信息发送到用户 B 的设备。\"}]]}]]}]]}]]}]}],[\"$\",\"p\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"接收方收到消息\"}]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":[\"a. 用户 B 在线\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"用户 B 的客户端通过 WebSocket 连接一直监听聊天服务器 2 发送的消息。\"}],[\"$\",\"li\",null,{\"children\":\"当聊天服务器 2 转发消息对象过来时，用户 B 的客户端收到消息并将其展示在聊天界面上。\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[\"b. 用户 B 离线\",[\"$\",\"ul\",null,{\"children\":[\"$\",\"li\",null,{\"children\":\"用户 B 需要通过其他方式 (例如打开应用) 拉取最新的消息记录，才能看到完整的聊天消息内容。\"}]}]]}]]}],[\"$\",\"h4\",null,{\"className\":\"content-header\",\"id\":\"消息同步多个设备\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#消息同步多个设备\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"消息同步多个设备\"]}],[\"$\",\"p\",null,{\"children\":\"许多用户在使用多个设备进行聊天。下面我们将介绍如何在多个设备之间同步消息，确保用户在任何设备上看到的聊天记录都是一致的。\"}],[\"$\",\"p\",null,{\"children\":\"图 13 展示了消息同步的一个示例。图中，用户 A 拥有手机和笔记本电脑两个设备。当用户 A 用手机登录聊天应用时，手机会通过 WebSocket 连接到聊天服务器 1。同样，笔记本电脑也会建立与其的连接。\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Lf\",null,{\"src\":\"/static/images/system/chat-system/picture13.webp\",\"alt\":\"Maple\",\"width\":\"640\",\"height\":\"454\"}],\" 图 13\"]}]}],[\"$\",\"p\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"1. 客户端游标 (cur_max_message_id)\"}]}],[\"$\",\"p\",null,{\"children\":[\"每个设备都会维护一个变量，称为 \",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"cur_max_message_id\"}],\"。它用来跟踪设备上本地存储的最新消息 ID。\"]}],[\"$\",\"p\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"2. 新消息识别\"}]}],[\"$\",\"p\",null,{\"children\":\"系统会根据以下两个条件来判断一条消息是否对当前设备而言是新消息：\"}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"消息的接收方用户 ID 与当前登录的用户 ID 相等。\"}],[\"$\",\"li\",null,{\"children\":[\"消息在键值存储中的 ID 大于设备上存储的 \",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"cur_max_message_id\"}],\"。\"]}]]}],[\"$\",\"p\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"3. 消息拉取\"}]}],[\"$\",\"p\",null,{\"children\":[\"由于每个设备的 \",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"cur_max_message_id\"}],\" 都不同，因此消息同步变得简单。每个设备都可以从键值存储中拉取满足上述条件的消息，即消息的接收方为自己且 ID 大于本地存储的最新消息 ID 的消息。\"]}],[\"$\",\"p\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"4. 更新游标\"}]}],[\"$\",\"p\",null,{\"children\":[\"当设备成功拉取到新消息后，会将 \",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"cur_max_message_id\"}],\" 更新为拉取到的最大消息 ID，以便后续仅拉取新消息。\"]}],[\"$\",\"p\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"5. 消息展示\"}]}],[\"$\",\"p\",null,{\"children\":\"拉取到的新消息将会展示在聊天界面上。\"}],[\"$\",\"h4\",null,{\"className\":\"content-header\",\"id\":\"小型群聊消息流\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#小型群聊消息流\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"小型群聊消息流\"]}],[\"$\",\"p\",null,{\"children\":\"与一对一聊天相比，群聊的逻辑更加复杂。图 14 和图 15 展示了群聊消息的发送和接收流程。\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Lf\",null,{\"src\":\"/static/images/system/chat-system/picture14.webp\",\"alt\":\"Maple\",\"width\":\"640\",\"height\":\"557\"}],\" 图 14\"]}]}],[\"$\",\"p\",null,{\"children\":\"图 14 展示了用户 A 在群聊中发送消息时的流程，假设群聊中有 3 个成员（用户 A、用户 B 和用户 C）。\"}],[\"$\",\"ol\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"用户 A 的客户端将消息内容、群聊 ID 等信息封装成消息对象。\"}],[\"$\",\"li\",null,{\"children\":\"聊天服务器 1 将消息对象复制一份，并分别放入用户 B 和用户 C 的消息同步队列中。\"}],[\"$\",\"li\",null,{\"children\":\"每个群成员都可以通过自己对应的消息同步队列接收来自不同发送方的消息。\"}]]}],[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"设计选择\"}],\": 这种将消息拷贝一份到每个群成员的消息同步队列的方案适用于小型群聊，原因如下：\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"简化消息同步流程：每个客户端只需要检查自己的消息同步队列即可获取新消息，降低了复杂性。\"}],[\"$\",\"li\",null,{\"children\":\"小型群聊成员数量较少，为每个成员存储一份消息副本的代价可以接受。\"}]]}],[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"局限性\"}],\": 微信也采用了类似的方案，并且将群聊人数限制在了 500 人以内。但是，对于拥有大量成员的群聊来说，为每个成员存储一份消息的副本将造成非常大的存储开销，变得不可接受。\"]}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Lf\",null,{\"src\":\"/static/images/system/chat-system/picture15.webp\",\"alt\":\"Maple\",\"width\":\"640\",\"height\":\"557\"}],\" 图 15\"]}]}],[\"$\",\"h3\",null,{\"className\":\"content-header\",\"id\":\"在线离线状态管理\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#在线离线状态管理\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"在线/离线状态管理\"]}],[\"$\",\"p\",null,{\"children\":\"在线/离线指示器是许多聊天应用必不可少的功能，通常用户可以在其他用户的名字或头像旁边看到一个绿色的点，表示该用户是否在线。本节将介绍在线/离线指示器背后的实现原理。\"}],[\"$\",\"p\",null,{\"children\":[\"在高级设计中，\",[\"$\",\"strong\",null,{\"children\":\"Presence Server\"}],\" (存在感服务器) 负责管理用户的在线状态，并通过 WebSocket 与客户端进行通信。以下是一些会触发用户在线状态改变的常见场景：\"]}],[\"$\",\"h4\",null,{\"className\":\"content-header\",\"id\":\"用户登录\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#用户登录\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"用户登录\"]}],[\"$\",\"p\",null,{\"children\":[\"用户登录流程已经在 “服务发现” 章节有所提及。当客户端通过服务发现找到合适的聊天服务器并建立 WebSocket 连接后，用户 A 的在线状态和最后活跃时间戳 (\",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"last_active_at\"}],\") 会被保存到键值存储中。此时，Presence Server 会通知客户端更新界面，显示用户 A 为在线状态。\"]}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Lf\",null,{\"src\":\"/static/images/system/chat-system/picture16.webp\",\"alt\":\"Maple\",\"width\":\"640\",\"height\":\"165\"}],\" 图 16\"]}]}],[\"$\",\"h4\",null,{\"className\":\"content-header\",\"id\":\"用户登出\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#用户登出\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"用户登出\"]}],[\"$\",\"p\",null,{\"children\":\"图 17 展示了用户登出时的流程。\"}],[\"$\",\"ol\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"用户点击退出按钮，客户端向 Presence Server 发送下线消息。\"}],[\"$\",\"li\",null,{\"children\":\"Presence Server 收到下线消息后，会将该用户的状态更新为离线，并将其从在线用户列表中移除。\"}],[\"$\",\"li\",null,{\"children\":\"Presence Server 会向其他在线用户推送该用户下线的消息，更新其他用户的好友列表中的在线状态。\"}],[\"$\",\"li\",null,{\"children\":[\"键值存储中，该用户的在线状态和最后活跃时间戳 (\",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"last_active_at\"}],\") 也将被更新为反映离线状态。\"]}],[\"$\",\"li\",null,{\"children\":\"客户端断开与 Presence Server 的 WebSocket 连接。\"}]]}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Lf\",null,{\"src\":\"/static/images/system/chat-system/picture17.webp\",\"alt\":\"Maple\",\"width\":\"640\",\"height\":\"130\"}],\" 图 17\"]}]}],[\"$\",\"h4\",null,{\"className\":\"content-header\",\"id\":\"用户断线\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#用户断线\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"用户断线\"]}],[\"$\",\"p\",null,{\"children\":\"网络连接并不总是可靠稳定的。用户断线后，客户端与服务器之间会失去连接。一种简单粗暴的处理方式是将用户直接标记为离线，当重连后又将其标记为在线。然而，这种方式存在着明显的缺陷：\"}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"用户在短时间内频繁断线和重连的情况很常见，例如在穿过隧道时网络信号可能会断断续续。\"}],[\"$\",\"li\",null,{\"children\":\"如果在线状态跟随每一次断线/重连进行更新，则 Presence 指示器将频繁闪烁，带来糟糕的用户体验。\"}]]}],[\"$\",\"p\",null,{\"children\":\"为了解决这个问题，我们引入了心跳检测机制。\"}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"在线客户端会定期向 Presence Server 发送心跳包。\"}],[\"$\",\"li\",null,{\"children\":\"Presence Server 会记录收到心跳包的最后时间。\"}],[\"$\",\"li\",null,{\"children\":[\"如果在 \",[\"$\",\"strong\",null,{\"children\":\"预设的超时时间\"}],\" (例如 x 秒) 内没有收到该用户的\",[\"$\",\"strong\",null,{\"children\":\"心跳包\"}],\"，Presence Server 会将该用户的状态标记为\",[\"$\",\"strong\",null,{\"children\":\"离线\"}],\"，并将其从在线用户列表中移除。\"]}],[\"$\",\"li\",null,{\"children\":\"同时，Presence Server 会向其他在线用户推送该用户下线的消息，更新其他用户的好友列表中的在线状态。\"}]]}],[\"$\",\"p\",null,{\"children\":\"图 18 展示了一个示例：\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Lf\",null,{\"src\":\"/static/images/system/chat-system/picture18.svg\",\"alt\":\"Maple\",\"width\":\"782\",\"height\":\"623\"}],\" 图 18\"]}]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"客户端每隔 5 秒向服务器发送一个心跳包。\"}],[\"$\",\"li\",null,{\"children\":[\"在发送了 3 个心跳包之后，客户端断线，并且在 \",[\"$\",\"strong\",null,{\"children\":\"超时时间 x = 30 秒\"}],\" 内没有重新连接 (此数值仅用于演示逻辑，实际超时时间需要根据具体情况设定)。\"]}],[\"$\",\"li\",null,{\"children\":\"此时，Presence Server 会检测到心跳包超時，并将该用户的状态标记为离线。\"}]]}],[\"$\",\"h4\",null,{\"className\":\"content-header\",\"id\":\"在线状态推送\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#在线状态推送\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"在线状态推送\"]}],[\"$\",\"p\",null,{\"children\":\"上文介绍了 Presence Server 如何跟踪用户在线状态，那么其他用户如何得知好友的在线状态更新呢？图 19 展示了常见的一种实现方式。\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Lf\",null,{\"src\":\"/static/images/system/chat-system/picture19.webp\",\"alt\":\"Maple\",\"width\":\"640\",\"height\":\"300\"}],\" 图 19\"]}]}],[\"$\",\"p\",null,{\"children\":\"Presence Server 采用发布-订阅 (Publish-Subscribe) 的模式来实现在线状态的推送。\"}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"每个好友对之间会维护一个唯一的频道 (channel)。\"}],[\"$\",\"li\",null,{\"children\":\"当用户 A 的在线状态发生改变时，Presence Server 会将这个事件发布到与其相关的频道，例如 A-B、A-C 和 A-D 频道。\"}],[\"$\",\"li\",null,{\"children\":\"用户 B、C 和 D 分别订阅了与之对应的频道，因此他们可以及时收到好友 A 的在线状态更新消息。\"}],[\"$\",\"li\",null,{\"children\":\"客户端和服务器之间的通信通过实时的 WebSocket 连接进行。\"}]]}],[\"$\",\"p\",null,{\"children\":\"这种方案对于用户规模较小的场景是比较高效的。例如，微信将群聊人数限制在了 500 人以内，也采用了类似的发布-订阅模型进行在线状态推送。\"}],[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"局限性\"}],\":\"]}],[\"$\",\"p\",null,{\"children\":\"对于用户规模较大的场景，例如一个拥有 100,000 名成员的群聊，当一名成员的在线状态发生变化时，需要向所有成员推送消息，会产生大量的事件 (100,000 个)，带来严重的性能瓶颈。\"}],[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"解决方法\"}],\":\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"拉取在线状态 (Pull Updates): 仅在用户进入群聊或手动刷新好友列表时，再向服务器请求好友的在线状态。\"}],[\"$\",\"li\",null,{\"children\":\"其他优化方案: 还可以采用分级推送、批量更新等方式来优化在线状态推送的性能。\"}]]}],[\"$\",\"h2\",null,{\"className\":\"content-header\",\"id\":\"第四步---系统设计总结\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#第四步---系统设计总结\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"第四步 - 系统设计总结\"]}],[\"$\",\"p\",null,{\"children\":\"该博客介绍了一个支持一对一聊天和小群聊的聊天系统架构。WebSocket 用于客户端和服务器之间的实时通信。聊天系统包含以下组件：\"}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"用于实时消息传递的聊天服务器\"}],[\"$\",\"li\",null,{\"children\":\"用于管理在线状态的 Presence 服务器\"}],[\"$\",\"li\",null,{\"children\":\"用于发送推送通知的推送通知服务器\"}],[\"$\",\"li\",null,{\"children\":\"用于保存聊天历史记录的键值存储\"}],[\"$\",\"li\",null,{\"children\":\"用于提供其他功能的 API 服务器\"}]]}],[\"$\",\"p\",null,{\"children\":\"如果您在面试结束时还有额外的时间，可以讨论以下附加话题：\"}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"支持媒体文件\"}],\" 扩展聊天应用程序以支持照片和视频等媒体文件。媒体文件的大小远大于文本，我们可以讨论压缩、云存储和缩略图等相关技术。\"]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"端到端加密\"}],\" Whatsapp 支持消息的端到端加密，只有发送者和接收者可以阅读消息。\"]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"客户端缓存\"}],\" 在客户端缓存消息可以有效减少客户端和服务器之间的数据传输。\"]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"优化加载时间\"}],\" Slack 构建了一个地理分布式网络来缓存用户的數據、频道等信息，从而改善加载时间。\"]}],[\"$\",\"li\",null,{\"children\":[\"错误处理\",[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"聊天服务器错误：聊天服务器可能需要处理成千上万的持久连接。如果聊天服务器宕机，服务发现 (Zookeeper) 将为客户端提供新的聊天服务器以建立新的连接。\"}],[\"$\",\"li\",null,{\"children\":\"消息重发机制：重试和队列是常见的用于消息重发的技术。\"}]]}]]}]]}],[\"$\",\"p\",null,{\"children\":\"恭喜您走到这一步！为自己的出色表现鼓掌吧！\"}]]}]}],[\"$\",\"div\",null,{\"className\":\"pb-6 pt-6 text-center text-gray-700 dark:text-gray-300\",\"id\":\"comment\",\"children\":[\"$\",\"$L19\",null,{\"slug\":\"system/chat-system\"}]}],[\"$\",\"footer\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col text-sm font-medium sm:flex-row sm:justify-between sm:text-base\",\"children\":[[\"$\",\"div\",null,{\"className\":\"pt-4 xl:pt-8\",\"children\":[\"$\",\"$Le\",null,{\"href\":\"/blog/system/design-system\",\"className\":\"text-primary-500 hover:text-primary-600 dark:hover:text-primary-400\",\"aria-label\":\"Previous post: 从零到百万用户的扩展之路\",\"children\":[\"← \",\"从零到百万用户的扩展之路\"]}]}],[\"$\",\"div\",null,{\"className\":\"pt-4 xl:pt-8\",\"children\":[\"$\",\"$Le\",null,{\"href\":\"/blog/frontend/javascript-trick\",\"className\":\"text-primary-500 hover:text-primary-600 dark:hover:text-primary-400\",\"aria-label\":\"Next post: JavaScript秘技：15个惊艳功能\",\"children\":[\"JavaScript秘技：15个惊艳功能\",\" →\"]}]}]]}]}]]}]]}]}]]}]]\n"])</script><script>self.__next_f.push([1,"15:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"从零开始：如何设计一个现代化聊天系统\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"博客介绍了一种可扩展且可靠的聊天系统架构，该架构支持一对一和小群聊，并有可能扩展到处理媒体文件。该系统采用客户端-服务器架构，由聊天服务器、Presence 服务器、推送通知服务器、键值存储和 API 服务器组成。它利用了 WebSocket、服务发现、消息传递、在线状态管理和推送通知等技术。该架构具有可扩展性、高可用性和易用性等优点，使其适用于各种规模的聊天应用程序。\"}],[\"$\",\"meta\",\"4\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"5\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"6\",{\"rel\":\"canonical\",\"href\":\"https://blog.mainjay.cloudns.ch/blog/system/chat-system\"}],[\"$\",\"link\",\"7\",{\"rel\":\"alternate\",\"type\":\"application/rss+xml\",\"href\":\"https://blog.mainjay.cloudns.ch/feed.xml\"}],[\"$\",\"meta\",\"8\",{\"property\":\"og:title\",\"content\":\"从零开始：如何设计一个现代化聊天系统\"}],[\"$\",\"meta\",\"9\",{\"property\":\"og:description\",\"content\":\"博客介绍了一种可扩展且可靠的聊天系统架构，该架构支持一对一和小群聊，并有可能扩展到处理媒体文件。该系统采用客户端-服务器架构，由聊天服务器、Presence 服务器、推送通知服务器、键值存储和 API 服务器组成。它利用了 WebSocket、服务发现、消息传递、在线状态管理和推送通知等技术。该架构具有可扩展性、高可用性和易用性等优点，使其适用于各种规模的聊天应用程序。\"}],[\"$\",\"meta\",\"10\",{\"property\":\"og:url\",\"content\":\"https://blog.mainjay.cloudns.ch/blog/system/chat-system\"}],[\"$\",\"meta\",\"11\",{\"property\":\"og:site_name\",\"content\":\"MainJayLai Blog\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:locale\",\"content\":\"en_US\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:image\",\"content\":\"https://pngimg.com/uploads/github/github_PNG80.png\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"15\",{\"property\":\"article:published_time\",\"content\":\"2024-07-02T00:00:00.000Z\"}],[\"$\",\"meta\",\"16\",{\"property\":\"article:modified_time\",\"content\":\"2024-07-02T00:00:00.000Z\"}],[\"$\",\"meta\",\"17\",{\"property\":\"article:author\",\"content\":\"mainJayLai\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"从零开始：如何设计一个现代化聊天系统\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"博客介绍了一种可扩展且可靠的聊天系统架构，该架构支持一对一和小群聊，并有可能扩展到处理媒体文件。该系统采用客户端-服务器架构，由聊天服务器、Presence 服务器、推送通知服务器、键值存储和 API 服务器组成。它利用了 WebSocket、服务发现、消息传递、在线状态管理和推送通知等技术。该架构具有可扩展性、高可用性和易用性等优点，使其适用于各种规模的聊天应用程序。\"}],[\"$\",\"meta\",\"21\",{\"name\":\"twitter:image\",\"content\":\"https://pngimg.com/uploads/github/github_PNG80.png\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>
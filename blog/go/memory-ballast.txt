3:I[9275,[],""]
5:I[1343,[],""]
6:I[8700,["599","static/chunks/ebde5ed1-51545511fe0d5050.js","231","static/chunks/231-34a6a67d2da26855.js","827","static/chunks/827-69594f61c16b8a9c.js","850","static/chunks/850-ecf153581cc02044.js","185","static/chunks/app/layout-54bebb918ae7f176.js"],"ThemeProviders"]
7:I[4080,["599","static/chunks/ebde5ed1-51545511fe0d5050.js","231","static/chunks/231-34a6a67d2da26855.js","827","static/chunks/827-69594f61c16b8a9c.js","850","static/chunks/850-ecf153581cc02044.js","185","static/chunks/app/layout-54bebb918ae7f176.js"],""]
8:I[9032,["599","static/chunks/ebde5ed1-51545511fe0d5050.js","231","static/chunks/231-34a6a67d2da26855.js","827","static/chunks/827-69594f61c16b8a9c.js","850","static/chunks/850-ecf153581cc02044.js","185","static/chunks/app/layout-54bebb918ae7f176.js"],"KBarSearchProvider"]
9:I[231,["231","static/chunks/231-34a6a67d2da26855.js","827","static/chunks/827-69594f61c16b8a9c.js","797","static/chunks/app/blog/%5B...slug%5D/page-bd056182432da53b.js"],""]
a:I[8173,["231","static/chunks/231-34a6a67d2da26855.js","827","static/chunks/827-69594f61c16b8a9c.js","797","static/chunks/app/blog/%5B...slug%5D/page-bd056182432da53b.js"],"Image"]
b:I[509,["599","static/chunks/ebde5ed1-51545511fe0d5050.js","231","static/chunks/231-34a6a67d2da26855.js","827","static/chunks/827-69594f61c16b8a9c.js","850","static/chunks/850-ecf153581cc02044.js","185","static/chunks/app/layout-54bebb918ae7f176.js"],"KBarButton"]
c:I[1398,["599","static/chunks/ebde5ed1-51545511fe0d5050.js","231","static/chunks/231-34a6a67d2da26855.js","827","static/chunks/827-69594f61c16b8a9c.js","850","static/chunks/850-ecf153581cc02044.js","185","static/chunks/app/layout-54bebb918ae7f176.js"],"default"]
d:I[7606,["599","static/chunks/ebde5ed1-51545511fe0d5050.js","231","static/chunks/231-34a6a67d2da26855.js","827","static/chunks/827-69594f61c16b8a9c.js","850","static/chunks/850-ecf153581cc02044.js","185","static/chunks/app/layout-54bebb918ae7f176.js"],"default"]
e:I[7510,["599","static/chunks/ebde5ed1-51545511fe0d5050.js","231","static/chunks/231-34a6a67d2da26855.js","827","static/chunks/827-69594f61c16b8a9c.js","850","static/chunks/850-ecf153581cc02044.js","185","static/chunks/app/layout-54bebb918ae7f176.js"],"default"]
f:I[8976,["599","static/chunks/ebde5ed1-51545511fe0d5050.js","231","static/chunks/231-34a6a67d2da26855.js","827","static/chunks/827-69594f61c16b8a9c.js","850","static/chunks/850-ecf153581cc02044.js","185","static/chunks/app/layout-54bebb918ae7f176.js"],"default"]
4:["slug","go/memory-ballast","c"]
0:["Ts-6BBsjdSlBnGT_Ikyc2",[[["",{"children":["blog",{"children":[["slug","go/memory-ballast","c"],{"children":["__PAGE__?{\"slug\":[\"go\",\"memory-ballast\"]}",{}]}]}]},"$undefined","$undefined",true],["",{"children":["blog",{"children":[["slug","go/memory-ballast","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/a9b9096fa657c0d0.css","precedence":"next","crossOrigin":"$undefined"}]]}],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"en-us","className":"__variable_dd5b2f scroll-smooth","suppressHydrationWarning":true,"children":[["$","head",null,{"children":[["$","link",null,{"rel":"icon","type":"image/png","href":"https://mainjaylai.github.io/favicon.png"}],["$","link",null,{"rel":"manifest","href":"/static/favicons/manifest.json"}],["$","meta",null,{"name":"msapplication-TileColor","content":"#000000"}],["$","link",null,{"href":"https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@200..900&display=swap","rel":"stylesheet"}],["$","link",null,{"href":"https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&family=ZCOOL+QingKe+HuangYou&family=ZCOOL+XiaoWei&display=swap","rel":"stylesheet"}],["$","script",null,{"src":"https://us.umami.is/script.js","async":true}],["$","meta",null,{"name":"theme-color","media":"(prefers-color-scheme: light)","content":"#fff"}],["$","meta",null,{"name":"theme-color","media":"(prefers-color-scheme: dark)","content":"#000"}],["$","meta",null,{"name":"referrer","content":"no-referrer"}],["$","script",null,{"src":"https://cdn.jsdelivr.net/gh/ashishagarwal2023/freegptjs@1.0.2/src/freegpt.min.js"}],["$","link",null,{"rel":"alternate","type":"application/rss+xml","href":"/feed.xml"}]]}],["$","body",null,{"className":"bg-white pl-[calc(100vw-100%)] text-black antialiased dark:bg-gray-950 dark:text-white","suppressHydrationWarning":true,"children":["$","$L6",null,{"children":[["$undefined","$undefined","$undefined",["$","$L7",null,{"async":true,"defer":true,"data-website-id":"bbe21cb3-3de3-4ba7-b6de-453053bc6ae8","src":"https://us.umami.is/script.js"}],"$undefined","$undefined"],["$","section",null,{"className":"mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0","children":["$","div",null,{"className":"flex h-screen flex-col justify-between font-sans","children":[["$","$L8",null,{"kbarConfig":{"searchDocumentsPath":"/search.json"},"children":[["$","header",null,{"className":"flex items-center justify-between py-5","children":[["$","div",null,{"children":["$","$L9",null,{"href":"/","aria-label":"Blog","children":["$","div",null,{"className":"flex items-center justify-between","children":[["$","div",null,{"className":"mr-3","children":["$","$La",null,{"src":"https://mainjaylai.github.io/favicon.png","width":44,"height":44,"alt":"logo"}]}],["$","div",null,{"className":"hidden h-[44px] text-center text-3xl font-semibold leading-10 sm:block","children":"Blog"}]]}]}]}],["$","div",null,{"className":"flex items-center space-x-4 leading-5 sm:space-x-6","children":[[["$","$L9",null,{"href":"/blog","className":"navbar-item hidden font-medium text-gray-900 dark:text-gray-100 sm:block","children":"Blog"}],["$","$L9",null,{"href":"/tags","className":"navbar-item hidden font-medium text-gray-900 dark:text-gray-100 sm:block","children":"Tags"}],["$","a",null,{"target":"_blank","rel":"noopener noreferrer","href":"https://mainjaylai.github.io","className":"navbar-item hidden font-medium text-gray-900 dark:text-gray-100 sm:block","children":"About"}]],["$","$Lb",null,{"aria-label":"Search","children":["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","fill":"none","viewBox":"0 0 24 24","strokeWidth":1.5,"stroke":"currentColor","className":"h-6 w-6 text-gray-900 dark:text-gray-100","children":["$","path",null,{"strokeLinecap":"round","strokeLinejoin":"round","d":"M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"}]}]}],["$","$Lc",null,{}],["$","$Ld",null,{}],["$","$Le",null,{}],["$","$Lf",null,{}]]}]]}],["$","main",null,{"className":"mb-auto","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"flex flex-col items-start justify-start md:mt-24 md:flex-row md:items-center md:justify-center md:space-x-6","children":[["$","div",null,{"className":"space-x-2 pb-8 pt-6 md:space-y-5","children":["$","h1",null,{"className":"text-6xl font-extrabold leading-9 tracking-tight text-gray-900 dark:text-gray-100 md:border-r-2 md:px-6 md:text-8xl md:leading-14","children":"404"}]}],["$","div",null,{"className":"max-w-md","children":[["$","p",null,{"className":"mb-4 text-xl font-bold leading-normal md:text-2xl","children":"Sorry we couldn't find this page."}],["$","p",null,{"className":"mb-8","children":"But dont worry, you can find plenty of other things on our homepage."}],["$","$L9",null,{"href":"/","className":"focus:shadow-outline-blue inline rounded-lg border border-transparent bg-blue-600 px-4 py-2 text-sm font-medium leading-5 text-white shadow transition-colors duration-150 hover:bg-blue-700 focus:outline-none dark:hover:bg-blue-500","children":"Back to homepage"}]]}]]}],"notFoundStyles":[],"styles":null}]}]]}],["$","footer",null,{"children":["$","div",null,{"className":"mt-16 flex flex-col items-center","children":[["$","div",null,{"className":"mb-3 flex space-x-4","children":[["$","a",null,{"className":"text-sm !text-gray-500 transition hover:text-gray-600","target":"_blank","rel":"noopener noreferrer","href":"mailto:mainjaylai@outlook.com","children":[["$","span",null,{"className":"sr-only","children":"mail"}],["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 20 20","className":"fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6","children":[["$","path",null,{"d":"M2.003 5.884L10 9.882l7.997-3.998A2 2 0 0016 4H4a2 2 0 00-1.997 1.884z"}],["$","path",null,{"d":"M18 8.118l-8 4-8-4V14a2 2 0 002 2h12a2 2 0 002-2V8.118z"}]]}]]}],["$","a",null,{"className":"text-sm !text-gray-500 transition hover:text-gray-600","target":"_blank","rel":"noopener noreferrer","href":"https://github.com/mainjaylai","children":[["$","span",null,{"className":"sr-only","children":"github"}],["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 24 24","className":"fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6","children":["$","path",null,{"d":"M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"}]}]]}],["$","a",null,{"className":"text-sm !text-gray-500 transition hover:text-gray-600","target":"_blank","rel":"noopener noreferrer","href":"https://gitlab.com/JayMain","children":[["$","span",null,{"className":"sr-only","children":"gitlab"}],["$","svg",null,{"viewBox":"0 0 1024 1024","xmlns":"http://www.w3.org/2000/svg","className":"fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6","width":"200","height":"200","children":["$","path",null,{"d":"M1022.08 579.712l-57.258667-176.426667-113.664-349.397333a19.413333 19.413333 0 0 0-36.992 0L700.501333 403.2H323.498667L209.877333 53.888C204.074667 35.84 178.56 35.84 172.8 53.76L59.136 403.157333 1.877333 579.712a39.424 39.424 0 0 0 14.122667 43.648L512 983.637333l496-360.234666a39.253333 39.253333 0 0 0 14.08-43.690667"}]}]]}],["$","a",null,{"className":"text-sm !text-gray-500 transition hover:text-gray-600","target":"_blank","rel":"noopener noreferrer","href":"https://gitee.com/lmj2001","children":[["$","span",null,{"className":"sr-only","children":"gitee"}],["$","svg",null,{"viewBox":"0 0 1024 1024","xmlns":"http://www.w3.org/2000/svg","className":"fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6","width":"200","height":"200","children":["$","path",null,{"d":"M512 992C246.895625 992 32 777.104375 32 512S246.895625 32 512 32s480 214.895625 480 480-214.895625 480-480 480z m242.9521875-533.3278125h-272.56875a23.7121875 23.7121875 0 0 0-23.71125 23.7121875l-0.024375 59.255625c0 13.08 10.6078125 23.7121875 23.6878125 23.7121875h165.96c13.104375 0 23.7121875 10.6078125 23.7121875 23.6878125v11.855625a71.1121875 71.1121875 0 0 1-71.1121875 71.1121875h-225.215625a23.7121875 23.7121875 0 0 1-23.6878125-23.7121875V423.1278125a71.1121875 71.1121875 0 0 1 71.0878125-71.1121875h331.824375a23.7121875 23.7121875 0 0 0 23.6878125-23.71125l0.0721875-59.2565625a23.7121875 23.7121875 0 0 0-23.68875-23.7121875H423.08a177.76875 177.76875 0 0 0-177.76875 177.7921875V754.953125c0 13.1034375 10.60875 23.7121875 23.713125 23.7121875h349.63125a159.984375 159.984375 0 0 0 159.984375-159.984375V482.36a23.7121875 23.7121875 0 0 0-23.7121875-23.6878125z"}]}]]}]]}],["$","div",null,{"className":"mb-2 flex space-x-2 text-sm text-gray-500 dark:text-gray-400","children":[["$","div",null,{"children":"MainJayLai"}],["$","div",null,{"children":" • "}],["$","div",null,{"children":"© 2025"}],["$","div",null,{"children":" • "}],["$","$L9",null,{"href":"/","children":"MainJayLai Blog"}]]}]]}]}]]}]}]]}]}]]}],null],null],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/c890694439b2475b.css","precedence":"next","crossOrigin":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/1ea5cf861ee12a80.css","precedence":"next","crossOrigin":"$undefined"}]],"$L10"]]]]
11:I[4347,["231","static/chunks/231-34a6a67d2da26855.js","827","static/chunks/827-69594f61c16b8a9c.js","797","static/chunks/app/blog/%5B...slug%5D/page-bd056182432da53b.js"],"default"]
12:I[408,["231","static/chunks/231-34a6a67d2da26855.js","827","static/chunks/827-69594f61c16b8a9c.js","797","static/chunks/app/blog/%5B...slug%5D/page-bd056182432da53b.js"],"default"]
13:I[9629,["231","static/chunks/231-34a6a67d2da26855.js","827","static/chunks/827-69594f61c16b8a9c.js","797","static/chunks/app/blog/%5B...slug%5D/page-bd056182432da53b.js"],"default"]
2:[["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"BlogPosting\",\"headline\":\"Go语言的内存镇流器\",\"datePublished\":\"2024-10-17T00:00:00.000Z\",\"dateModified\":\"2024-10-17T00:00:00.000Z\",\"description\":\"我们通过引入内存镇流器减少了Go应用程序的垃圾回收（GC）周期频率，从而改善了API响应时间。这种做法允许堆在更大范围内增长，减少了GC辅助延迟，而镇流器的虚拟内存分配几乎不消耗实际RAM。相比调整GOGC值，使用镇流器更易于推理与管理。最后，深入分析性能瓶颈是提高应用效率的关键。\",\"image\":\"https://pngimg.com/uploads/github/github_PNG80.png\",\"url\":\"https://blog.mainjay.cloudns.ch/blog/go/memory-ballast\",\"author\":[{\"@type\":\"Person\",\"name\":\"mainJayLai\"}]}"}}],["$","section",null,{"className":"mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0","children":[["$","$L11",null,{}],["$","article",null,{"children":["$","div",null,{"children":[["$","header",null,{"children":["$","div",null,{"className":"space-y-1 border-b border-gray-200 pb-10 text-center dark:border-gray-700","children":[["$","div",null,{"className":"beautiful-chinese-title","children":["$","h1",null,{"className":"text-3xl font-extrabold leading-9 tracking-tight text-gray-900 dark:text-gray-100 sm:text-4xl sm:leading-10 md:text-5xl md:leading-14","children":"Go语言的内存镇流器"}]}],["$","dl",null,{"children":["$","div",null,{"children":[["$","dt",null,{"className":"sr-only","children":"Published on"}],["$","dd",null,{"className":"text-base font-medium leading-6 text-gray-500 dark:text-gray-400","children":["$","time",null,{"dateTime":"2024-10-17T00:00:00.000Z","children":"October 17, 2024"}]}]]}]}]]}]}],["$","div",null,{"className":"grid-rows-[auto_1fr] divide-y divide-gray-200 pb-8 dark:divide-gray-700 xl:divide-y-0","children":[["$","div",null,{"className":"divide-y divide-gray-200 dark:divide-gray-700 xl:col-span-3 xl:row-span-2 xl:pb-0","children":["$","div",null,{"className":"beautiful-chinese-content prose max-w-none pb-8 pt-10 dark:prose-invert","children":[["$","p",null,{"children":[["$","strong",null,{"children":"“内存镇流器”"}],"（Memory Ballast）是一个形象的比喻，指的是一种优化Go程序内存使用的技术。就像船舶使用压舱物来增加稳定性一样，Go程序也可以通过预先分配一定量的内存来提升性能和稳定性，尤其是在应对突发流量时。"]}],["$","h2",null,{"className":"content-header","id":"背景介绍","children":[["$","a",null,{"href":"#背景介绍","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"背景介绍"]}],["$","p",null,{"children":"在Twitch平台上，有一个名为Visage的服务，它作为API前端，是所有外部出站API流量的中央网关。Visage负责处理多项关键任务，包括授权、请求路由以及服务端的GraphQL处理。因此，它需要具备良好的扩展能力，以应对用户流量的波动，这些流量模式有时可能超出我们的控制。作为API网关，Visage在Twitch的后端服务与外部世界之间扮演着关键角色，它的性能直接影响到用户体验和平台的整体稳定性。"}],["$","p",null,{"children":["例如，大型互联网公司常常遇到一种被称为 ",["$","strong",null,{"children":"“刷新风暴”"}]," 的流量模式。这种情况通常发生在一个受欢迎的主播因网络问题掉线时。主播重新开始直播后，观众会纷纷刷新他们的页面，导致服务器突然面临大量的API请求流量。"]}],["$","h2",null,{"className":"content-header","id":"挑战与应对","children":[["$","a",null,{"href":"#挑战与应对","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"挑战与应对"]}],["$","p",null,{"children":"Visage是一个基于Go语言开发的应用（在此次优化中使用的是Go 1.11版本），运行在Amazon EC2实例上，并配有负载均衡器。尽管EC2结合自动扩展组的能力能够很好地进行水平扩展，但在应对突发的巨大流量时，依然存在挑战。"}],["$","p",null,{"children":"在“刷新风暴”期间，服务器需要在几秒钟内处理数百万个请求，流量激增可能是平时的20倍。工程师们发现，当前端服务器负载过高时，API的响应延迟会显著增加，从而影响用户体验。"}],["$","p",null,{"children":"一种简单的解决方案是始终保持高冗余的服务器容量，以应对这些突发情况，但这种做法非常浪费且成本高昂。为了减少这些持续上升的成本，工程师们决定探索能够提高单台服务器吞吐量，并在负载高峰时提供更稳定请求处理的优化方案。经过研究，他们找到了“内存镇流器”这一技术，以帮助改善内存管理和程序的整体性能。"}],["$","h2",null,{"className":"content-header","id":"方案调研","children":[["$","a",null,{"href":"#方案调研","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"方案调研"]}],["$","p",null,{"children":["在优化过程中，工程师们在生产环境中运行了 ",["$","code",null,{"className":"custom-code","children":"pprof"}],"，这使得获取真实生产流量下的性能分析变得非常容易。如果你还没有使用过 ",["$","code",null,{"className":"custom-code","children":"pprof"}],"，我强烈建议你开始使用它。大多数情况下，性能分析器对CPU的负载影响非常小。即使是执行跟踪器，尽管有一些开销，但影响微乎其微，可以在生产环境中每小时运行几秒钟，而不会对服务造成显著影响。"]}],["$","p",null,{"children":"通过对Go应用的性能分析，我们得出以下观察结果："}],["$","ol",null,{"children":[["$","li",null,{"children":"在稳定状态下，我们的应用每秒大约运行8-10次垃圾回收（GC）周期（每分钟400-600次）。"}],["$","li",null,{"children":"超过30%的CPU时间消耗在与GC相关的函数上，这一比例相当高，表明存在很大的优化空间。"}],["$","li",null,{"children":"在流量激增期间，GC周期数量进一步增加，这会加剧性能问题，导致应用响应时间变长。"}],["$","li",null,{"children":"我们的堆内存大小相对较小，这表明内存使用效率较高，但也可能导致频繁的GC触发。"}]]}],["$","div",null,{"className":"flex flex-col items-center justify-center text-center","children":["$","div",null,{"children":["$","$La",null,{"src":"/static/images/go/memory-ballast/picture1.webp","alt":"GC Performance","width":"721","height":"289"}]}]}],["$","div",null,{"className":"flex flex-col items-center justify-center text-center","children":["$","div",null,{"children":["$","$La",null,{"src":"/static/images/go/memory-ballast/picture2.webp","alt":"Heap Usage Analysis","width":"516","height":"250"}]}]}],["$","p",null,{"children":"我们此次改进的重点是优化应用程序的垃圾回收性能，以提升整体处理能力。"}],["$","h2",null,{"className":"content-header","id":"什么是垃圾收集器gc","children":[["$","a",null,{"href":"#什么是垃圾收集器gc","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"什么是垃圾收集器（GC）？"]}],["$","p",null,{"children":"在现代编程中，通常有两种方式来分配内存：栈（stack）和堆（heap）。大多数程序员在第一次写出导致栈溢出的递归程序时，就已经对栈有了初步的了解。而堆则是一个用于动态内存分配的区域，适用于那些生命周期无法在编译时确定的对象。"}],["$","p",null,{"children":"栈内存的分配优势在于其生命周期与所属函数绑定，因此，当函数返回时，栈上的内存会自动释放。而堆上的内存则不会在超出作用域时自动释放。为了防止堆内存无限增长，我们要么手动释放内存，要么依赖像Go这样的编程语言中的垃圾收集器（GC），来查找并清除不再被引用的对象。"}],["$","p",null,{"children":"通常情况下，在有GC机制的语言中，尽可能多地在栈上分配内存是有益的，因为这些内存分配不会被GC察觉。Go语言通过逃逸分析（escape analysis）来确定对象是应该分配在栈上还是堆上。"}],["$","p",null,{"children":"然而，在实际应用中，编写只在栈上分配内存的程序往往非常受限。因此，我们依赖Go的高效垃圾收集器来维护堆内存的清洁，确保程序的性能和稳定性。"}],["$","h2",null,{"className":"content-header","id":"go的垃圾收集器","children":[["$","a",null,{"href":"#go的垃圾收集器","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"Go的垃圾收集器"]}],["$","p",null,{"children":["$","em",null,{"children":"垃圾收集器是复杂的软件组件。"}]}],["$","p",null,{"children":["从Go 1.5版本开始，Go引入了一个标记-清除（mark-and-sweep）垃圾收集器。顾名思义，这种GC机制包括两个主要阶段：",["$","strong",null,{"children":"标记"}],"和",["$","strong",null,{"children":"清除"}],"。与传统的“全程暂停应用程序”（Stop The World, STW）的垃圾回收不同，Go的GC在大多数情况下能够与应用程序代码并发运行，从而减少对程序执行的影响。"]}],["$","h3",null,{"className":"content-header","id":"标记和清除阶段","children":[["$","a",null,{"href":"#标记和清除阶段","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"标记和清除阶段"]}],["$","ol",null,{"children":[["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"标记阶段"}],"：运行时会遍历堆中所有被应用程序引用的对象，并将这些对象标记为“仍在使用中”。这些对象被称为",["$","strong",null,{"children":"活动内存"}],"。标记阶段的任务是找出所有仍然有用的数据，以确保它们不会被错误地回收。"]}]}],["$","li",null,{"children":["$","p",null,{"children":[["$","strong",null,{"children":"清除阶段"}],"：在标记阶段完成后，所有未被标记的对象就会被认为是垃圾。清除阶段的任务是将这些未被引用的对象从堆中移除，释放出相应的内存。"]}]}]]}],["$","p",null,{"children":"在整个GC周期中，虽然清除操作本质上是“STW”的，但由于现代操作系统在释放内存时的速度非常快，清除阶段所占用的时间通常较短。因此，标记阶段是影响GC时间的主要因素。"}],["$","h3",null,{"className":"content-header","id":"关键术语","children":[["$","a",null,{"href":"#关键术语","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"关键术语"]}],["$","ul",null,{"children":[["$","li",null,{"children":[["$","strong",null,{"children":"堆大小"}],"：包括堆中所有的内存分配，既包含当前被使用的，也包含已经成为垃圾的部分。"]}],["$","li",null,{"children":[["$","strong",null,{"children":"活动内存"}],"：指正在被应用程序引用的内存分配，是当前有用的部分，不包括垃圾。"]}]]}],["$","h3",null,{"className":"content-header","id":"标记阶段与性能的关系","children":[["$","a",null,{"href":"#标记阶段与性能的关系","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"标记阶段与性能的关系"]}],["$","p",null,{"children":["在标记阶段，运行时需要遍历应用程序当前引用的所有对象，因此标记所需的时间与活动内存的大小成正比，而与总堆大小无关。这意味着，即使堆中有大量的垃圾对象，也不会显著增加标记阶段所需的时间。因此，理论上讲，",["$","strong",null,{"children":"拥有更多垃圾对象并不会明显延长GC周期。"}]]}],["$","p",null,{"children":"然而，这种设计存在权衡。减少GC触发的频率，意味着垃圾清理的时间间隔变长，从而在内存中会积累更多的垃圾对象。这种权衡的结果就是：随着GC间隔的增加，系统内存消耗会变高。"}],["$","h3",null,{"className":"content-header","id":"visage应用程序中的实际问题","children":[["$","a",null,{"href":"#visage应用程序中的实际问题","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"Visage应用程序中的实际问题"]}],["$","p",null,{"children":"在Visage应用程序中，我们注意到它运行在专有的虚拟机上，拥有64GiB的物理内存，但即便如此，应用程序的GC非常频繁，而实际使用的物理内存仅约400MiB。这种现象表明GC频率过高，造成了CPU资源的浪费。要理解这种情况，我们需要深入了解Go如何在GC频率和内存使用之间进行权衡，这就涉及到Go垃圾收集的步调控制器（Pacer）。"}],["$","h2",null,{"className":"content-header","id":"pacer步调控制器","children":[["$","a",null,{"href":"#pacer步调控制器","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"Pacer（步调控制器）"]}],["$","p",null,{"children":["Go 的 GC 使用 ",["$","strong",null,{"children":"步调控制器"}]," 来决定何时启动下一个 GC 周期。这被建模为一个控制问题，它试图找到正确的时机来触发 GC 周期，以达到目标堆大小。默认情况下，Go 的步调控制器会尝试在堆大小每次翻倍时启动一个 GC 周期。这是通过在当前 GC 周期的标记终止阶段设置下一个堆触发大小来实现的。因此，在标记完所有活动内存后，它可以决定在总堆大小是当前集合的 2 倍时运行下一次 GC。这个 2 倍值来自运行时使用的 ",["$","code",null,{"className":"custom-code","children":"GOGC"}]," 环境变量设置的触发器比率。"]}],["$","p",null,{"children":"在我们的场景中，步调控制器有效地将堆上的垃圾保持在最小限度，但代价是引入了大量不必要的GC操作，因为应用程序仅使用了系统内存的约0.6%。"}],["$","h3",null,{"className":"content-header","id":"引入内存镇流器ballast","children":[["$","a",null,{"href":"#引入内存镇流器ballast","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"引入内存镇流器（Ballast）"]}],["$","p",null,{"children":"我们通过在应用程序启动时分配一个大型字节数组（例如10 GiB）来实现内存镇流器，这样做的目的是增加堆的稳定性："}],["$","$L12",null,{"className":"language-go","children":["$","code",null,{"className":"language-go code-highlight","children":[["$","span",null,{"className":"code-line","children":[["$","span",null,{"className":"token keyword","children":"func"}]," ",["$","span",null,{"className":"token function","children":"main"}],["$","span",null,{"className":"token punctuation","children":"("}],["$","span",null,{"className":"token punctuation","children":")"}]," ",["$","span",null,{"className":"token punctuation","children":"{"}],"\n"]}],["$","span",null,{"className":"code-line","children":["\t",["$","span",null,{"className":"token comment","children":"// 创建一个10 GiB的大型堆分配"}],"\n"]}],["$","span",null,{"className":"code-line","children":["\tballast ",["$","span",null,{"className":"token operator","children":":="}]," ",["$","span",null,{"className":"token function","children":"make"}],["$","span",null,{"className":"token punctuation","children":"("}],["$","span",null,{"className":"token punctuation","children":"["}],["$","span",null,{"className":"token punctuation","children":"]"}],["$","span",null,{"className":"token builtin","children":"byte"}],["$","span",null,{"className":"token punctuation","children":","}]," ",["$","span",null,{"className":"token number","children":"10"}],["$","span",null,{"className":"token operator","children":"<<"}],["$","span",null,{"className":"token number","children":"30"}],["$","span",null,{"className":"token punctuation","children":")"}],"\n"]}],["$","span",null,{"className":"code-line","children":["\t",["$","span",null,{"className":"token comment","children":"// 继续执行应用程序"}],"\n"]}],["$","span",null,{"className":"code-line","children":["\t",["$","span",null,{"className":"token comment","children":"// ..."}],"\n"]}],["$","span",null,{"className":"code-line","children":[["$","span",null,{"className":"token punctuation","children":"}"}],"\n"]}]]}]}],["$","h3",null,{"className":"content-header","id":"解释","children":[["$","a",null,{"href":"#解释","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"解释"]}],["$","h4",null,{"className":"content-header","id":"1-为什么使用内存镇流器","children":[["$","a",null,{"href":"#1-为什么使用内存镇流器","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"1. 为什么使用内存镇流器？"]}],["$","p",null,{"children":"如前所述，GC 会在堆大小每次翻倍时触发。堆大小是堆上所有分配的总大小。因此，如果分配了 10GB 的镇流器，下一次 GC 只会在堆大小增长到 20GB 时触发。此时，大约会有 10GB 的镇流器 + 10GB 的其他分配。"}],["$","p",null,{"children":"当 GC 运行时，镇流器不会被当作垃圾清除，因为我们在 main 函数中仍然保持对它的引用，因此它被视为活动内存的一部分。由于我们应用程序中的大多数分配只在短暂的 API 请求生命周期内存在，10GB 分配中的大部分将被清除，将堆大小再次减小到略高于 ~10GB (即 10GB 镇流器加上所有正在进行的请求中被认为是活动内存的分配)。现在，下一个 GC 周期将在堆大小（当前略高于 10GB）再次翻倍时发生。"}],["$","p",null,{"children":"因此，镇流器增加了基本堆大小，使得我们的 GC 触发被延迟，随时间推移 GC 周期的数量减少。这个改变如预期那样起作用了 - 我们看到 GC 周期减少了约 99%："}],["$","div",null,{"className":"flex flex-col items-center justify-center text-center","children":["$","div",null,{"children":["$","$La",null,{"src":"/static/images/go/memory-ballast/picture3.webp","alt":"GC Reduction Graph","width":"1658","height":"498"}]}]}],["$","p",null,{"children":"那么这看起来不错,CPU使用率呢?"}],["$","div",null,{"className":"flex flex-col items-center justify-center text-center","children":["$","div",null,{"children":["$","$La",null,{"src":"/static/images/go/memory-ballast/picture4.webp","alt":"GC Reduction Graph","width":"1400","height":"454"}]}]}],["$","p",null,{"children":"绿色的正弦波形CPU指标是由我们流量的每日波动引起的。可以看到改变后有一个明显的下降。"}],["$","p",null,{"children":"~30%的CPU减少意味着不用进一步观察，我们可以将波动减少30%，然而我们也关心API延迟——稍后会详细讨论这一点。"}],["$","p",null,{"children":["如前所述,Go运行时提供了一个",["$","code",null,{"className":"custom-code","children":"GOGC"}],"环境变量，允许对GC步调控制器进行非常粗略的调整。这个值控制堆在运行GC之前的增长比例。我们决定不使用它，因为它有一些明显的缺点:"]}],["$","ul",null,{"children":[["$","li",null,{"children":"比例本身对我们来说并不重要；我们使用的内存量才是。"}],["$","li",null,{"children":"我们必须将值设置得非常高才能获得与镇流器相同的效果，使得该值对活动堆大小的小变化很敏感。"}],["$","li",null,{"children":"推理活动内存及其变化率并不容易;而思考总使用内存则很简单。"}]]}],["$","p",null,{"children":["$","em",null,{"children":"如果你想知道为什么我们使用字节数组作为镇流器,这保证我们只向标记阶段添加一个额外的对象。因为字节数组没有任何指针(除了对象本身),GC可以在O(1)时间内标记整个对象。"}]}],["$","h4",null,{"className":"content-header","id":"2-这不会浪费10-gib的物理内存吗","children":[["$","a",null,{"href":"#2-这不会浪费10-gib的物理内存吗","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"2. 这不会浪费10 GiB的物理内存吗？"]}],["$","p",null,{"children":["简短的回答是：不会，除非你在代码中访问这些内存。在Unix系统（包括Windows）中，内存是通过操作系统的页表进行映射的。尽管",["$","code",null,{"className":"custom-code","children":"make([]byte, 10<<30)"}],"会在程序的虚拟地址空间中创建一个10 GiB的数组，但实际的物理内存只有在对该数组进行读写时才会被分配。只有当我们试图读取或写入切片时，才会发生页面错误，导致支持虚拟地址的物理 RAM 被分配。"]}],["$","p",null,{"children":"可以通过以下简单程序进行验证："}],["$","$L12",null,{"className":"language-go","children":["$","code",null,{"className":"language-go code-highlight","children":[["$","span",null,{"className":"code-line","children":[["$","span",null,{"className":"token keyword","children":"func"}]," ",["$","span",null,{"className":"token function","children":"main"}],["$","span",null,{"className":"token punctuation","children":"("}],["$","span",null,{"className":"token punctuation","children":")"}]," ",["$","span",null,{"className":"token punctuation","children":"{"}],"\n"]}],["$","span",null,{"className":"code-line","children":["    ",["$","span",null,{"className":"token boolean","children":"_"}]," ",["$","span",null,{"className":"token operator","children":"="}]," ",["$","span",null,{"className":"token function","children":"make"}],["$","span",null,{"className":"token punctuation","children":"("}],["$","span",null,{"className":"token punctuation","children":"["}],["$","span",null,{"className":"token punctuation","children":"]"}],["$","span",null,{"className":"token builtin","children":"byte"}],["$","span",null,{"className":"token punctuation","children":","}]," ",["$","span",null,{"className":"token number","children":"100"}],["$","span",null,{"className":"token operator","children":"<<"}],["$","span",null,{"className":"token number","children":"20"}],["$","span",null,{"className":"token punctuation","children":")"}],"\n"]}],["$","span",null,{"className":"code-line","children":["    ",["$","span",null,{"className":"token operator","children":"<-"}],"time",["$","span",null,{"className":"token punctuation","children":"."}],["$","span",null,{"className":"token function","children":"After"}],["$","span",null,{"className":"token punctuation","children":"("}],"time",["$","span",null,{"className":"token punctuation","children":"."}],["$","span",null,{"className":"token function","children":"Duration"}],["$","span",null,{"className":"token punctuation","children":"("}],"math",["$","span",null,{"className":"token punctuation","children":"."}],"MaxInt64",["$","span",null,{"className":"token punctuation","children":")"}],["$","span",null,{"className":"token punctuation","children":")"}],"\n"]}],["$","span",null,{"className":"code-line","children":[["$","span",null,{"className":"token punctuation","children":"}"}],"\n"]}]]}]}],["$","p",null,{"children":["运行程序后使用",["$","code",null,{"className":"custom-code","children":"ps"}],"查看内存分配："]}],["$","$L12",null,{"className":"language-shell","children":["$","code",null,{"className":"code-highlight language-shell","children":[["$","span",null,{"className":"code-line","children":"%MEM  COMMAND          PID    MAJFL  MINFL  RSS   VSZ\n"}],["$","span",null,{"className":"code-line","children":[["$","span",null,{"className":"token number","children":"0.2"}],"   test_alloc       ",["$","span",null,{"className":"token number","children":"27826"}],"  ",["$","span",null,{"className":"token number","children":"0"}],"      ",["$","span",null,{"className":"token number","children":"1003"}],"   ",["$","span",null,{"className":"token number","children":"4"}],".8M  108M\n"]}]]}]}],["$","p",null,{"children":"这表示进程的虚拟内存分配（VSZ）约为100 MiB，但实际占用的物理内存（RSS）仅为~5 MiB。"}],["$","p",null,{"children":"接下来，如果我们修改程序，让它写入一半的字节数组："}],["$","$L12",null,{"className":"language-go","children":["$","code",null,{"className":"language-go code-highlight","children":[["$","span",null,{"className":"code-line","children":[["$","span",null,{"className":"token keyword","children":"func"}]," ",["$","span",null,{"className":"token function","children":"main"}],["$","span",null,{"className":"token punctuation","children":"("}],["$","span",null,{"className":"token punctuation","children":")"}]," ",["$","span",null,{"className":"token punctuation","children":"{"}],"\n"]}],["$","span",null,{"className":"code-line","children":["\tballast ",["$","span",null,{"className":"token operator","children":":="}]," ",["$","span",null,{"className":"token function","children":"make"}],["$","span",null,{"className":"token punctuation","children":"("}],["$","span",null,{"className":"token punctuation","children":"["}],["$","span",null,{"className":"token punctuation","children":"]"}],["$","span",null,{"className":"token builtin","children":"byte"}],["$","span",null,{"className":"token punctuation","children":","}]," ",["$","span",null,{"className":"token number","children":"100"}],["$","span",null,{"className":"token operator","children":"<<"}],["$","span",null,{"className":"token number","children":"20"}],["$","span",null,{"className":"token punctuation","children":")"}],"\n"]}],["$","span",null,{"className":"code-line","children":["\t",["$","span",null,{"className":"token keyword","children":"for"}]," i ",["$","span",null,{"className":"token operator","children":":="}]," ",["$","span",null,{"className":"token number","children":"0"}],["$","span",null,{"className":"token punctuation","children":";"}]," i ",["$","span",null,{"className":"token operator","children":"<"}]," ",["$","span",null,{"className":"token function","children":"len"}],["$","span",null,{"className":"token punctuation","children":"("}],"ballast",["$","span",null,{"className":"token punctuation","children":")"}],["$","span",null,{"className":"token operator","children":"/"}],["$","span",null,{"className":"token number","children":"2"}],["$","span",null,{"className":"token punctuation","children":";"}]," i",["$","span",null,{"className":"token operator","children":"++"}]," ",["$","span",null,{"className":"token punctuation","children":"{"}],"\n"]}],["$","span",null,{"className":"code-line","children":["\t\tballast",["$","span",null,{"className":"token punctuation","children":"["}],"i",["$","span",null,{"className":"token punctuation","children":"]"}]," ",["$","span",null,{"className":"token operator","children":"="}]," ",["$","span",null,{"className":"token function","children":"byte"}],["$","span",null,{"className":"token punctuation","children":"("}],["$","span",null,{"className":"token char","children":"'A'"}],["$","span",null,{"className":"token punctuation","children":")"}],"\n"]}],["$","span",null,{"className":"code-line","children":["\t",["$","span",null,{"className":"token punctuation","children":"}"}],"\n"]}],["$","span",null,{"className":"code-line","children":["\t",["$","span",null,{"className":"token operator","children":"<-"}],"time",["$","span",null,{"className":"token punctuation","children":"."}],["$","span",null,{"className":"token function","children":"After"}],["$","span",null,{"className":"token punctuation","children":"("}],"time",["$","span",null,{"className":"token punctuation","children":"."}],["$","span",null,{"className":"token function","children":"Duration"}],["$","span",null,{"className":"token punctuation","children":"("}],"math",["$","span",null,{"className":"token punctuation","children":"."}],"MaxInt64",["$","span",null,{"className":"token punctuation","children":")"}],["$","span",null,{"className":"token punctuation","children":")"}],"\n"]}],["$","span",null,{"className":"code-line","children":[["$","span",null,{"className":"token punctuation","children":"}"}],"\n"]}]]}]}],["$","p",null,{"children":["再次检查",["$","code",null,{"className":"custom-code","children":"ps"}],"输出："]}],["$","$L12",null,{"className":"language-shell","children":["$","code",null,{"className":"code-highlight language-shell","children":[["$","span",null,{"className":"code-line","children":"%MEM  COMMAND          PID    MAJFL  MINFL  RSS   VSZ\n"}],["$","span",null,{"className":"code-line","children":[["$","span",null,{"className":"token number","children":"2.7"}],"   test_alloc       ",["$","span",null,{"className":"token number","children":"28331"}],"  ",["$","span",null,{"className":"token number","children":"0"}],"      ",["$","span",null,{"className":"token number","children":"1"}],".5K   57M   108M\n"]}]]}]}],["$","p",null,{"children":"正如预期的那样，现在字节数组的一半在 RSS 中，占用物理内存。VSZ 没有变化，因为在两个程序中都存在相同大小的虚拟分配。"}],["$","p",null,{"children":["$","em",null,{"children":"对于那些感兴趣的人，MINFL 列是次要页面错误的数量 - 这是发生在进程中需要从内存加载页面的页面错误数量。如果 OS 成功地很好地连续分配了我们的物理内存，那么每个页面错误将能够映射多个 RAM 页面，减少发生的总页面错误数量。"}]}],["$","p",null,{"children":[["$","strong",null,{"children":"总结"}],"："]}],["$","ol",null,{"children":[["$","li",null,{"children":[["$","strong",null,{"children":"内存镇流器的优势"}],"：通过增加堆基准大小，内存镇流器减少了GC周期的频率，从而降低了CPU的使用率，提升了应用程序的整体性能。"]}],["$","li",null,{"children":[["$","strong",null,{"children":"物理内存的利用"}],"：镇流器作为虚拟分配存在，只要不读写它，其内存开销几乎不会反映在实际的物理内存中。"]}]]}],["$","h2",null,{"className":"content-header","id":"api延迟","children":[["$","a",null,{"href":"#api延迟","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"API延迟"]}],["$","p",null,{"children":"正如前面提到的，我们观察到减少GC频率后，API延迟得到了改善，尤其是在高负载期间。最初，我们猜测这是因为GC暂停时间减少了。然而，改变前后GC暂停时间的差异并不显著，而且暂停时间仅为单位数毫秒，而我们在峰值负载时观察到的延迟却达到100毫秒级。"}],["$","p",null,{"children":["要更好地理解延迟改善的原因，我们需要探讨Go GC中的一个重要特性——",["$","strong",null,{"children":"GC assists"}],"。"]}],["$","h3",null,{"className":"content-header","id":"gc-assists","children":[["$","a",null,{"href":"#gc-assists","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"GC assists"]}],["$","p",null,{"children":["GC assists机制会在",["$","strong",null,{"children":"GC周期期间"}],"将部分内存分配工作转移到正在执行分配操作的goroutine上。没有这种机制，Go运行时就无法在GC周期期间控制堆的增长。"]}],["$","p",null,{"children":"Go已经有一个后台GC工作线程，而__“assists”__意味着用户的goroutine会帮助后台GC线程进行特定的工作，尤其是标记阶段的工作。"}],["$","p",null,{"children":"为了更好地理解这一点，让我们看一个例子:"}],["$","$L12",null,{"className":"language-go","children":["$","code",null,{"className":"language-go code-highlight","children":["$","span",null,{"className":"code-line","children":["someObject ",["$","span",null,{"className":"token operator","children":":="}],"  ",["$","span",null,{"className":"token function","children":"make"}],["$","span",null,{"className":"token punctuation","children":"("}],["$","span",null,{"className":"token punctuation","children":"["}],["$","span",null,{"className":"token punctuation","children":"]"}],["$","span",null,{"className":"token builtin","children":"int"}],["$","span",null,{"className":"token punctuation","children":","}]," ",["$","span",null,{"className":"token number","children":"5"}],["$","span",null,{"className":"token punctuation","children":")"}],"\n"]}]}]}],["$","p",null,{"children":["当这段代码执行时，goroutine通过一系列符号转换和类型检查，最终调用",["$","code",null,{"className":"custom-code","children":"runtime.mallocgc"}],"来为切片分配内存。",["$","code",null,{"className":"custom-code","children":"runtime.mallocgc"}],"内部包含一些有趣的逻辑："]}],["$","$L12",null,{"className":"language-go","children":["$","code",null,{"className":"language-go code-highlight","children":[["$","span",null,{"className":"code-line","children":[["$","span",null,{"className":"token comment","children":"// 分配指定大小的对象。"}],"\n"]}],["$","span",null,{"className":"code-line","children":[["$","span",null,{"className":"token keyword","children":"func"}]," ",["$","span",null,{"className":"token function","children":"mallocgc"}],["$","span",null,{"className":"token punctuation","children":"("}],"size ",["$","span",null,{"className":"token builtin","children":"uintptr"}],["$","span",null,{"className":"token punctuation","children":","}]," typ ",["$","span",null,{"className":"token operator","children":"*"}],"_type",["$","span",null,{"className":"token punctuation","children":","}]," needzero ",["$","span",null,{"className":"token builtin","children":"bool"}],["$","span",null,{"className":"token punctuation","children":")"}]," unsafe",["$","span",null,{"className":"token punctuation","children":"."}],"Pointer ",["$","span",null,{"className":"token punctuation","children":"{"}],"\n"]}],["$","span",null,{"className":"code-line","children":"\n"}],["$","span",null,{"className":"code-line","children":["  \t",["$","span",null,{"className":"token comment","children":"// 一些错误检查和调试代码被省略..."}],"\n"]}],["$","span",null,{"className":"code-line","children":"\n"}],["$","span",null,{"className":"code-line","children":["\t",["$","span",null,{"className":"token comment","children":"// assistG是用于此分配的G（goroutine），如果GC未激活则为nil。"}],"\n"]}],["$","span",null,{"className":"code-line","children":["\t",["$","span",null,{"className":"token keyword","children":"var"}]," assistG ",["$","span",null,{"className":"token operator","children":"*"}],"g\n"]}],["$","span",null,{"className":"code-line","children":["\t",["$","span",null,{"className":"token keyword","children":"if"}]," gcBlackenEnabled ",["$","span",null,{"className":"token operator","children":"!="}]," ",["$","span",null,{"className":"token number","children":"0"}]," ",["$","span",null,{"className":"token punctuation","children":"{"}],"\n"]}],["$","span",null,{"className":"code-line","children":["\t\tassistG ",["$","span",null,{"className":"token operator","children":"="}]," ",["$","span",null,{"className":"token function","children":"getg"}],["$","span",null,{"className":"token punctuation","children":"("}],["$","span",null,{"className":"token punctuation","children":")"}],"\n"]}],["$","span",null,{"className":"code-line","children":["\t\t",["$","span",null,{"className":"token comment","children":"// 对当前的goroutine进行“收费”。"}],"\n"]}],["$","span",null,{"className":"code-line","children":["\t\tassistG",["$","span",null,{"className":"token punctuation","children":"."}],"gcAssistBytes ",["$","span",null,{"className":"token operator","children":"-="}]," ",["$","span",null,{"className":"token function","children":"int64"}],["$","span",null,{"className":"token punctuation","children":"("}],"size",["$","span",null,{"className":"token punctuation","children":")"}],"\n"]}],["$","span",null,{"className":"code-line","children":"\n"}],["$","span",null,{"className":"code-line","children":["\t\t",["$","span",null,{"className":"token keyword","children":"if"}]," assistG",["$","span",null,{"className":"token punctuation","children":"."}],"gcAssistBytes ",["$","span",null,{"className":"token operator","children":"<"}]," ",["$","span",null,{"className":"token number","children":"0"}]," ",["$","span",null,{"className":"token punctuation","children":"{"}],"\n"]}],["$","span",null,{"className":"code-line","children":["\t\t\t",["$","span",null,{"className":"token comment","children":"// 当goroutine有分配债务时，调用gcAssistAlloc进行GC工作。"}],"\n"]}],["$","span",null,{"className":"code-line","children":["\t\t\t",["$","span",null,{"className":"token function","children":"gcAssistAlloc"}],["$","span",null,{"className":"token punctuation","children":"("}],"assistG",["$","span",null,{"className":"token punctuation","children":")"}],"\n"]}],["$","span",null,{"className":"code-line","children":["\t\t",["$","span",null,{"className":"token punctuation","children":"}"}],"\n"]}],["$","span",null,{"className":"code-line","children":["\t",["$","span",null,{"className":"token punctuation","children":"}"}],"\n"]}],["$","span",null,{"className":"code-line","children":"\n"}],["$","span",null,{"className":"code-line","children":["\t",["$","span",null,{"className":"token comment","children":"// 实际分配代码被省略..."}],"\n"]}],["$","span",null,{"className":"code-line","children":[["$","span",null,{"className":"token punctuation","children":"}"}],"\n"]}]]}]}],["$","p",null,{"children":["在上面的代码中，",["$","code",null,{"className":"custom-code","children":"if assistG.gcAssistBytes < 0"}],"这行检查我们的goroutine是否有分配债务。分配债务是一种奇特的说法，意思是这个goroutine在GC周期期间分配的内存比它做GC工作的多。"]}],["$","p",null,{"children":["你可以把这想象成你的goroutine在GC周期期间分配时必须支付的税，除了这个税必须提前支付，然后才能实际进行分配。此外，税是与goroutine试图分配的数量成比例的。这提供了一定程度的",["$","em",null,{"children":"公平性"}],"，使得分配很多的goroutines为这些分配付出代价。"]}],["$","p",null,{"children":["因此,假设这是我们的goroutine在当前GC周期中第一次分配,它将被强制做GC assist工作。这里有趣的一行是对",["$","code",null,{"className":"custom-code","children":"gcAssistAlloc"}],"的调用。"]}],["$","p",null,{"children":["这个函数负责一些清理工作,最终调用",["$","code",null,{"className":"custom-code","children":"gcAssistAlloc1"}],"来执行实际的GC assist工作。我不会深入",["$","code",null,{"className":"custom-code","children":"gcAssistAlloc"}],"函数的细节,但本质上它做以下事情:"]}],["$","ol",null,{"children":[["$","li",null,{"children":"检查goroutine是否在做一些不可抢占的事情(即系统goroutine)"}],["$","li",null,{"children":"执行GC标记工作"}],["$","li",null,{"children":"检查goroutine是否仍有分配债务,否则返回"}]]}],["$","p",null,{"children":["现在应该清楚，任何运行并涉及",["$","strong",null,{"children":"分配"}],"的goroutine都将在",["$","strong",null,{"children":"GC周期期间"}],"承担",["$","strong",null,{"children":"GC Assist的惩罚"}],"。由于工作必须在分配之前完成，这将表现为goroutine原本打算做的实际有用工作的延迟或迟缓。"]}],["$","h4",null,{"className":"content-header","id":"api延迟的影响","children":[["$","a",null,{"href":"#api延迟的影响","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"API延迟的影响"]}],["$","p",null,{"children":"在我们的API前端中，这种机制意味着，当GC周期活跃时，goroutine的分配操作会因为辅助GC工作而导致响应延迟。随着服务器负载增加，内存分配的频率上升，这又会触发更多的GC周期（通常每秒高达10到20次）。更多的GC周期意味着更多的GC assist工作，从而使API响应时间增加。"}],["$","p",null,{"children":"通过执行跟踪，我们可以清楚地看到这一现象。下面是两个跟踪片段：一个在GC周期期间，另一个在非GC周期期间。"}],["$","div",null,{"className":"flex flex-col items-center justify-center text-center","children":["$","div",null,{"children":["$","$La",null,{"src":"/static/images/go/memory-ballast/picture5.webp","alt":"Maple","width":"1008","height":"688"}]}]}],["$","p",null,{"children":["跟踪显示了哪些goroutines在哪个处理器上运行。所有标记为",["$","code",null,{"className":"custom-code","children":"app-code"}],"的都是执行我们应用程序有用代码的goroutine(例如服务API请求的逻辑)。注意，除了四个专门执行GC代码的处理器外，我们的其他goroutines如何被延迟并被迫做",["$","code",null,{"className":"custom-code","children":"MARK ASSIST"}],"(即",["$","code",null,{"className":"custom-code","children":"runtime.gcAssistAlloc"}],")工作。"]}],["$","p",null,{"children":"将此与同一运行应用程序不在GC周期期间的这个配置文件进行比较。这里我们的goroutines大部分时间都在运行我们的应用程序代码，正如预期的那样："}],["$","div",null,{"className":"flex flex-col items-center justify-center text-center","children":["$","div",null,{"children":["$","$La",null,{"src":"/static/images/go/memory-ballast/picture6.webp","alt":"Maple","width":"913","height":"640"}]}]}],["$","p",null,{"children":["通过减少GC频率，我们显著减少了",["$","code",null,{"className":"custom-code","children":"MARK ASSIST"}],"的次数，几乎降低了99%。这直接改善了API的响应时间，特别是在高流量下，使得99百分位的延迟下降了约45%。"]}],["$","div",null,{"className":"flex flex-col items-center justify-center text-center","children":["$","div",null,{"children":["$","$La",null,{"src":"/static/images/go/memory-ballast/picture7.webp","alt":"Maple","width":"952","height":"593"}]}]}],["$","h3",null,{"className":"content-header","id":"为什么选择这种设计","children":[["$","a",null,{"href":"#为什么选择这种设计","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"为什么选择这种设计？"]}],["$","p",null,{"children":"你可能会好奇，为什么Go选择了这样一种通过GC assist来分摊内存分配负担的设计。实际上，这是为了在并发GC中有效管理堆的增长。在停止世界（STW）的GC中，控制堆增长相对简单，但在并发GC中，我们需要一种机制确保在GC周期期间发生的分配不会导致堆无限制增长。让goroutine为其分配的内存“缴税”，使得这种设计变得相当优雅，也更具公平性。"}],["$","h2",null,{"className":"content-header","id":"总结","children":[["$","a",null,{"href":"#总结","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"总结"]}],["$","ol",null,{"children":[["$","li",null,{"children":"我们发现应用程序在GC操作上花费了大量时间。"}],["$","li",null,{"children":["为此，我们引入了",["$","strong",null,{"children":"内存镇流器"}],"。"]}],["$","li",null,{"children":"通过允许堆增长得更大，内存镇流器减少了GC周期的频率。"}],["$","li",null,{"children":["这直接减少了Go GC中的",["$","strong",null,{"children":"assist"}],"延迟，从而改善了API的响应时间。"]}],["$","li",null,{"children":"由于镇流器仅消耗虚拟内存，因而其分配成本几乎可以忽略不计。"}],["$","li",null,{"children":["与调整",["$","code",null,{"className":"custom-code","children":"GOGC"}],"参数相比，使用镇流器更容易推理和管理。"]}],["$","li",null,{"children":"建议从较小的镇流器开始，并在测试过程中逐步调整。"}]]}],["$","h2",null,{"className":"content-header","id":"一些最后的思考","children":[["$","a",null,{"href":"#一些最后的思考","aria-hidden":"true","tabIndex":"-1","children":["$","span",null,{"className":"content-header-link","children":["$","svg",null,{"className":"h-5 linkicon w-5","fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg","children":[["$","path",null,{"d":"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"}],["$","path",null,{"d":"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"}]]}]}]}],"一些最后的思考"]}],["$","p",null,{"children":"Go在运行时细节上做了很好的抽象，这对大多数程序和开发者来说都是理想的。"}],["$","p",null,{"children":"然而，当你的应用接近性能瓶颈，不论是在计算、内存还是I/O方面时，深入研究其内部机制就变得至关重要。"}],["$","p",null,{"children":"在这些情况下，拥有一套强大的工具，如Go提供的调试与性能分析工具，能够帮助快速识别和解决瓶颈，这显然是非常有用的。"}]]}]}],["$","div",null,{"className":"pb-6 pt-6 text-center text-gray-700 dark:text-gray-300","id":"comment","children":["$","$L13",null,{"slug":"go/memory-ballast"}]}],["$","footer",null,{"children":["$","div",null,{"className":"flex flex-col text-sm font-medium sm:flex-row sm:justify-between sm:text-base","children":[["$","div",null,{"className":"pt-4 xl:pt-8","children":["$","$L9",null,{"href":"/blog/diary/2024-09-17","className":"text-primary-500 hover:text-primary-600 dark:hover:text-primary-400","aria-label":"Previous post: 领队随想","children":["← ","领队随想"]}]}],["$","div",null,{"className":"pt-4 xl:pt-8","children":["$","$L9",null,{"href":"/blog/tools/hack-email","className":"text-primary-500 hover:text-primary-600 dark:hover:text-primary-400","aria-label":"Next post: 获取非加密邮件协议中的用户名和密码——安全风险演示","children":["获取非加密邮件协议中的用户名和密码——安全风险演示"," →"]}]}]]}]}]]}]]}]}]]}]]
10:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Go语言的内存镇流器"}],["$","meta","3",{"name":"description","content":"我们通过引入内存镇流器减少了Go应用程序的垃圾回收（GC）周期频率，从而改善了API响应时间。这种做法允许堆在更大范围内增长，减少了GC辅助延迟，而镇流器的虚拟内存分配几乎不消耗实际RAM。相比调整GOGC值，使用镇流器更易于推理与管理。最后，深入分析性能瓶颈是提高应用效率的关键。"}],["$","meta","4",{"name":"robots","content":"index, follow"}],["$","meta","5",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","6",{"rel":"canonical","href":"https://blog.mainjay.cloudns.ch/blog/go/memory-ballast"}],["$","link","7",{"rel":"alternate","type":"application/rss+xml","href":"https://blog.mainjay.cloudns.ch/feed.xml"}],["$","meta","8",{"property":"og:title","content":"Go语言的内存镇流器"}],["$","meta","9",{"property":"og:description","content":"我们通过引入内存镇流器减少了Go应用程序的垃圾回收（GC）周期频率，从而改善了API响应时间。这种做法允许堆在更大范围内增长，减少了GC辅助延迟，而镇流器的虚拟内存分配几乎不消耗实际RAM。相比调整GOGC值，使用镇流器更易于推理与管理。最后，深入分析性能瓶颈是提高应用效率的关键。"}],["$","meta","10",{"property":"og:url","content":"https://blog.mainjay.cloudns.ch/blog/go/memory-ballast"}],["$","meta","11",{"property":"og:site_name","content":"MainJayLai Blog"}],["$","meta","12",{"property":"og:locale","content":"en_US"}],["$","meta","13",{"property":"og:image","content":"https://pngimg.com/uploads/github/github_PNG80.png"}],["$","meta","14",{"property":"og:type","content":"article"}],["$","meta","15",{"property":"article:published_time","content":"2024-10-17T00:00:00.000Z"}],["$","meta","16",{"property":"article:modified_time","content":"2024-10-17T00:00:00.000Z"}],["$","meta","17",{"property":"article:author","content":"mainJayLai"}],["$","meta","18",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","19",{"name":"twitter:title","content":"Go语言的内存镇流器"}],["$","meta","20",{"name":"twitter:description","content":"我们通过引入内存镇流器减少了Go应用程序的垃圾回收（GC）周期频率，从而改善了API响应时间。这种做法允许堆在更大范围内增长，减少了GC辅助延迟，而镇流器的虚拟内存分配几乎不消耗实际RAM。相比调整GOGC值，使用镇流器更易于推理与管理。最后，深入分析性能瓶颈是提高应用效率的关键。"}],["$","meta","21",{"name":"twitter:image","content":"https://pngimg.com/uploads/github/github_PNG80.png"}],["$","meta","22",{"name":"next-size-adjust"}]]
1:null

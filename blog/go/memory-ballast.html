<!DOCTYPE html><html lang="en-us" class="__variable_dd5b2f scroll-smooth"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/36966cca54120369-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/c890694439b2475b.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/1ea5cf861ee12a80.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/a9b9096fa657c0d0.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-8506c16620cf39fb.js"/><script src="/_next/static/chunks/fd9d1056-30760135124e6678.js" async=""></script><script src="/_next/static/chunks/23-44b8024386371b46.js" async=""></script><script src="/_next/static/chunks/main-app-06a10a1bb45617e8.js" async=""></script><script src="/_next/static/chunks/ebde5ed1-51545511fe0d5050.js" async=""></script><script src="/_next/static/chunks/231-34a6a67d2da26855.js" async=""></script><script src="/_next/static/chunks/827-69594f61c16b8a9c.js" async=""></script><script src="/_next/static/chunks/850-ecf153581cc02044.js" async=""></script><script src="/_next/static/chunks/app/layout-54bebb918ae7f176.js" async=""></script><script src="/_next/static/chunks/app/blog/%5B...slug%5D/page-bd056182432da53b.js" async=""></script><script src="https://us.umami.is/script.js" async=""></script><title>Go语言的内存镇流器</title><meta name="description" content="我们通过引入内存镇流器减少了Go应用程序的垃圾回收（GC）周期频率，从而改善了API响应时间。这种做法允许堆在更大范围内增长，减少了GC辅助延迟，而镇流器的虚拟内存分配几乎不消耗实际RAM。相比调整GOGC值，使用镇流器更易于推理与管理。最后，深入分析性能瓶颈是提高应用效率的关键。"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.mainjay.cloudns.ch/blog/go/memory-ballast"/><link rel="alternate" type="application/rss+xml" href="https://blog.mainjay.cloudns.ch/feed.xml"/><meta property="og:title" content="Go语言的内存镇流器"/><meta property="og:description" content="我们通过引入内存镇流器减少了Go应用程序的垃圾回收（GC）周期频率，从而改善了API响应时间。这种做法允许堆在更大范围内增长，减少了GC辅助延迟，而镇流器的虚拟内存分配几乎不消耗实际RAM。相比调整GOGC值，使用镇流器更易于推理与管理。最后，深入分析性能瓶颈是提高应用效率的关键。"/><meta property="og:url" content="https://blog.mainjay.cloudns.ch/blog/go/memory-ballast"/><meta property="og:site_name" content="MainJayLai Blog"/><meta property="og:locale" content="en_US"/><meta property="og:image" content="https://pngimg.com/uploads/github/github_PNG80.png"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2024-10-17T00:00:00.000Z"/><meta property="article:modified_time" content="2024-10-17T00:00:00.000Z"/><meta property="article:author" content="mainJayLai"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Go语言的内存镇流器"/><meta name="twitter:description" content="我们通过引入内存镇流器减少了Go应用程序的垃圾回收（GC）周期频率，从而改善了API响应时间。这种做法允许堆在更大范围内增长，减少了GC辅助延迟，而镇流器的虚拟内存分配几乎不消耗实际RAM。相比调整GOGC值，使用镇流器更易于推理与管理。最后，深入分析性能瓶颈是提高应用效率的关键。"/><meta name="twitter:image" content="https://pngimg.com/uploads/github/github_PNG80.png"/><meta name="next-size-adjust"/><link rel="icon" type="image/png" href="https://mainjaylai.github.io/favicon.png"/><link rel="manifest" href="/static/favicons/manifest.json"/><meta name="msapplication-TileColor" content="#000000"/><meta name="theme-color" media="(prefers-color-scheme: light)" content="#fff"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000"/><meta name="referrer" content="no-referrer"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@200..900&amp;display=swap" rel="stylesheet"/><link href="https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&amp;family=ZCOOL+QingKe+HuangYou&amp;family=ZCOOL+XiaoWei&amp;display=swap" rel="stylesheet"/><script src="https://cdn.jsdelivr.net/gh/ashishagarwal2023/freegptjs@1.0.2/src/freegpt.min.js"></script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="bg-white pl-[calc(100vw-100%)] text-black antialiased dark:bg-gray-950 dark:text-white"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&false)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}else{c.add('light')}if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'light'}catch(e){}}()</script><section class="mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0"><div class="flex h-screen flex-col justify-between font-sans"><header class="flex items-center justify-between py-5"><div><a aria-label="Blog" href="/"><div class="flex items-center justify-between"><div class="mr-3"><img alt="logo" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" style="color:transparent" src="https://mainjaylai.github.io/favicon.png"/></div><div class="hidden h-[44px] text-center text-3xl font-semibold leading-10 sm:block">Blog</div></div></a></div><div class="flex items-center space-x-4 leading-5 sm:space-x-6"><a class="navbar-item hidden font-medium text-gray-900 dark:text-gray-100 sm:block" href="/blog">Blog</a><a class="navbar-item hidden font-medium text-gray-900 dark:text-gray-100 sm:block" href="/tags">Tags</a><a target="_blank" rel="noopener noreferrer" href="https://mainjaylai.github.io" class="navbar-item hidden font-medium text-gray-900 dark:text-gray-100 sm:block">About</a><button aria-label="Search"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="h-6 w-6 text-gray-900 dark:text-gray-100"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"></path></svg></button><div class="mr-8"><div class="relative inline-block text-left" data-headlessui-state=""><div><button id="headlessui-menu-button-:R5pkqja:" type="button" aria-haspopup="menu" aria-expanded="false" data-headlessui-state=""><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="h-6 w-6 text-gray-900 dark:text-gray-100"><path fill-rule="evenodd" d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" clip-rule="evenodd"></path></svg></button></div></div></div><button aria-label="AI Chat" class="flex items-center justify-center rounded-full p-1.5 text-gray-800 transition-all hover:bg-gray-100 dark:text-gray-200 dark:hover:bg-gray-800"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path><path d="M8 9h8"></path><path d="M8 13h6"></path></svg></button><div class="mr-5"><div class="relative inline-block text-left" data-headlessui-state=""><div><button class="flex items-center" id="headlessui-menu-button-:R6pkqja:" type="button" aria-haspopup="menu" aria-expanded="false" data-headlessui-state=""><div class="mr-2">简体中文</div><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1616" width="15" height="15"><path d="M670.72 325.696L511.552 152l87.68-87.872 360.96 389.504L832 453.76v0.64H64V325.76h606.72z m-318.4 382.08l157.248 172.8-94.976 79.552L63.872 579.84l147.712-0.704v-0.128H960v128.768H352.32z" fill="#262626" p-id="1617"></path></svg></button></div></div></div><button aria-label="Toggle Menu" class="sm:hidden"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="h-8 w-8 text-gray-900 dark:text-gray-100"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg></button><div class="opacity-98 fixed left-0 top-0 z-10 h-full w-full transform bg-white duration-300 ease-in-out dark:bg-gray-950 dark:opacity-[0.98] translate-x-full"><div class="flex justify-end"><button class="mr-8 mt-8 h-8 w-8" aria-label="Toggle Menu"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="text-gray-900 dark:text-gray-100"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><nav class="fixed mt-8 h-full"><div class="px-12 py-4"><a class="text-2xl font-bold tracking-widest text-gray-900 opacity-80 dark:text-gray-100" href="/">Home</a></div><div class="px-12 py-4"><a class="text-2xl font-bold tracking-widest text-gray-900 opacity-80 dark:text-gray-100" href="/blog">Blog</a></div><div class="px-12 py-4"><a class="text-2xl font-bold tracking-widest text-gray-900 opacity-80 dark:text-gray-100" href="/tags">Tags</a></div><div class="px-12 py-4"><a target="_blank" rel="noopener noreferrer" href="https://mainjaylai.github.io" class="text-2xl font-bold tracking-widest text-gray-900 opacity-80 dark:text-gray-100">About</a></div></nav></div></div></header><main class="mb-auto"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go语言的内存镇流器","datePublished":"2024-10-17T00:00:00.000Z","dateModified":"2024-10-17T00:00:00.000Z","description":"我们通过引入内存镇流器减少了Go应用程序的垃圾回收（GC）周期频率，从而改善了API响应时间。这种做法允许堆在更大范围内增长，减少了GC辅助延迟，而镇流器的虚拟内存分配几乎不消耗实际RAM。相比调整GOGC值，使用镇流器更易于推理与管理。最后，深入分析性能瓶颈是提高应用效率的关键。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/go/memory-ballast","author":[{"@type":"Person","name":"mainJayLai"}]}</script><section class="mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0"><div class="fixed bottom-8 right-8 hidden flex-col gap-3 md:hidden"><button aria-label="Scroll To Comment" class="rounded-full bg-gray-200 p-2 text-gray-500 transition-all hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-400 dark:hover:bg-gray-600"><svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10c0 3.866-3.582 7-8 7a8.841 8.841 0 01-4.083-.98L2 17l1.338-3.123C2.493 12.767 2 11.434 2 10c0-3.866 3.582-7 8-7s8 3.134 8 7zM7 9H5v2h2V9zm8 0h-2v2h2V9zM9 9h2v2H9V9z" clip-rule="evenodd"></path></svg></button><button aria-label="Scroll To Top" class="rounded-full bg-gray-200 p-2 text-gray-500 transition-all hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-400 dark:hover:bg-gray-600"><svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg></button></div><article><div><header><div class="space-y-1 border-b border-gray-200 pb-10 text-center dark:border-gray-700"><div class="beautiful-chinese-title"><h1 class="text-3xl font-extrabold leading-9 tracking-tight text-gray-900 dark:text-gray-100 sm:text-4xl sm:leading-10 md:text-5xl md:leading-14">Go语言的内存镇流器</h1></div><dl><div><dt class="sr-only">Published on</dt><dd class="text-base font-medium leading-6 text-gray-500 dark:text-gray-400"><time dateTime="2024-10-17T00:00:00.000Z">October 17, 2024</time></dd></div></dl></div></header><div class="grid-rows-[auto_1fr] divide-y divide-gray-200 pb-8 dark:divide-gray-700 xl:divide-y-0"><div class="divide-y divide-gray-200 dark:divide-gray-700 xl:col-span-3 xl:row-span-2 xl:pb-0"><div class="beautiful-chinese-content prose max-w-none pb-8 pt-10 dark:prose-invert"><p><strong>“内存镇流器”</strong>（Memory Ballast）是一个形象的比喻，指的是一种优化Go程序内存使用的技术。就像船舶使用压舱物来增加稳定性一样，Go程序也可以通过预先分配一定量的内存来提升性能和稳定性，尤其是在应对突发流量时。</p><h2 class="content-header" id="背景介绍"><a href="#背景介绍" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>背景介绍</h2><p>在Twitch平台上，有一个名为Visage的服务，它作为API前端，是所有外部出站API流量的中央网关。Visage负责处理多项关键任务，包括授权、请求路由以及服务端的GraphQL处理。因此，它需要具备良好的扩展能力，以应对用户流量的波动，这些流量模式有时可能超出我们的控制。作为API网关，Visage在Twitch的后端服务与外部世界之间扮演着关键角色，它的性能直接影响到用户体验和平台的整体稳定性。</p><p>例如，大型互联网公司常常遇到一种被称为 <strong>“刷新风暴”</strong> 的流量模式。这种情况通常发生在一个受欢迎的主播因网络问题掉线时。主播重新开始直播后，观众会纷纷刷新他们的页面，导致服务器突然面临大量的API请求流量。</p><h2 class="content-header" id="挑战与应对"><a href="#挑战与应对" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>挑战与应对</h2><p>Visage是一个基于Go语言开发的应用（在此次优化中使用的是Go 1.11版本），运行在Amazon EC2实例上，并配有负载均衡器。尽管EC2结合自动扩展组的能力能够很好地进行水平扩展，但在应对突发的巨大流量时，依然存在挑战。</p><p>在“刷新风暴”期间，服务器需要在几秒钟内处理数百万个请求，流量激增可能是平时的20倍。工程师们发现，当前端服务器负载过高时，API的响应延迟会显著增加，从而影响用户体验。</p><p>一种简单的解决方案是始终保持高冗余的服务器容量，以应对这些突发情况，但这种做法非常浪费且成本高昂。为了减少这些持续上升的成本，工程师们决定探索能够提高单台服务器吞吐量，并在负载高峰时提供更稳定请求处理的优化方案。经过研究，他们找到了“内存镇流器”这一技术，以帮助改善内存管理和程序的整体性能。</p><h2 class="content-header" id="方案调研"><a href="#方案调研" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>方案调研</h2><p>在优化过程中，工程师们在生产环境中运行了 <code class="custom-code">pprof</code>，这使得获取真实生产流量下的性能分析变得非常容易。如果你还没有使用过 <code class="custom-code">pprof</code>，我强烈建议你开始使用它。大多数情况下，性能分析器对CPU的负载影响非常小。即使是执行跟踪器，尽管有一些开销，但影响微乎其微，可以在生产环境中每小时运行几秒钟，而不会对服务造成显著影响。</p><p>通过对Go应用的性能分析，我们得出以下观察结果：</p><ol><li>在稳定状态下，我们的应用每秒大约运行8-10次垃圾回收（GC）周期（每分钟400-600次）。</li><li>超过30%的CPU时间消耗在与GC相关的函数上，这一比例相当高，表明存在很大的优化空间。</li><li>在流量激增期间，GC周期数量进一步增加，这会加剧性能问题，导致应用响应时间变长。</li><li>我们的堆内存大小相对较小，这表明内存使用效率较高，但也可能导致频繁的GC触发。</li></ol><div class="flex flex-col items-center justify-center text-center"><div><img alt="GC Performance" loading="lazy" width="721" height="289" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/go/memory-ballast/picture1.webp"/></div></div><div class="flex flex-col items-center justify-center text-center"><div><img alt="Heap Usage Analysis" loading="lazy" width="516" height="250" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/go/memory-ballast/picture2.webp"/></div></div><p>我们此次改进的重点是优化应用程序的垃圾回收性能，以提升整体处理能力。</p><h2 class="content-header" id="什么是垃圾收集器gc"><a href="#什么是垃圾收集器gc" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>什么是垃圾收集器（GC）？</h2><p>在现代编程中，通常有两种方式来分配内存：栈（stack）和堆（heap）。大多数程序员在第一次写出导致栈溢出的递归程序时，就已经对栈有了初步的了解。而堆则是一个用于动态内存分配的区域，适用于那些生命周期无法在编译时确定的对象。</p><p>栈内存的分配优势在于其生命周期与所属函数绑定，因此，当函数返回时，栈上的内存会自动释放。而堆上的内存则不会在超出作用域时自动释放。为了防止堆内存无限增长，我们要么手动释放内存，要么依赖像Go这样的编程语言中的垃圾收集器（GC），来查找并清除不再被引用的对象。</p><p>通常情况下，在有GC机制的语言中，尽可能多地在栈上分配内存是有益的，因为这些内存分配不会被GC察觉。Go语言通过逃逸分析（escape analysis）来确定对象是应该分配在栈上还是堆上。</p><p>然而，在实际应用中，编写只在栈上分配内存的程序往往非常受限。因此，我们依赖Go的高效垃圾收集器来维护堆内存的清洁，确保程序的性能和稳定性。</p><h2 class="content-header" id="go的垃圾收集器"><a href="#go的垃圾收集器" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>Go的垃圾收集器</h2><p><em>垃圾收集器是复杂的软件组件。</em></p><p>从Go 1.5版本开始，Go引入了一个标记-清除（mark-and-sweep）垃圾收集器。顾名思义，这种GC机制包括两个主要阶段：<strong>标记</strong>和<strong>清除</strong>。与传统的“全程暂停应用程序”（Stop The World, STW）的垃圾回收不同，Go的GC在大多数情况下能够与应用程序代码并发运行，从而减少对程序执行的影响。</p><h3 class="content-header" id="标记和清除阶段"><a href="#标记和清除阶段" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>标记和清除阶段</h3><ol><li><p><strong>标记阶段</strong>：运行时会遍历堆中所有被应用程序引用的对象，并将这些对象标记为“仍在使用中”。这些对象被称为<strong>活动内存</strong>。标记阶段的任务是找出所有仍然有用的数据，以确保它们不会被错误地回收。</p></li><li><p><strong>清除阶段</strong>：在标记阶段完成后，所有未被标记的对象就会被认为是垃圾。清除阶段的任务是将这些未被引用的对象从堆中移除，释放出相应的内存。</p></li></ol><p>在整个GC周期中，虽然清除操作本质上是“STW”的，但由于现代操作系统在释放内存时的速度非常快，清除阶段所占用的时间通常较短。因此，标记阶段是影响GC时间的主要因素。</p><h3 class="content-header" id="关键术语"><a href="#关键术语" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>关键术语</h3><ul><li><strong>堆大小</strong>：包括堆中所有的内存分配，既包含当前被使用的，也包含已经成为垃圾的部分。</li><li><strong>活动内存</strong>：指正在被应用程序引用的内存分配，是当前有用的部分，不包括垃圾。</li></ul><h3 class="content-header" id="标记阶段与性能的关系"><a href="#标记阶段与性能的关系" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>标记阶段与性能的关系</h3><p>在标记阶段，运行时需要遍历应用程序当前引用的所有对象，因此标记所需的时间与活动内存的大小成正比，而与总堆大小无关。这意味着，即使堆中有大量的垃圾对象，也不会显著增加标记阶段所需的时间。因此，理论上讲，<strong>拥有更多垃圾对象并不会明显延长GC周期。</strong></p><p>然而，这种设计存在权衡。减少GC触发的频率，意味着垃圾清理的时间间隔变长，从而在内存中会积累更多的垃圾对象。这种权衡的结果就是：随着GC间隔的增加，系统内存消耗会变高。</p><h3 class="content-header" id="visage应用程序中的实际问题"><a href="#visage应用程序中的实际问题" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>Visage应用程序中的实际问题</h3><p>在Visage应用程序中，我们注意到它运行在专有的虚拟机上，拥有64GiB的物理内存，但即便如此，应用程序的GC非常频繁，而实际使用的物理内存仅约400MiB。这种现象表明GC频率过高，造成了CPU资源的浪费。要理解这种情况，我们需要深入了解Go如何在GC频率和内存使用之间进行权衡，这就涉及到Go垃圾收集的步调控制器（Pacer）。</p><h2 class="content-header" id="pacer步调控制器"><a href="#pacer步调控制器" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>Pacer（步调控制器）</h2><p>Go 的 GC 使用 <strong>步调控制器</strong> 来决定何时启动下一个 GC 周期。这被建模为一个控制问题，它试图找到正确的时机来触发 GC 周期，以达到目标堆大小。默认情况下，Go 的步调控制器会尝试在堆大小每次翻倍时启动一个 GC 周期。这是通过在当前 GC 周期的标记终止阶段设置下一个堆触发大小来实现的。因此，在标记完所有活动内存后，它可以决定在总堆大小是当前集合的 2 倍时运行下一次 GC。这个 2 倍值来自运行时使用的 <code class="custom-code">GOGC</code> 环境变量设置的触发器比率。</p><p>在我们的场景中，步调控制器有效地将堆上的垃圾保持在最小限度，但代价是引入了大量不必要的GC操作，因为应用程序仅使用了系统内存的约0.6%。</p><h3 class="content-header" id="引入内存镇流器ballast"><a href="#引入内存镇流器ballast" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>引入内存镇流器（Ballast）</h3><p>我们通过在应用程序启动时分配一个大型字节数组（例如10 GiB）来实现内存镇流器，这样做的目的是增加堆的稳定性：</p><div class="relative"><pre><code class="language-go code-highlight"><span class="code-line"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">	<span class="token comment">// 创建一个10 GiB的大型堆分配</span>
</span><span class="code-line">	ballast <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">&lt;&lt;</span><span class="token number">30</span><span class="token punctuation">)</span>
</span><span class="code-line">	<span class="token comment">// 继续执行应用程序</span>
</span><span class="code-line">	<span class="token comment">// ...</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre></div><h3 class="content-header" id="解释"><a href="#解释" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>解释</h3><h4 class="content-header" id="1-为什么使用内存镇流器"><a href="#1-为什么使用内存镇流器" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>1. 为什么使用内存镇流器？</h4><p>如前所述，GC 会在堆大小每次翻倍时触发。堆大小是堆上所有分配的总大小。因此，如果分配了 10GB 的镇流器，下一次 GC 只会在堆大小增长到 20GB 时触发。此时，大约会有 10GB 的镇流器 + 10GB 的其他分配。</p><p>当 GC 运行时，镇流器不会被当作垃圾清除，因为我们在 main 函数中仍然保持对它的引用，因此它被视为活动内存的一部分。由于我们应用程序中的大多数分配只在短暂的 API 请求生命周期内存在，10GB 分配中的大部分将被清除，将堆大小再次减小到略高于 ~10GB (即 10GB 镇流器加上所有正在进行的请求中被认为是活动内存的分配)。现在，下一个 GC 周期将在堆大小（当前略高于 10GB）再次翻倍时发生。</p><p>因此，镇流器增加了基本堆大小，使得我们的 GC 触发被延迟，随时间推移 GC 周期的数量减少。这个改变如预期那样起作用了 - 我们看到 GC 周期减少了约 99%：</p><div class="flex flex-col items-center justify-center text-center"><div><img alt="GC Reduction Graph" loading="lazy" width="1658" height="498" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/go/memory-ballast/picture3.webp"/></div></div><p>那么这看起来不错,CPU使用率呢?</p><div class="flex flex-col items-center justify-center text-center"><div><img alt="GC Reduction Graph" loading="lazy" width="1400" height="454" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/go/memory-ballast/picture4.webp"/></div></div><p>绿色的正弦波形CPU指标是由我们流量的每日波动引起的。可以看到改变后有一个明显的下降。</p><p>~30%的CPU减少意味着不用进一步观察，我们可以将波动减少30%，然而我们也关心API延迟——稍后会详细讨论这一点。</p><p>如前所述,Go运行时提供了一个<code class="custom-code">GOGC</code>环境变量，允许对GC步调控制器进行非常粗略的调整。这个值控制堆在运行GC之前的增长比例。我们决定不使用它，因为它有一些明显的缺点:</p><ul><li>比例本身对我们来说并不重要；我们使用的内存量才是。</li><li>我们必须将值设置得非常高才能获得与镇流器相同的效果，使得该值对活动堆大小的小变化很敏感。</li><li>推理活动内存及其变化率并不容易;而思考总使用内存则很简单。</li></ul><p><em>如果你想知道为什么我们使用字节数组作为镇流器,这保证我们只向标记阶段添加一个额外的对象。因为字节数组没有任何指针(除了对象本身),GC可以在O(1)时间内标记整个对象。</em></p><h4 class="content-header" id="2-这不会浪费10-gib的物理内存吗"><a href="#2-这不会浪费10-gib的物理内存吗" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>2. 这不会浪费10 GiB的物理内存吗？</h4><p>简短的回答是：不会，除非你在代码中访问这些内存。在Unix系统（包括Windows）中，内存是通过操作系统的页表进行映射的。尽管<code class="custom-code">make([]byte, 10&lt;&lt;30)</code>会在程序的虚拟地址空间中创建一个10 GiB的数组，但实际的物理内存只有在对该数组进行读写时才会被分配。只有当我们试图读取或写入切片时，才会发生页面错误，导致支持虚拟地址的物理 RAM 被分配。</p><p>可以通过以下简单程序进行验证：</p><div class="relative"><pre><code class="language-go code-highlight"><span class="code-line"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token boolean">_</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token operator">&lt;&lt;</span><span class="token number">20</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token operator">&lt;-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span>MaxInt64<span class="token punctuation">)</span><span class="token punctuation">)</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre></div><p>运行程序后使用<code class="custom-code">ps</code>查看内存分配：</p><div class="relative"><pre><code class="code-highlight language-shell"><span class="code-line">%MEM  COMMAND          PID    MAJFL  MINFL  RSS   VSZ
</span><span class="code-line"><span class="token number">0.2</span>   test_alloc       <span class="token number">27826</span>  <span class="token number">0</span>      <span class="token number">1003</span>   <span class="token number">4</span>.8M  108M
</span></code></pre></div><p>这表示进程的虚拟内存分配（VSZ）约为100 MiB，但实际占用的物理内存（RSS）仅为~5 MiB。</p><p>接下来，如果我们修改程序，让它写入一半的字节数组：</p><div class="relative"><pre><code class="language-go code-highlight"><span class="code-line"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">	ballast <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token operator">&lt;&lt;</span><span class="token number">20</span><span class="token punctuation">)</span>
</span><span class="code-line">	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>ballast<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
</span><span class="code-line">		ballast<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">byte</span><span class="token punctuation">(</span><span class="token char">&#x27;A&#x27;</span><span class="token punctuation">)</span>
</span><span class="code-line">	<span class="token punctuation">}</span>
</span><span class="code-line">	<span class="token operator">&lt;-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span>MaxInt64<span class="token punctuation">)</span><span class="token punctuation">)</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre></div><p>再次检查<code class="custom-code">ps</code>输出：</p><div class="relative"><pre><code class="code-highlight language-shell"><span class="code-line">%MEM  COMMAND          PID    MAJFL  MINFL  RSS   VSZ
</span><span class="code-line"><span class="token number">2.7</span>   test_alloc       <span class="token number">28331</span>  <span class="token number">0</span>      <span class="token number">1</span>.5K   57M   108M
</span></code></pre></div><p>正如预期的那样，现在字节数组的一半在 RSS 中，占用物理内存。VSZ 没有变化，因为在两个程序中都存在相同大小的虚拟分配。</p><p><em>对于那些感兴趣的人，MINFL 列是次要页面错误的数量 - 这是发生在进程中需要从内存加载页面的页面错误数量。如果 OS 成功地很好地连续分配了我们的物理内存，那么每个页面错误将能够映射多个 RAM 页面，减少发生的总页面错误数量。</em></p><p><strong>总结</strong>：</p><ol><li><strong>内存镇流器的优势</strong>：通过增加堆基准大小，内存镇流器减少了GC周期的频率，从而降低了CPU的使用率，提升了应用程序的整体性能。</li><li><strong>物理内存的利用</strong>：镇流器作为虚拟分配存在，只要不读写它，其内存开销几乎不会反映在实际的物理内存中。</li></ol><h2 class="content-header" id="api延迟"><a href="#api延迟" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>API延迟</h2><p>正如前面提到的，我们观察到减少GC频率后，API延迟得到了改善，尤其是在高负载期间。最初，我们猜测这是因为GC暂停时间减少了。然而，改变前后GC暂停时间的差异并不显著，而且暂停时间仅为单位数毫秒，而我们在峰值负载时观察到的延迟却达到100毫秒级。</p><p>要更好地理解延迟改善的原因，我们需要探讨Go GC中的一个重要特性——<strong>GC assists</strong>。</p><h3 class="content-header" id="gc-assists"><a href="#gc-assists" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>GC assists</h3><p>GC assists机制会在<strong>GC周期期间</strong>将部分内存分配工作转移到正在执行分配操作的goroutine上。没有这种机制，Go运行时就无法在GC周期期间控制堆的增长。</p><p>Go已经有一个后台GC工作线程，而__“assists”__意味着用户的goroutine会帮助后台GC线程进行特定的工作，尤其是标记阶段的工作。</p><p>为了更好地理解这一点，让我们看一个例子:</p><div class="relative"><pre><code class="language-go code-highlight"><span class="code-line">someObject <span class="token operator">:=</span>  <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
</span></code></pre></div><p>当这段代码执行时，goroutine通过一系列符号转换和类型检查，最终调用<code class="custom-code">runtime.mallocgc</code>来为切片分配内存。<code class="custom-code">runtime.mallocgc</code>内部包含一些有趣的逻辑：</p><div class="relative"><pre><code class="language-go code-highlight"><span class="code-line"><span class="token comment">// 分配指定大小的对象。</span>
</span><span class="code-line"><span class="token keyword">func</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span>size <span class="token builtin">uintptr</span><span class="token punctuation">,</span> typ <span class="token operator">*</span>_type<span class="token punctuation">,</span> needzero <span class="token builtin">bool</span><span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">{</span>
</span><span class="code-line">
</span><span class="code-line">  	<span class="token comment">// 一些错误检查和调试代码被省略...</span>
</span><span class="code-line">
</span><span class="code-line">	<span class="token comment">// assistG是用于此分配的G（goroutine），如果GC未激活则为nil。</span>
</span><span class="code-line">	<span class="token keyword">var</span> assistG <span class="token operator">*</span>g
</span><span class="code-line">	<span class="token keyword">if</span> gcBlackenEnabled <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
</span><span class="code-line">		assistG <span class="token operator">=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</span><span class="code-line">		<span class="token comment">// 对当前的goroutine进行“收费”。</span>
</span><span class="code-line">		assistG<span class="token punctuation">.</span>gcAssistBytes <span class="token operator">-=</span> <span class="token function">int64</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span>
</span><span class="code-line">
</span><span class="code-line">		<span class="token keyword">if</span> assistG<span class="token punctuation">.</span>gcAssistBytes <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
</span><span class="code-line">			<span class="token comment">// 当goroutine有分配债务时，调用gcAssistAlloc进行GC工作。</span>
</span><span class="code-line">			<span class="token function">gcAssistAlloc</span><span class="token punctuation">(</span>assistG<span class="token punctuation">)</span>
</span><span class="code-line">		<span class="token punctuation">}</span>
</span><span class="code-line">	<span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">	<span class="token comment">// 实际分配代码被省略...</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre></div><p>在上面的代码中，<code class="custom-code">if assistG.gcAssistBytes &lt; 0</code>这行检查我们的goroutine是否有分配债务。分配债务是一种奇特的说法，意思是这个goroutine在GC周期期间分配的内存比它做GC工作的多。</p><p>你可以把这想象成你的goroutine在GC周期期间分配时必须支付的税，除了这个税必须提前支付，然后才能实际进行分配。此外，税是与goroutine试图分配的数量成比例的。这提供了一定程度的<em>公平性</em>，使得分配很多的goroutines为这些分配付出代价。</p><p>因此,假设这是我们的goroutine在当前GC周期中第一次分配,它将被强制做GC assist工作。这里有趣的一行是对<code class="custom-code">gcAssistAlloc</code>的调用。</p><p>这个函数负责一些清理工作,最终调用<code class="custom-code">gcAssistAlloc1</code>来执行实际的GC assist工作。我不会深入<code class="custom-code">gcAssistAlloc</code>函数的细节,但本质上它做以下事情:</p><ol><li>检查goroutine是否在做一些不可抢占的事情(即系统goroutine)</li><li>执行GC标记工作</li><li>检查goroutine是否仍有分配债务,否则返回</li></ol><p>现在应该清楚，任何运行并涉及<strong>分配</strong>的goroutine都将在<strong>GC周期期间</strong>承担<strong>GC Assist的惩罚</strong>。由于工作必须在分配之前完成，这将表现为goroutine原本打算做的实际有用工作的延迟或迟缓。</p><h4 class="content-header" id="api延迟的影响"><a href="#api延迟的影响" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>API延迟的影响</h4><p>在我们的API前端中，这种机制意味着，当GC周期活跃时，goroutine的分配操作会因为辅助GC工作而导致响应延迟。随着服务器负载增加，内存分配的频率上升，这又会触发更多的GC周期（通常每秒高达10到20次）。更多的GC周期意味着更多的GC assist工作，从而使API响应时间增加。</p><p>通过执行跟踪，我们可以清楚地看到这一现象。下面是两个跟踪片段：一个在GC周期期间，另一个在非GC周期期间。</p><div class="flex flex-col items-center justify-center text-center"><div><img alt="Maple" loading="lazy" width="1008" height="688" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/go/memory-ballast/picture5.webp"/></div></div><p>跟踪显示了哪些goroutines在哪个处理器上运行。所有标记为<code class="custom-code">app-code</code>的都是执行我们应用程序有用代码的goroutine(例如服务API请求的逻辑)。注意，除了四个专门执行GC代码的处理器外，我们的其他goroutines如何被延迟并被迫做<code class="custom-code">MARK ASSIST</code>(即<code class="custom-code">runtime.gcAssistAlloc</code>)工作。</p><p>将此与同一运行应用程序不在GC周期期间的这个配置文件进行比较。这里我们的goroutines大部分时间都在运行我们的应用程序代码，正如预期的那样：</p><div class="flex flex-col items-center justify-center text-center"><div><img alt="Maple" loading="lazy" width="913" height="640" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/go/memory-ballast/picture6.webp"/></div></div><p>通过减少GC频率，我们显著减少了<code class="custom-code">MARK ASSIST</code>的次数，几乎降低了99%。这直接改善了API的响应时间，特别是在高流量下，使得99百分位的延迟下降了约45%。</p><div class="flex flex-col items-center justify-center text-center"><div><img alt="Maple" loading="lazy" width="952" height="593" decoding="async" data-nimg="1" style="color:transparent" src="/static/images/go/memory-ballast/picture7.webp"/></div></div><h3 class="content-header" id="为什么选择这种设计"><a href="#为什么选择这种设计" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>为什么选择这种设计？</h3><p>你可能会好奇，为什么Go选择了这样一种通过GC assist来分摊内存分配负担的设计。实际上，这是为了在并发GC中有效管理堆的增长。在停止世界（STW）的GC中，控制堆增长相对简单，但在并发GC中，我们需要一种机制确保在GC周期期间发生的分配不会导致堆无限制增长。让goroutine为其分配的内存“缴税”，使得这种设计变得相当优雅，也更具公平性。</p><h2 class="content-header" id="总结"><a href="#总结" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>总结</h2><ol><li>我们发现应用程序在GC操作上花费了大量时间。</li><li>为此，我们引入了<strong>内存镇流器</strong>。</li><li>通过允许堆增长得更大，内存镇流器减少了GC周期的频率。</li><li>这直接减少了Go GC中的<strong>assist</strong>延迟，从而改善了API的响应时间。</li><li>由于镇流器仅消耗虚拟内存，因而其分配成本几乎可以忽略不计。</li><li>与调整<code class="custom-code">GOGC</code>参数相比，使用镇流器更容易推理和管理。</li><li>建议从较小的镇流器开始，并在测试过程中逐步调整。</li></ol><h2 class="content-header" id="一些最后的思考"><a href="#一些最后的思考" aria-hidden="true" tabindex="-1"><span class="content-header-link"><svg class="h-5 linkicon w-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z"></path><path d="M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z"></path></svg></span></a>一些最后的思考</h2><p>Go在运行时细节上做了很好的抽象，这对大多数程序和开发者来说都是理想的。</p><p>然而，当你的应用接近性能瓶颈，不论是在计算、内存还是I/O方面时，深入研究其内部机制就变得至关重要。</p><p>在这些情况下，拥有一套强大的工具，如Go提供的调试与性能分析工具，能够帮助快速识别和解决瓶颈，这显然是非常有用的。</p></div></div><div class="pb-6 pt-6 text-center text-gray-700 dark:text-gray-300" id="comment"></div><footer><div class="flex flex-col text-sm font-medium sm:flex-row sm:justify-between sm:text-base"><div class="pt-4 xl:pt-8"><a class="text-primary-500 hover:text-primary-600 dark:hover:text-primary-400" aria-label="Previous post: 领队随想" href="/blog/diary/2024-09-17">← <!-- -->领队随想</a></div><div class="pt-4 xl:pt-8"><a class="text-primary-500 hover:text-primary-600 dark:hover:text-primary-400" aria-label="Next post: 获取非加密邮件协议中的用户名和密码——安全风险演示" href="/blog/tools/hack-email">获取非加密邮件协议中的用户名和密码——安全风险演示<!-- --> →</a></div></div></footer></div></div></article></section></main><footer><div class="mt-16 flex flex-col items-center"><div class="mb-3 flex space-x-4"><a class="text-sm !text-gray-500 transition hover:text-gray-600" target="_blank" rel="noopener noreferrer" href="mailto:mainjaylai@outlook.com"><span class="sr-only">mail</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" class="fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6"><path d="M2.003 5.884L10 9.882l7.997-3.998A2 2 0 0016 4H4a2 2 0 00-1.997 1.884z"></path><path d="M18 8.118l-8 4-8-4V14a2 2 0 002 2h12a2 2 0 002-2V8.118z"></path></svg></a><a class="text-sm !text-gray-500 transition hover:text-gray-600" target="_blank" rel="noopener noreferrer" href="https://github.com/mainjaylai"><span class="sr-only">github</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6"><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg></a><a class="text-sm !text-gray-500 transition hover:text-gray-600" target="_blank" rel="noopener noreferrer" href="https://gitlab.com/JayMain"><span class="sr-only">gitlab</span><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6" width="200" height="200"><path d="M1022.08 579.712l-57.258667-176.426667-113.664-349.397333a19.413333 19.413333 0 0 0-36.992 0L700.501333 403.2H323.498667L209.877333 53.888C204.074667 35.84 178.56 35.84 172.8 53.76L59.136 403.157333 1.877333 579.712a39.424 39.424 0 0 0 14.122667 43.648L512 983.637333l496-360.234666a39.253333 39.253333 0 0 0 14.08-43.690667"></path></svg></a><a class="text-sm !text-gray-500 transition hover:text-gray-600" target="_blank" rel="noopener noreferrer" href="https://gitee.com/lmj2001"><span class="sr-only">gitee</span><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6" width="200" height="200"><path d="M512 992C246.895625 992 32 777.104375 32 512S246.895625 32 512 32s480 214.895625 480 480-214.895625 480-480 480z m242.9521875-533.3278125h-272.56875a23.7121875 23.7121875 0 0 0-23.71125 23.7121875l-0.024375 59.255625c0 13.08 10.6078125 23.7121875 23.6878125 23.7121875h165.96c13.104375 0 23.7121875 10.6078125 23.7121875 23.6878125v11.855625a71.1121875 71.1121875 0 0 1-71.1121875 71.1121875h-225.215625a23.7121875 23.7121875 0 0 1-23.6878125-23.7121875V423.1278125a71.1121875 71.1121875 0 0 1 71.0878125-71.1121875h331.824375a23.7121875 23.7121875 0 0 0 23.6878125-23.71125l0.0721875-59.2565625a23.7121875 23.7121875 0 0 0-23.68875-23.7121875H423.08a177.76875 177.76875 0 0 0-177.76875 177.7921875V754.953125c0 13.1034375 10.60875 23.7121875 23.713125 23.7121875h349.63125a159.984375 159.984375 0 0 0 159.984375-159.984375V482.36a23.7121875 23.7121875 0 0 0-23.7121875-23.6878125z"></path></svg></a></div><div class="mb-2 flex space-x-2 text-sm text-gray-500 dark:text-gray-400"><div>MainJayLai</div><div> • </div><div>© 2025</div><div> • </div><a href="/">MainJayLai Blog</a></div></div></footer></div></section><script src="/_next/static/chunks/webpack-8506c16620cf39fb.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/36966cca54120369-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/c890694439b2475b.css\",\"style\"]\n3:HL[\"/_next/static/css/1ea5cf861ee12a80.css\",\"style\"]\n4:HL[\"/_next/static/css/a9b9096fa657c0d0.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"5:I[5751,[],\"\"]\n8:I[9275,[],\"\"]\na:I[1343,[],\"\"]\nb:I[8700,[\"599\",\"static/chunks/ebde5ed1-51545511fe0d5050.js\",\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"850\",\"static/chunks/850-ecf153581cc02044.js\",\"185\",\"static/chunks/app/layout-54bebb918ae7f176.js\"],\"ThemeProviders\"]\nc:I[4080,[\"599\",\"static/chunks/ebde5ed1-51545511fe0d5050.js\",\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"850\",\"static/chunks/850-ecf153581cc02044.js\",\"185\",\"static/chunks/app/layout-54bebb918ae7f176.js\"],\"\"]\nd:I[9032,[\"599\",\"static/chunks/ebde5ed1-51545511fe0d5050.js\",\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"850\",\"static/chunks/850-ecf153581cc02044.js\",\"185\",\"static/chunks/app/layout-54bebb918ae7f176.js\"],\"KBarSearchProvider\"]\ne:I[231,[\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"797\",\"static/chunks/app/blog/%5B...slug%5D/page-bd056182432da53b.js\"],\"\"]\nf:I[8173,[\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"797\",\"static/chunks/app/blog/%5B...slug%5D/page-bd056182432da53b.js\"],\"Image\"]\n10:I[509,[\"599\",\"static/chunks/ebde5ed1-51545511fe0d5050.js\",\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"850\",\"static/chunks/850-ecf153581cc02044.js\",\"185\",\"static/chunks/app/layout-54bebb918ae7f176.js\"],\"KBarButton\"]\n11:I[1398,[\"599\",\"static/chunks/ebde5ed1-51545511fe0d5050.js\",\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"850\",\"static/chunks/850-ecf153581cc02044.js\",\"185\",\"static/chunks/app/layout-54bebb918ae7f176.js\"],\"default\"]\n12:I[7606,[\"599\",\"static/chunks/ebde5ed1-51545511fe0d5050.js\",\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"850\",\"static/chunks/850-ecf153581cc02044.js\",\"185\",\"static/chunks/app/layout-54bebb918ae7f176.js\"],\"default\"]\n13:I[7510,[\"599\",\"static/chunks/ebde5ed1-5"])</script><script>self.__next_f.push([1,"1545511fe0d5050.js\",\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"850\",\"static/chunks/850-ecf153581cc02044.js\",\"185\",\"static/chunks/app/layout-54bebb918ae7f176.js\"],\"default\"]\n14:I[8976,[\"599\",\"static/chunks/ebde5ed1-51545511fe0d5050.js\",\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"850\",\"static/chunks/850-ecf153581cc02044.js\",\"185\",\"static/chunks/app/layout-54bebb918ae7f176.js\"],\"default\"]\n16:I[6130,[],\"\"]\n9:[\"slug\",\"go/memory-ballast\",\"c\"]\n17:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/c890694439b2475b.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/1ea5cf861ee12a80.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L5\",null,{\"buildId\":\"AO1lBacSEqBfLSl9iFzzQ\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/blog/go/memory-ballast\",\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"go/memory-ballast\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"go\\\",\\\"memory-ballast\\\"]}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"go/memory-ballast\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L6\",\"$L7\"],null],null]},[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"$9\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/a9b9096fa657c0d0.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]]}],null]},[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"en-us\",\"className\":\"__variable_dd5b2f scroll-smooth\",\"suppressHydrationWarning\":true,\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"href\":\"https://mainjaylai.github.io/favicon.png\"}],[\"$\",\"link\",null,{\"rel\":\"manifest\",\"href\":\"/static/favicons/manifest.json\"}],[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#000000\"}],[\"$\",\"link\",null,{\"href\":\"https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@200..900\u0026display=swap\",\"rel\":\"stylesheet\"}],[\"$\",\"link\",null,{\"href\":\"https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe\u0026family=ZCOOL+QingKe+HuangYou\u0026family=ZCOOL+XiaoWei\u0026display=swap\",\"rel\":\"stylesheet\"}],[\"$\",\"script\",null,{\"src\":\"https://us.umami.is/script.js\",\"async\":true}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"media\":\"(prefers-color-scheme: light)\",\"content\":\"#fff\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"media\":\"(prefers-color-scheme: dark)\",\"content\":\"#000\"}],[\"$\",\"meta\",null,{\"name\":\"referrer\",\"content\":\"no-referrer\"}],[\"$\",\"script\",null,{\"src\":\"https://cdn.jsdelivr.net/gh/ashishagarwal2023/freegptjs@1.0.2/src/freegpt.min.js\"}],[\"$\",\"link\",null,{\"rel\":\"alternate\",\"type\":\"application/rss+xml\",\"href\":\"/feed.xml\"}]]}],[\"$\",\"body\",null,{\"className\":\"bg-white pl-[calc(100vw-100%)] text-black antialiased dark:bg-gray-950 dark:text-white\",\"suppressHydrationWarning\":true,\"children\":[\"$\",\"$Lb\",null,{\"children\":[[\"$undefined\",\"$undefined\",\"$undefined\",[\"$\",\"$Lc\",null,{\"async\":true,\"defer\":true,\"data-website-id\":\"bbe21cb3-3de3-4ba7-b6de-453053bc6ae8\",\"src\":\"https://us.umami.is/script.js\"}],\"$undefined\",\"$undefined\"],[\"$\",\"section\",null,{\"className\":\"mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex h-screen flex-col justify-between font-sans\",\"children\":[[\"$\",\"$Ld\",null,{\"kbarConfig\":{\"searchDocumentsPath\":\"/search.json\"},\"children\":[[\"$\",\"header\",null,{\"className\":\"flex items-center justify-between py-5\",\"children\":[[\"$\",\"div\",null,{\"children\":[\"$\",\"$Le\",null,{\"href\":\"/\",\"aria-label\":\"Blog\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex items-center justify-between\",\"children\":[[\"$\",\"div\",null,{\"className\":\"mr-3\",\"children\":[\"$\",\"$Lf\",null,{\"src\":\"https://mainjaylai.github.io/favicon.png\",\"width\":44,\"height\":44,\"alt\":\"logo\"}]}],[\"$\",\"div\",null,{\"className\":\"hidden h-[44px] text-center text-3xl font-semibold leading-10 sm:block\",\"children\":\"Blog\"}]]}]}]}],[\"$\",\"div\",null,{\"className\":\"flex items-center space-x-4 leading-5 sm:space-x-6\",\"children\":[[[\"$\",\"$Le\",null,{\"href\":\"/blog\",\"className\":\"navbar-item hidden font-medium text-gray-900 dark:text-gray-100 sm:block\",\"children\":\"Blog\"}],[\"$\",\"$Le\",null,{\"href\":\"/tags\",\"className\":\"navbar-item hidden font-medium text-gray-900 dark:text-gray-100 sm:block\",\"children\":\"Tags\"}],[\"$\",\"a\",null,{\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"href\":\"https://mainjaylai.github.io\",\"className\":\"navbar-item hidden font-medium text-gray-900 dark:text-gray-100 sm:block\",\"children\":\"About\"}]],[\"$\",\"$L10\",null,{\"aria-label\":\"Search\",\"children\":[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"fill\":\"none\",\"viewBox\":\"0 0 24 24\",\"strokeWidth\":1.5,\"stroke\":\"currentColor\",\"className\":\"h-6 w-6 text-gray-900 dark:text-gray-100\",\"children\":[\"$\",\"path\",null,{\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"d\":\"M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z\"}]}]}],[\"$\",\"$L11\",null,{}],[\"$\",\"$L12\",null,{}],[\"$\",\"$L13\",null,{}],[\"$\",\"$L14\",null,{}]]}]]}],[\"$\",\"main\",null,{\"className\":\"mb-auto\",\"children\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"flex flex-col items-start justify-start md:mt-24 md:flex-row md:items-center md:justify-center md:space-x-6\",\"children\":[[\"$\",\"div\",null,{\"className\":\"space-x-2 pb-8 pt-6 md:space-y-5\",\"children\":[\"$\",\"h1\",null,{\"className\":\"text-6xl font-extrabold leading-9 tracking-tight text-gray-900 dark:text-gray-100 md:border-r-2 md:px-6 md:text-8xl md:leading-14\",\"children\":\"404\"}]}],[\"$\",\"div\",null,{\"className\":\"max-w-md\",\"children\":[[\"$\",\"p\",null,{\"className\":\"mb-4 text-xl font-bold leading-normal md:text-2xl\",\"children\":\"Sorry we couldn't find this page.\"}],[\"$\",\"p\",null,{\"className\":\"mb-8\",\"children\":\"But dont worry, you can find plenty of other things on our homepage.\"}],[\"$\",\"$Le\",null,{\"href\":\"/\",\"className\":\"focus:shadow-outline-blue inline rounded-lg border border-transparent bg-blue-600 px-4 py-2 text-sm font-medium leading-5 text-white shadow transition-colors duration-150 hover:bg-blue-700 focus:outline-none dark:hover:bg-blue-500\",\"children\":\"Back to homepage\"}]]}]]}],\"notFoundStyles\":[],\"styles\":null}]}]]}],[\"$\",\"footer\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"mt-16 flex flex-col items-center\",\"children\":[[\"$\",\"div\",null,{\"className\":\"mb-3 flex space-x-4\",\"children\":[[\"$\",\"a\",null,{\"className\":\"text-sm !text-gray-500 transition hover:text-gray-600\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"href\":\"mailto:mainjaylai@outlook.com\",\"children\":[[\"$\",\"span\",null,{\"className\":\"sr-only\",\"children\":\"mail\"}],[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"viewBox\":\"0 0 20 20\",\"className\":\"fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M2.003 5.884L10 9.882l7.997-3.998A2 2 0 0016 4H4a2 2 0 00-1.997 1.884z\"}],[\"$\",\"path\",null,{\"d\":\"M18 8.118l-8 4-8-4V14a2 2 0 002 2h12a2 2 0 002-2V8.118z\"}]]}]]}],[\"$\",\"a\",null,{\"className\":\"text-sm !text-gray-500 transition hover:text-gray-600\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"href\":\"https://github.com/mainjaylai\",\"children\":[[\"$\",\"span\",null,{\"className\":\"sr-only\",\"children\":\"github\"}],[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"viewBox\":\"0 0 24 24\",\"className\":\"fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6\",\"children\":[\"$\",\"path\",null,{\"d\":\"M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12\"}]}]]}],[\"$\",\"a\",null,{\"className\":\"text-sm !text-gray-500 transition hover:text-gray-600\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"href\":\"https://gitlab.com/JayMain\",\"children\":[[\"$\",\"span\",null,{\"className\":\"sr-only\",\"children\":\"gitlab\"}],[\"$\",\"svg\",null,{\"viewBox\":\"0 0 1024 1024\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"className\":\"fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6\",\"width\":\"200\",\"height\":\"200\",\"children\":[\"$\",\"path\",null,{\"d\":\"M1022.08 579.712l-57.258667-176.426667-113.664-349.397333a19.413333 19.413333 0 0 0-36.992 0L700.501333 403.2H323.498667L209.877333 53.888C204.074667 35.84 178.56 35.84 172.8 53.76L59.136 403.157333 1.877333 579.712a39.424 39.424 0 0 0 14.122667 43.648L512 983.637333l496-360.234666a39.253333 39.253333 0 0 0 14.08-43.690667\"}]}]]}],[\"$\",\"a\",null,{\"className\":\"text-sm !text-gray-500 transition hover:text-gray-600\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"href\":\"https://gitee.com/lmj2001\",\"children\":[[\"$\",\"span\",null,{\"className\":\"sr-only\",\"children\":\"gitee\"}],[\"$\",\"svg\",null,{\"viewBox\":\"0 0 1024 1024\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"className\":\"fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6\",\"width\":\"200\",\"height\":\"200\",\"children\":[\"$\",\"path\",null,{\"d\":\"M512 992C246.895625 992 32 777.104375 32 512S246.895625 32 512 32s480 214.895625 480 480-214.895625 480-480 480z m242.9521875-533.3278125h-272.56875a23.7121875 23.7121875 0 0 0-23.71125 23.7121875l-0.024375 59.255625c0 13.08 10.6078125 23.7121875 23.6878125 23.7121875h165.96c13.104375 0 23.7121875 10.6078125 23.7121875 23.6878125v11.855625a71.1121875 71.1121875 0 0 1-71.1121875 71.1121875h-225.215625a23.7121875 23.7121875 0 0 1-23.6878125-23.7121875V423.1278125a71.1121875 71.1121875 0 0 1 71.0878125-71.1121875h331.824375a23.7121875 23.7121875 0 0 0 23.6878125-23.71125l0.0721875-59.2565625a23.7121875 23.7121875 0 0 0-23.68875-23.7121875H423.08a177.76875 177.76875 0 0 0-177.76875 177.7921875V754.953125c0 13.1034375 10.60875 23.7121875 23.713125 23.7121875h349.63125a159.984375 159.984375 0 0 0 159.984375-159.984375V482.36a23.7121875 23.7121875 0 0 0-23.7121875-23.6878125z\"}]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"mb-2 flex space-x-2 text-sm text-gray-500 dark:text-gray-400\",\"children\":[[\"$\",\"div\",null,{\"children\":\"MainJayLai\"}],[\"$\",\"div\",null,{\"children\":\" • \"}],[\"$\",\"div\",null,{\"children\":\"© 2025\"}],[\"$\",\"div\",null,{\"children\":\" • \"}],[\"$\",\"$Le\",null,{\"href\":\"/\",\"children\":\"MainJayLai Blog\"}]]}]]}]}]]}]}]]}]}]]}],null],null],\"couldBeIntercepted\":false,\"initialHead\":[false,\"$L15\"],\"globalErrorComponent\":\"$16\",\"missingSlots\":\"$W17\"}]]\n"])</script><script>self.__next_f.push([1,"18:I[4347,[\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"797\",\"static/chunks/app/blog/%5B...slug%5D/page-bd056182432da53b.js\"],\"default\"]\n19:I[408,[\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"797\",\"static/chunks/app/blog/%5B...slug%5D/page-bd056182432da53b.js\"],\"default\"]\n1a:I[9629,[\"231\",\"static/chunks/231-34a6a67d2da26855.js\",\"827\",\"static/chunks/827-69594f61c16b8a9c.js\",\"797\",\"static/chunks/app/blog/%5B...slug%5D/page-bd056182432da53b.js\"],\"default\"]\n"])</script><script>self.__next_f.push([1,"7:[[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"BlogPosting\\\",\\\"headline\\\":\\\"Go语言的内存镇流器\\\",\\\"datePublished\\\":\\\"2024-10-17T00:00:00.000Z\\\",\\\"dateModified\\\":\\\"2024-10-17T00:00:00.000Z\\\",\\\"description\\\":\\\"我们通过引入内存镇流器减少了Go应用程序的垃圾回收（GC）周期频率，从而改善了API响应时间。这种做法允许堆在更大范围内增长，减少了GC辅助延迟，而镇流器的虚拟内存分配几乎不消耗实际RAM。相比调整GOGC值，使用镇流器更易于推理与管理。最后，深入分析性能瓶颈是提高应用效率的关键。\\\",\\\"image\\\":\\\"https://pngimg.com/uploads/github/github_PNG80.png\\\",\\\"url\\\":\\\"https://blog.mainjay.cloudns.ch/blog/go/memory-ballast\\\",\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"mainJayLai\\\"}]}\"}}],[\"$\",\"section\",null,{\"className\":\"mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0\",\"children\":[[\"$\",\"$L18\",null,{}],[\"$\",\"article\",null,{\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"header\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"space-y-1 border-b border-gray-200 pb-10 text-center dark:border-gray-700\",\"children\":[[\"$\",\"div\",null,{\"className\":\"beautiful-chinese-title\",\"children\":[\"$\",\"h1\",null,{\"className\":\"text-3xl font-extrabold leading-9 tracking-tight text-gray-900 dark:text-gray-100 sm:text-4xl sm:leading-10 md:text-5xl md:leading-14\",\"children\":\"Go语言的内存镇流器\"}]}],[\"$\",\"dl\",null,{\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"dt\",null,{\"className\":\"sr-only\",\"children\":\"Published on\"}],[\"$\",\"dd\",null,{\"className\":\"text-base font-medium leading-6 text-gray-500 dark:text-gray-400\",\"children\":[\"$\",\"time\",null,{\"dateTime\":\"2024-10-17T00:00:00.000Z\",\"children\":\"October 17, 2024\"}]}]]}]}]]}]}],[\"$\",\"div\",null,{\"className\":\"grid-rows-[auto_1fr] divide-y divide-gray-200 pb-8 dark:divide-gray-700 xl:divide-y-0\",\"children\":[[\"$\",\"div\",null,{\"className\":\"divide-y divide-gray-200 dark:divide-gray-700 xl:col-span-3 xl:row-span-2 xl:pb-0\",\"children\":[\"$\",\"div\",null,{\"className\":\"beautiful-chinese-content prose max-w-none pb-8 pt-10 dark:prose-invert\",\"children\":[[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"“内存镇流器”\"}],\"（Memory Ballast）是一个形象的比喻，指的是一种优化Go程序内存使用的技术。就像船舶使用压舱物来增加稳定性一样，Go程序也可以通过预先分配一定量的内存来提升性能和稳定性，尤其是在应对突发流量时。\"]}],[\"$\",\"h2\",null,{\"className\":\"content-header\",\"id\":\"背景介绍\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#背景介绍\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"背景介绍\"]}],[\"$\",\"p\",null,{\"children\":\"在Twitch平台上，有一个名为Visage的服务，它作为API前端，是所有外部出站API流量的中央网关。Visage负责处理多项关键任务，包括授权、请求路由以及服务端的GraphQL处理。因此，它需要具备良好的扩展能力，以应对用户流量的波动，这些流量模式有时可能超出我们的控制。作为API网关，Visage在Twitch的后端服务与外部世界之间扮演着关键角色，它的性能直接影响到用户体验和平台的整体稳定性。\"}],[\"$\",\"p\",null,{\"children\":[\"例如，大型互联网公司常常遇到一种被称为 \",[\"$\",\"strong\",null,{\"children\":\"“刷新风暴”\"}],\" 的流量模式。这种情况通常发生在一个受欢迎的主播因网络问题掉线时。主播重新开始直播后，观众会纷纷刷新他们的页面，导致服务器突然面临大量的API请求流量。\"]}],[\"$\",\"h2\",null,{\"className\":\"content-header\",\"id\":\"挑战与应对\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#挑战与应对\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"挑战与应对\"]}],[\"$\",\"p\",null,{\"children\":\"Visage是一个基于Go语言开发的应用（在此次优化中使用的是Go 1.11版本），运行在Amazon EC2实例上，并配有负载均衡器。尽管EC2结合自动扩展组的能力能够很好地进行水平扩展，但在应对突发的巨大流量时，依然存在挑战。\"}],[\"$\",\"p\",null,{\"children\":\"在“刷新风暴”期间，服务器需要在几秒钟内处理数百万个请求，流量激增可能是平时的20倍。工程师们发现，当前端服务器负载过高时，API的响应延迟会显著增加，从而影响用户体验。\"}],[\"$\",\"p\",null,{\"children\":\"一种简单的解决方案是始终保持高冗余的服务器容量，以应对这些突发情况，但这种做法非常浪费且成本高昂。为了减少这些持续上升的成本，工程师们决定探索能够提高单台服务器吞吐量，并在负载高峰时提供更稳定请求处理的优化方案。经过研究，他们找到了“内存镇流器”这一技术，以帮助改善内存管理和程序的整体性能。\"}],[\"$\",\"h2\",null,{\"className\":\"content-header\",\"id\":\"方案调研\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#方案调研\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"方案调研\"]}],[\"$\",\"p\",null,{\"children\":[\"在优化过程中，工程师们在生产环境中运行了 \",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"pprof\"}],\"，这使得获取真实生产流量下的性能分析变得非常容易。如果你还没有使用过 \",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"pprof\"}],\"，我强烈建议你开始使用它。大多数情况下，性能分析器对CPU的负载影响非常小。即使是执行跟踪器，尽管有一些开销，但影响微乎其微，可以在生产环境中每小时运行几秒钟，而不会对服务造成显著影响。\"]}],[\"$\",\"p\",null,{\"children\":\"通过对Go应用的性能分析，我们得出以下观察结果：\"}],[\"$\",\"ol\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"在稳定状态下，我们的应用每秒大约运行8-10次垃圾回收（GC）周期（每分钟400-600次）。\"}],[\"$\",\"li\",null,{\"children\":\"超过30%的CPU时间消耗在与GC相关的函数上，这一比例相当高，表明存在很大的优化空间。\"}],[\"$\",\"li\",null,{\"children\":\"在流量激增期间，GC周期数量进一步增加，这会加剧性能问题，导致应用响应时间变长。\"}],[\"$\",\"li\",null,{\"children\":\"我们的堆内存大小相对较小，这表明内存使用效率较高，但也可能导致频繁的GC触发。\"}]]}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[\"$\",\"$Lf\",null,{\"src\":\"/static/images/go/memory-ballast/picture1.webp\",\"alt\":\"GC Performance\",\"width\":\"721\",\"height\":\"289\"}]}]}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[\"$\",\"$Lf\",null,{\"src\":\"/static/images/go/memory-ballast/picture2.webp\",\"alt\":\"Heap Usage Analysis\",\"width\":\"516\",\"height\":\"250\"}]}]}],[\"$\",\"p\",null,{\"children\":\"我们此次改进的重点是优化应用程序的垃圾回收性能，以提升整体处理能力。\"}],[\"$\",\"h2\",null,{\"className\":\"content-header\",\"id\":\"什么是垃圾收集器gc\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#什么是垃圾收集器gc\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"什么是垃圾收集器（GC）？\"]}],[\"$\",\"p\",null,{\"children\":\"在现代编程中，通常有两种方式来分配内存：栈（stack）和堆（heap）。大多数程序员在第一次写出导致栈溢出的递归程序时，就已经对栈有了初步的了解。而堆则是一个用于动态内存分配的区域，适用于那些生命周期无法在编译时确定的对象。\"}],[\"$\",\"p\",null,{\"children\":\"栈内存的分配优势在于其生命周期与所属函数绑定，因此，当函数返回时，栈上的内存会自动释放。而堆上的内存则不会在超出作用域时自动释放。为了防止堆内存无限增长，我们要么手动释放内存，要么依赖像Go这样的编程语言中的垃圾收集器（GC），来查找并清除不再被引用的对象。\"}],[\"$\",\"p\",null,{\"children\":\"通常情况下，在有GC机制的语言中，尽可能多地在栈上分配内存是有益的，因为这些内存分配不会被GC察觉。Go语言通过逃逸分析（escape analysis）来确定对象是应该分配在栈上还是堆上。\"}],[\"$\",\"p\",null,{\"children\":\"然而，在实际应用中，编写只在栈上分配内存的程序往往非常受限。因此，我们依赖Go的高效垃圾收集器来维护堆内存的清洁，确保程序的性能和稳定性。\"}],[\"$\",\"h2\",null,{\"className\":\"content-header\",\"id\":\"go的垃圾收集器\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#go的垃圾收集器\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"Go的垃圾收集器\"]}],[\"$\",\"p\",null,{\"children\":[\"$\",\"em\",null,{\"children\":\"垃圾收集器是复杂的软件组件。\"}]}],[\"$\",\"p\",null,{\"children\":[\"从Go 1.5版本开始，Go引入了一个标记-清除（mark-and-sweep）垃圾收集器。顾名思义，这种GC机制包括两个主要阶段：\",[\"$\",\"strong\",null,{\"children\":\"标记\"}],\"和\",[\"$\",\"strong\",null,{\"children\":\"清除\"}],\"。与传统的“全程暂停应用程序”（Stop The World, STW）的垃圾回收不同，Go的GC在大多数情况下能够与应用程序代码并发运行，从而减少对程序执行的影响。\"]}],[\"$\",\"h3\",null,{\"className\":\"content-header\",\"id\":\"标记和清除阶段\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#标记和清除阶段\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"标记和清除阶段\"]}],[\"$\",\"ol\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"标记阶段\"}],\"：运行时会遍历堆中所有被应用程序引用的对象，并将这些对象标记为“仍在使用中”。这些对象被称为\",[\"$\",\"strong\",null,{\"children\":\"活动内存\"}],\"。标记阶段的任务是找出所有仍然有用的数据，以确保它们不会被错误地回收。\"]}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"清除阶段\"}],\"：在标记阶段完成后，所有未被标记的对象就会被认为是垃圾。清除阶段的任务是将这些未被引用的对象从堆中移除，释放出相应的内存。\"]}]}]]}],[\"$\",\"p\",null,{\"children\":\"在整个GC周期中，虽然清除操作本质上是“STW”的，但由于现代操作系统在释放内存时的速度非常快，清除阶段所占用的时间通常较短。因此，标记阶段是影响GC时间的主要因素。\"}],[\"$\",\"h3\",null,{\"className\":\"content-header\",\"id\":\"关键术语\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#关键术语\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"关键术语\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"堆大小\"}],\"：包括堆中所有的内存分配，既包含当前被使用的，也包含已经成为垃圾的部分。\"]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"活动内存\"}],\"：指正在被应用程序引用的内存分配，是当前有用的部分，不包括垃圾。\"]}]]}],[\"$\",\"h3\",null,{\"className\":\"content-header\",\"id\":\"标记阶段与性能的关系\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#标记阶段与性能的关系\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"标记阶段与性能的关系\"]}],[\"$\",\"p\",null,{\"children\":[\"在标记阶段，运行时需要遍历应用程序当前引用的所有对象，因此标记所需的时间与活动内存的大小成正比，而与总堆大小无关。这意味着，即使堆中有大量的垃圾对象，也不会显著增加标记阶段所需的时间。因此，理论上讲，\",[\"$\",\"strong\",null,{\"children\":\"拥有更多垃圾对象并不会明显延长GC周期。\"}]]}],[\"$\",\"p\",null,{\"children\":\"然而，这种设计存在权衡。减少GC触发的频率，意味着垃圾清理的时间间隔变长，从而在内存中会积累更多的垃圾对象。这种权衡的结果就是：随着GC间隔的增加，系统内存消耗会变高。\"}],[\"$\",\"h3\",null,{\"className\":\"content-header\",\"id\":\"visage应用程序中的实际问题\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#visage应用程序中的实际问题\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"Visage应用程序中的实际问题\"]}],[\"$\",\"p\",null,{\"children\":\"在Visage应用程序中，我们注意到它运行在专有的虚拟机上，拥有64GiB的物理内存，但即便如此，应用程序的GC非常频繁，而实际使用的物理内存仅约400MiB。这种现象表明GC频率过高，造成了CPU资源的浪费。要理解这种情况，我们需要深入了解Go如何在GC频率和内存使用之间进行权衡，这就涉及到Go垃圾收集的步调控制器（Pacer）。\"}],[\"$\",\"h2\",null,{\"className\":\"content-header\",\"id\":\"pacer步调控制器\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#pacer步调控制器\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"Pacer（步调控制器）\"]}],[\"$\",\"p\",null,{\"children\":[\"Go 的 GC 使用 \",[\"$\",\"strong\",null,{\"children\":\"步调控制器\"}],\" 来决定何时启动下一个 GC 周期。这被建模为一个控制问题，它试图找到正确的时机来触发 GC 周期，以达到目标堆大小。默认情况下，Go 的步调控制器会尝试在堆大小每次翻倍时启动一个 GC 周期。这是通过在当前 GC 周期的标记终止阶段设置下一个堆触发大小来实现的。因此，在标记完所有活动内存后，它可以决定在总堆大小是当前集合的 2 倍时运行下一次 GC。这个 2 倍值来自运行时使用的 \",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"GOGC\"}],\" 环境变量设置的触发器比率。\"]}],[\"$\",\"p\",null,{\"children\":\"在我们的场景中，步调控制器有效地将堆上的垃圾保持在最小限度，但代价是引入了大量不必要的GC操作，因为应用程序仅使用了系统内存的约0.6%。\"}],[\"$\",\"h3\",null,{\"className\":\"content-header\",\"id\":\"引入内存镇流器ballast\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#引入内存镇流器ballast\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"引入内存镇流器（Ballast）\"]}],[\"$\",\"p\",null,{\"children\":\"我们通过在应用程序启动时分配一个大型字节数组（例如10 GiB）来实现内存镇流器，这样做的目的是增加堆的稳定性：\"}],[\"$\",\"$L19\",null,{\"className\":\"language-go\",\"children\":[\"$\",\"code\",null,{\"className\":\"language-go code-highlight\",\"children\":[[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[[\"$\",\"span\",null,{\"className\":\"token keyword\",\"children\":\"func\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token function\",\"children\":\"main\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"{\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"\\t\",[\"$\",\"span\",null,{\"className\":\"token comment\",\"children\":\"// 创建一个10 GiB的大型堆分配\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"\\tballast \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\":=\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token function\",\"children\":\"make\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"[\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"]\"}],[\"$\",\"span\",null,{\"className\":\"token builtin\",\"children\":\"byte\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\",\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"10\"}],[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"\u003c\u003c\"}],[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"30\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"\\t\",[\"$\",\"span\",null,{\"className\":\"token comment\",\"children\":\"// 继续执行应用程序\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"\\t\",[\"$\",\"span\",null,{\"className\":\"token comment\",\"children\":\"// ...\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"}\"}],\"\\n\"]}]]}]}],[\"$\",\"h3\",null,{\"className\":\"content-header\",\"id\":\"解释\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#解释\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"解释\"]}],[\"$\",\"h4\",null,{\"className\":\"content-header\",\"id\":\"1-为什么使用内存镇流器\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#1-为什么使用内存镇流器\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"1. 为什么使用内存镇流器？\"]}],[\"$\",\"p\",null,{\"children\":\"如前所述，GC 会在堆大小每次翻倍时触发。堆大小是堆上所有分配的总大小。因此，如果分配了 10GB 的镇流器，下一次 GC 只会在堆大小增长到 20GB 时触发。此时，大约会有 10GB 的镇流器 + 10GB 的其他分配。\"}],[\"$\",\"p\",null,{\"children\":\"当 GC 运行时，镇流器不会被当作垃圾清除，因为我们在 main 函数中仍然保持对它的引用，因此它被视为活动内存的一部分。由于我们应用程序中的大多数分配只在短暂的 API 请求生命周期内存在，10GB 分配中的大部分将被清除，将堆大小再次减小到略高于 ~10GB (即 10GB 镇流器加上所有正在进行的请求中被认为是活动内存的分配)。现在，下一个 GC 周期将在堆大小（当前略高于 10GB）再次翻倍时发生。\"}],[\"$\",\"p\",null,{\"children\":\"因此，镇流器增加了基本堆大小，使得我们的 GC 触发被延迟，随时间推移 GC 周期的数量减少。这个改变如预期那样起作用了 - 我们看到 GC 周期减少了约 99%：\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[\"$\",\"$Lf\",null,{\"src\":\"/static/images/go/memory-ballast/picture3.webp\",\"alt\":\"GC Reduction Graph\",\"width\":\"1658\",\"height\":\"498\"}]}]}],[\"$\",\"p\",null,{\"children\":\"那么这看起来不错,CPU使用率呢?\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[\"$\",\"$Lf\",null,{\"src\":\"/static/images/go/memory-ballast/picture4.webp\",\"alt\":\"GC Reduction Graph\",\"width\":\"1400\",\"height\":\"454\"}]}]}],[\"$\",\"p\",null,{\"children\":\"绿色的正弦波形CPU指标是由我们流量的每日波动引起的。可以看到改变后有一个明显的下降。\"}],[\"$\",\"p\",null,{\"children\":\"~30%的CPU减少意味着不用进一步观察，我们可以将波动减少30%，然而我们也关心API延迟——稍后会详细讨论这一点。\"}],[\"$\",\"p\",null,{\"children\":[\"如前所述,Go运行时提供了一个\",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"GOGC\"}],\"环境变量，允许对GC步调控制器进行非常粗略的调整。这个值控制堆在运行GC之前的增长比例。我们决定不使用它，因为它有一些明显的缺点:\"]}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"比例本身对我们来说并不重要；我们使用的内存量才是。\"}],[\"$\",\"li\",null,{\"children\":\"我们必须将值设置得非常高才能获得与镇流器相同的效果，使得该值对活动堆大小的小变化很敏感。\"}],[\"$\",\"li\",null,{\"children\":\"推理活动内存及其变化率并不容易;而思考总使用内存则很简单。\"}]]}],[\"$\",\"p\",null,{\"children\":[\"$\",\"em\",null,{\"children\":\"如果你想知道为什么我们使用字节数组作为镇流器,这保证我们只向标记阶段添加一个额外的对象。因为字节数组没有任何指针(除了对象本身),GC可以在O(1)时间内标记整个对象。\"}]}],[\"$\",\"h4\",null,{\"className\":\"content-header\",\"id\":\"2-这不会浪费10-gib的物理内存吗\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#2-这不会浪费10-gib的物理内存吗\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"2. 这不会浪费10 GiB的物理内存吗？\"]}],[\"$\",\"p\",null,{\"children\":[\"简短的回答是：不会，除非你在代码中访问这些内存。在Unix系统（包括Windows）中，内存是通过操作系统的页表进行映射的。尽管\",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"make([]byte, 10\u003c\u003c30)\"}],\"会在程序的虚拟地址空间中创建一个10 GiB的数组，但实际的物理内存只有在对该数组进行读写时才会被分配。只有当我们试图读取或写入切片时，才会发生页面错误，导致支持虚拟地址的物理 RAM 被分配。\"]}],[\"$\",\"p\",null,{\"children\":\"可以通过以下简单程序进行验证：\"}],[\"$\",\"$L19\",null,{\"className\":\"language-go\",\"children\":[\"$\",\"code\",null,{\"className\":\"language-go code-highlight\",\"children\":[[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[[\"$\",\"span\",null,{\"className\":\"token keyword\",\"children\":\"func\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token function\",\"children\":\"main\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"{\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"    \",[\"$\",\"span\",null,{\"className\":\"token boolean\",\"children\":\"_\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"=\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token function\",\"children\":\"make\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"[\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"]\"}],[\"$\",\"span\",null,{\"className\":\"token builtin\",\"children\":\"byte\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\",\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"100\"}],[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"\u003c\u003c\"}],[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"20\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"    \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"\u003c-\"}],\"time\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\".\"}],[\"$\",\"span\",null,{\"className\":\"token function\",\"children\":\"After\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],\"time\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\".\"}],[\"$\",\"span\",null,{\"className\":\"token function\",\"children\":\"Duration\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],\"math\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\".\"}],\"MaxInt64\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"}\"}],\"\\n\"]}]]}]}],[\"$\",\"p\",null,{\"children\":[\"运行程序后使用\",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"ps\"}],\"查看内存分配：\"]}],[\"$\",\"$L19\",null,{\"className\":\"language-shell\",\"children\":[\"$\",\"code\",null,{\"className\":\"code-highlight language-shell\",\"children\":[[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":\"%MEM  COMMAND          PID    MAJFL  MINFL  RSS   VSZ\\n\"}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"0.2\"}],\"   test_alloc       \",[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"27826\"}],\"  \",[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"0\"}],\"      \",[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"1003\"}],\"   \",[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"4\"}],\".8M  108M\\n\"]}]]}]}],[\"$\",\"p\",null,{\"children\":\"这表示进程的虚拟内存分配（VSZ）约为100 MiB，但实际占用的物理内存（RSS）仅为~5 MiB。\"}],[\"$\",\"p\",null,{\"children\":\"接下来，如果我们修改程序，让它写入一半的字节数组：\"}],[\"$\",\"$L19\",null,{\"className\":\"language-go\",\"children\":[\"$\",\"code\",null,{\"className\":\"language-go code-highlight\",\"children\":[[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[[\"$\",\"span\",null,{\"className\":\"token keyword\",\"children\":\"func\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token function\",\"children\":\"main\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"{\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"\\tballast \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\":=\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token function\",\"children\":\"make\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"[\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"]\"}],[\"$\",\"span\",null,{\"className\":\"token builtin\",\"children\":\"byte\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\",\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"100\"}],[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"\u003c\u003c\"}],[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"20\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"\\t\",[\"$\",\"span\",null,{\"className\":\"token keyword\",\"children\":\"for\"}],\" i \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\":=\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"0\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\";\"}],\" i \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"\u003c\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token function\",\"children\":\"len\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],\"ballast\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"/\"}],[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"2\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\";\"}],\" i\",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"++\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"{\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"\\t\\tballast\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"[\"}],\"i\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"]\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"=\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token function\",\"children\":\"byte\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],[\"$\",\"span\",null,{\"className\":\"token char\",\"children\":\"'A'\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"\\t\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"}\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"\\t\",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"\u003c-\"}],\"time\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\".\"}],[\"$\",\"span\",null,{\"className\":\"token function\",\"children\":\"After\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],\"time\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\".\"}],[\"$\",\"span\",null,{\"className\":\"token function\",\"children\":\"Duration\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],\"math\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\".\"}],\"MaxInt64\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"}\"}],\"\\n\"]}]]}]}],[\"$\",\"p\",null,{\"children\":[\"再次检查\",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"ps\"}],\"输出：\"]}],[\"$\",\"$L19\",null,{\"className\":\"language-shell\",\"children\":[\"$\",\"code\",null,{\"className\":\"code-highlight language-shell\",\"children\":[[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":\"%MEM  COMMAND          PID    MAJFL  MINFL  RSS   VSZ\\n\"}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"2.7\"}],\"   test_alloc       \",[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"28331\"}],\"  \",[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"0\"}],\"      \",[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"1\"}],\".5K   57M   108M\\n\"]}]]}]}],[\"$\",\"p\",null,{\"children\":\"正如预期的那样，现在字节数组的一半在 RSS 中，占用物理内存。VSZ 没有变化，因为在两个程序中都存在相同大小的虚拟分配。\"}],[\"$\",\"p\",null,{\"children\":[\"$\",\"em\",null,{\"children\":\"对于那些感兴趣的人，MINFL 列是次要页面错误的数量 - 这是发生在进程中需要从内存加载页面的页面错误数量。如果 OS 成功地很好地连续分配了我们的物理内存，那么每个页面错误将能够映射多个 RAM 页面，减少发生的总页面错误数量。\"}]}],[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"总结\"}],\"：\"]}],[\"$\",\"ol\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"内存镇流器的优势\"}],\"：通过增加堆基准大小，内存镇流器减少了GC周期的频率，从而降低了CPU的使用率，提升了应用程序的整体性能。\"]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"物理内存的利用\"}],\"：镇流器作为虚拟分配存在，只要不读写它，其内存开销几乎不会反映在实际的物理内存中。\"]}]]}],[\"$\",\"h2\",null,{\"className\":\"content-header\",\"id\":\"api延迟\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#api延迟\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"API延迟\"]}],[\"$\",\"p\",null,{\"children\":\"正如前面提到的，我们观察到减少GC频率后，API延迟得到了改善，尤其是在高负载期间。最初，我们猜测这是因为GC暂停时间减少了。然而，改变前后GC暂停时间的差异并不显著，而且暂停时间仅为单位数毫秒，而我们在峰值负载时观察到的延迟却达到100毫秒级。\"}],[\"$\",\"p\",null,{\"children\":[\"要更好地理解延迟改善的原因，我们需要探讨Go GC中的一个重要特性——\",[\"$\",\"strong\",null,{\"children\":\"GC assists\"}],\"。\"]}],[\"$\",\"h3\",null,{\"className\":\"content-header\",\"id\":\"gc-assists\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#gc-assists\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"GC assists\"]}],[\"$\",\"p\",null,{\"children\":[\"GC assists机制会在\",[\"$\",\"strong\",null,{\"children\":\"GC周期期间\"}],\"将部分内存分配工作转移到正在执行分配操作的goroutine上。没有这种机制，Go运行时就无法在GC周期期间控制堆的增长。\"]}],[\"$\",\"p\",null,{\"children\":\"Go已经有一个后台GC工作线程，而__“assists”__意味着用户的goroutine会帮助后台GC线程进行特定的工作，尤其是标记阶段的工作。\"}],[\"$\",\"p\",null,{\"children\":\"为了更好地理解这一点，让我们看一个例子:\"}],[\"$\",\"$L19\",null,{\"className\":\"language-go\",\"children\":[\"$\",\"code\",null,{\"className\":\"language-go code-highlight\",\"children\":[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"someObject \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\":=\"}],\"  \",[\"$\",\"span\",null,{\"className\":\"token function\",\"children\":\"make\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"[\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"]\"}],[\"$\",\"span\",null,{\"className\":\"token builtin\",\"children\":\"int\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\",\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"5\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],\"\\n\"]}]}]}],[\"$\",\"p\",null,{\"children\":[\"当这段代码执行时，goroutine通过一系列符号转换和类型检查，最终调用\",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"runtime.mallocgc\"}],\"来为切片分配内存。\",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"runtime.mallocgc\"}],\"内部包含一些有趣的逻辑：\"]}],[\"$\",\"$L19\",null,{\"className\":\"language-go\",\"children\":[\"$\",\"code\",null,{\"className\":\"language-go code-highlight\",\"children\":[[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[[\"$\",\"span\",null,{\"className\":\"token comment\",\"children\":\"// 分配指定大小的对象。\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[[\"$\",\"span\",null,{\"className\":\"token keyword\",\"children\":\"func\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token function\",\"children\":\"mallocgc\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],\"size \",[\"$\",\"span\",null,{\"className\":\"token builtin\",\"children\":\"uintptr\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\",\"}],\" typ \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"*\"}],\"_type\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\",\"}],\" needzero \",[\"$\",\"span\",null,{\"className\":\"token builtin\",\"children\":\"bool\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],\" unsafe\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\".\"}],\"Pointer \",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"{\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":\"\\n\"}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"  \\t\",[\"$\",\"span\",null,{\"className\":\"token comment\",\"children\":\"// 一些错误检查和调试代码被省略...\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":\"\\n\"}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"\\t\",[\"$\",\"span\",null,{\"className\":\"token comment\",\"children\":\"// assistG是用于此分配的G（goroutine），如果GC未激活则为nil。\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"\\t\",[\"$\",\"span\",null,{\"className\":\"token keyword\",\"children\":\"var\"}],\" assistG \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"*\"}],\"g\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"\\t\",[\"$\",\"span\",null,{\"className\":\"token keyword\",\"children\":\"if\"}],\" gcBlackenEnabled \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"!=\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"0\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"{\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"\\t\\tassistG \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"=\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token function\",\"children\":\"getg\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"\\t\\t\",[\"$\",\"span\",null,{\"className\":\"token comment\",\"children\":\"// 对当前的goroutine进行“收费”。\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"\\t\\tassistG\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\".\"}],\"gcAssistBytes \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"-=\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token function\",\"children\":\"int64\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],\"size\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":\"\\n\"}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"\\t\\t\",[\"$\",\"span\",null,{\"className\":\"token keyword\",\"children\":\"if\"}],\" assistG\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\".\"}],\"gcAssistBytes \",[\"$\",\"span\",null,{\"className\":\"token operator\",\"children\":\"\u003c\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token number\",\"children\":\"0\"}],\" \",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"{\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"\\t\\t\\t\",[\"$\",\"span\",null,{\"className\":\"token comment\",\"children\":\"// 当goroutine有分配债务时，调用gcAssistAlloc进行GC工作。\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"\\t\\t\\t\",[\"$\",\"span\",null,{\"className\":\"token function\",\"children\":\"gcAssistAlloc\"}],[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"(\"}],\"assistG\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\")\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"\\t\\t\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"}\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"\\t\",[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"}\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":\"\\n\"}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[\"\\t\",[\"$\",\"span\",null,{\"className\":\"token comment\",\"children\":\"// 实际分配代码被省略...\"}],\"\\n\"]}],[\"$\",\"span\",null,{\"className\":\"code-line\",\"children\":[[\"$\",\"span\",null,{\"className\":\"token punctuation\",\"children\":\"}\"}],\"\\n\"]}]]}]}],[\"$\",\"p\",null,{\"children\":[\"在上面的代码中，\",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"if assistG.gcAssistBytes \u003c 0\"}],\"这行检查我们的goroutine是否有分配债务。分配债务是一种奇特的说法，意思是这个goroutine在GC周期期间分配的内存比它做GC工作的多。\"]}],[\"$\",\"p\",null,{\"children\":[\"你可以把这想象成你的goroutine在GC周期期间分配时必须支付的税，除了这个税必须提前支付，然后才能实际进行分配。此外，税是与goroutine试图分配的数量成比例的。这提供了一定程度的\",[\"$\",\"em\",null,{\"children\":\"公平性\"}],\"，使得分配很多的goroutines为这些分配付出代价。\"]}],[\"$\",\"p\",null,{\"children\":[\"因此,假设这是我们的goroutine在当前GC周期中第一次分配,它将被强制做GC assist工作。这里有趣的一行是对\",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"gcAssistAlloc\"}],\"的调用。\"]}],[\"$\",\"p\",null,{\"children\":[\"这个函数负责一些清理工作,最终调用\",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"gcAssistAlloc1\"}],\"来执行实际的GC assist工作。我不会深入\",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"gcAssistAlloc\"}],\"函数的细节,但本质上它做以下事情:\"]}],[\"$\",\"ol\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"检查goroutine是否在做一些不可抢占的事情(即系统goroutine)\"}],[\"$\",\"li\",null,{\"children\":\"执行GC标记工作\"}],[\"$\",\"li\",null,{\"children\":\"检查goroutine是否仍有分配债务,否则返回\"}]]}],[\"$\",\"p\",null,{\"children\":[\"现在应该清楚，任何运行并涉及\",[\"$\",\"strong\",null,{\"children\":\"分配\"}],\"的goroutine都将在\",[\"$\",\"strong\",null,{\"children\":\"GC周期期间\"}],\"承担\",[\"$\",\"strong\",null,{\"children\":\"GC Assist的惩罚\"}],\"。由于工作必须在分配之前完成，这将表现为goroutine原本打算做的实际有用工作的延迟或迟缓。\"]}],[\"$\",\"h4\",null,{\"className\":\"content-header\",\"id\":\"api延迟的影响\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#api延迟的影响\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"API延迟的影响\"]}],[\"$\",\"p\",null,{\"children\":\"在我们的API前端中，这种机制意味着，当GC周期活跃时，goroutine的分配操作会因为辅助GC工作而导致响应延迟。随着服务器负载增加，内存分配的频率上升，这又会触发更多的GC周期（通常每秒高达10到20次）。更多的GC周期意味着更多的GC assist工作，从而使API响应时间增加。\"}],[\"$\",\"p\",null,{\"children\":\"通过执行跟踪，我们可以清楚地看到这一现象。下面是两个跟踪片段：一个在GC周期期间，另一个在非GC周期期间。\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[\"$\",\"$Lf\",null,{\"src\":\"/static/images/go/memory-ballast/picture5.webp\",\"alt\":\"Maple\",\"width\":\"1008\",\"height\":\"688\"}]}]}],[\"$\",\"p\",null,{\"children\":[\"跟踪显示了哪些goroutines在哪个处理器上运行。所有标记为\",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"app-code\"}],\"的都是执行我们应用程序有用代码的goroutine(例如服务API请求的逻辑)。注意，除了四个专门执行GC代码的处理器外，我们的其他goroutines如何被延迟并被迫做\",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"MARK ASSIST\"}],\"(即\",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"runtime.gcAssistAlloc\"}],\")工作。\"]}],[\"$\",\"p\",null,{\"children\":\"将此与同一运行应用程序不在GC周期期间的这个配置文件进行比较。这里我们的goroutines大部分时间都在运行我们的应用程序代码，正如预期的那样：\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[\"$\",\"$Lf\",null,{\"src\":\"/static/images/go/memory-ballast/picture6.webp\",\"alt\":\"Maple\",\"width\":\"913\",\"height\":\"640\"}]}]}],[\"$\",\"p\",null,{\"children\":[\"通过减少GC频率，我们显著减少了\",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"MARK ASSIST\"}],\"的次数，几乎降低了99%。这直接改善了API的响应时间，特别是在高流量下，使得99百分位的延迟下降了约45%。\"]}],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-center text-center\",\"children\":[\"$\",\"div\",null,{\"children\":[\"$\",\"$Lf\",null,{\"src\":\"/static/images/go/memory-ballast/picture7.webp\",\"alt\":\"Maple\",\"width\":\"952\",\"height\":\"593\"}]}]}],[\"$\",\"h3\",null,{\"className\":\"content-header\",\"id\":\"为什么选择这种设计\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#为什么选择这种设计\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"为什么选择这种设计？\"]}],[\"$\",\"p\",null,{\"children\":\"你可能会好奇，为什么Go选择了这样一种通过GC assist来分摊内存分配负担的设计。实际上，这是为了在并发GC中有效管理堆的增长。在停止世界（STW）的GC中，控制堆增长相对简单，但在并发GC中，我们需要一种机制确保在GC周期期间发生的分配不会导致堆无限制增长。让goroutine为其分配的内存“缴税”，使得这种设计变得相当优雅，也更具公平性。\"}],[\"$\",\"h2\",null,{\"className\":\"content-header\",\"id\":\"总结\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#总结\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"总结\"]}],[\"$\",\"ol\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"我们发现应用程序在GC操作上花费了大量时间。\"}],[\"$\",\"li\",null,{\"children\":[\"为此，我们引入了\",[\"$\",\"strong\",null,{\"children\":\"内存镇流器\"}],\"。\"]}],[\"$\",\"li\",null,{\"children\":\"通过允许堆增长得更大，内存镇流器减少了GC周期的频率。\"}],[\"$\",\"li\",null,{\"children\":[\"这直接减少了Go GC中的\",[\"$\",\"strong\",null,{\"children\":\"assist\"}],\"延迟，从而改善了API的响应时间。\"]}],[\"$\",\"li\",null,{\"children\":\"由于镇流器仅消耗虚拟内存，因而其分配成本几乎可以忽略不计。\"}],[\"$\",\"li\",null,{\"children\":[\"与调整\",[\"$\",\"code\",null,{\"className\":\"custom-code\",\"children\":\"GOGC\"}],\"参数相比，使用镇流器更容易推理和管理。\"]}],[\"$\",\"li\",null,{\"children\":\"建议从较小的镇流器开始，并在测试过程中逐步调整。\"}]]}],[\"$\",\"h2\",null,{\"className\":\"content-header\",\"id\":\"一些最后的思考\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#一些最后的思考\",\"aria-hidden\":\"true\",\"tabIndex\":\"-1\",\"children\":[\"$\",\"span\",null,{\"className\":\"content-header-link\",\"children\":[\"$\",\"svg\",null,{\"className\":\"h-5 linkicon w-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.667l3-3Z\"}],[\"$\",\"path\",null,{\"d\":\"M11.603 7.963a.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.667l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 1 0 5.656 5.656l3-3a4 4 0 0 0-.225-5.865Z\"}]]}]}]}],\"一些最后的思考\"]}],[\"$\",\"p\",null,{\"children\":\"Go在运行时细节上做了很好的抽象，这对大多数程序和开发者来说都是理想的。\"}],[\"$\",\"p\",null,{\"children\":\"然而，当你的应用接近性能瓶颈，不论是在计算、内存还是I/O方面时，深入研究其内部机制就变得至关重要。\"}],[\"$\",\"p\",null,{\"children\":\"在这些情况下，拥有一套强大的工具，如Go提供的调试与性能分析工具，能够帮助快速识别和解决瓶颈，这显然是非常有用的。\"}]]}]}],[\"$\",\"div\",null,{\"className\":\"pb-6 pt-6 text-center text-gray-700 dark:text-gray-300\",\"id\":\"comment\",\"children\":[\"$\",\"$L1a\",null,{\"slug\":\"go/memory-ballast\"}]}],[\"$\",\"footer\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col text-sm font-medium sm:flex-row sm:justify-between sm:text-base\",\"children\":[[\"$\",\"div\",null,{\"className\":\"pt-4 xl:pt-8\",\"children\":[\"$\",\"$Le\",null,{\"href\":\"/blog/diary/2024-09-17\",\"className\":\"text-primary-500 hover:text-primary-600 dark:hover:text-primary-400\",\"aria-label\":\"Previous post: 领队随想\",\"children\":[\"← \",\"领队随想\"]}]}],[\"$\",\"div\",null,{\"className\":\"pt-4 xl:pt-8\",\"children\":[\"$\",\"$Le\",null,{\"href\":\"/blog/tools/hack-email\",\"className\":\"text-primary-500 hover:text-primary-600 dark:hover:text-primary-400\",\"aria-label\":\"Next post: 获取非加密邮件协议中的用户名和密码——安全风险演示\",\"children\":[\"获取非加密邮件协议中的用户名和密码——安全风险演示\",\" →\"]}]}]]}]}]]}]]}]}]]}]]\n"])</script><script>self.__next_f.push([1,"15:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Go语言的内存镇流器\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"我们通过引入内存镇流器减少了Go应用程序的垃圾回收（GC）周期频率，从而改善了API响应时间。这种做法允许堆在更大范围内增长，减少了GC辅助延迟，而镇流器的虚拟内存分配几乎不消耗实际RAM。相比调整GOGC值，使用镇流器更易于推理与管理。最后，深入分析性能瓶颈是提高应用效率的关键。\"}],[\"$\",\"meta\",\"4\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"5\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"6\",{\"rel\":\"canonical\",\"href\":\"https://blog.mainjay.cloudns.ch/blog/go/memory-ballast\"}],[\"$\",\"link\",\"7\",{\"rel\":\"alternate\",\"type\":\"application/rss+xml\",\"href\":\"https://blog.mainjay.cloudns.ch/feed.xml\"}],[\"$\",\"meta\",\"8\",{\"property\":\"og:title\",\"content\":\"Go语言的内存镇流器\"}],[\"$\",\"meta\",\"9\",{\"property\":\"og:description\",\"content\":\"我们通过引入内存镇流器减少了Go应用程序的垃圾回收（GC）周期频率，从而改善了API响应时间。这种做法允许堆在更大范围内增长，减少了GC辅助延迟，而镇流器的虚拟内存分配几乎不消耗实际RAM。相比调整GOGC值，使用镇流器更易于推理与管理。最后，深入分析性能瓶颈是提高应用效率的关键。\"}],[\"$\",\"meta\",\"10\",{\"property\":\"og:url\",\"content\":\"https://blog.mainjay.cloudns.ch/blog/go/memory-ballast\"}],[\"$\",\"meta\",\"11\",{\"property\":\"og:site_name\",\"content\":\"MainJayLai Blog\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:locale\",\"content\":\"en_US\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:image\",\"content\":\"https://pngimg.com/uploads/github/github_PNG80.png\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"15\",{\"property\":\"article:published_time\",\"content\":\"2024-10-17T00:00:00.000Z\"}],[\"$\",\"meta\",\"16\",{\"property\":\"article:modified_time\",\"content\":\"2024-10-17T00:00:00.000Z\"}],[\"$\",\"meta\",\"17\",{\"property\":\"article:author\",\"content\":\"mainJayLai\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"Go语言的内存镇流器\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"我们通过引入内存镇流器减少了Go应用程序的垃圾回收（GC）周期频率，从而改善了API响应时间。这种做法允许堆在更大范围内增长，减少了GC辅助延迟，而镇流器的虚拟内存分配几乎不消耗实际RAM。相比调整GOGC值，使用镇流器更易于推理与管理。最后，深入分析性能瓶颈是提高应用效率的关键。\"}],[\"$\",\"meta\",\"21\",{\"name\":\"twitter:image\",\"content\":\"https://pngimg.com/uploads/github/github_PNG80.png\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>
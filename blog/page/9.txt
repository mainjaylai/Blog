2:I[6379,["231","static/chunks/231-34a6a67d2da26855.js","166","static/chunks/166-f8ba395620a18dc5.js","107","static/chunks/app/blog/page/%5Bpage%5D/page-62601385aed3ebec.js"],"default"]
3d:I[9275,[],""]
3f:I[1343,[],""]
40:I[8700,["599","static/chunks/ebde5ed1-51545511fe0d5050.js","231","static/chunks/231-34a6a67d2da26855.js","827","static/chunks/827-69594f61c16b8a9c.js","850","static/chunks/850-ecf153581cc02044.js","185","static/chunks/app/layout-54bebb918ae7f176.js"],"ThemeProviders"]
41:I[4080,["599","static/chunks/ebde5ed1-51545511fe0d5050.js","231","static/chunks/231-34a6a67d2da26855.js","827","static/chunks/827-69594f61c16b8a9c.js","850","static/chunks/850-ecf153581cc02044.js","185","static/chunks/app/layout-54bebb918ae7f176.js"],""]
42:I[9032,["599","static/chunks/ebde5ed1-51545511fe0d5050.js","231","static/chunks/231-34a6a67d2da26855.js","827","static/chunks/827-69594f61c16b8a9c.js","850","static/chunks/850-ecf153581cc02044.js","185","static/chunks/app/layout-54bebb918ae7f176.js"],"KBarSearchProvider"]
43:I[231,["231","static/chunks/231-34a6a67d2da26855.js","827","static/chunks/827-69594f61c16b8a9c.js","797","static/chunks/app/blog/%5B...slug%5D/page-bd056182432da53b.js"],""]
44:I[8173,["231","static/chunks/231-34a6a67d2da26855.js","827","static/chunks/827-69594f61c16b8a9c.js","797","static/chunks/app/blog/%5B...slug%5D/page-bd056182432da53b.js"],"Image"]
45:I[509,["599","static/chunks/ebde5ed1-51545511fe0d5050.js","231","static/chunks/231-34a6a67d2da26855.js","827","static/chunks/827-69594f61c16b8a9c.js","850","static/chunks/850-ecf153581cc02044.js","185","static/chunks/app/layout-54bebb918ae7f176.js"],"KBarButton"]
46:I[1398,["599","static/chunks/ebde5ed1-51545511fe0d5050.js","231","static/chunks/231-34a6a67d2da26855.js","827","static/chunks/827-69594f61c16b8a9c.js","850","static/chunks/850-ecf153581cc02044.js","185","static/chunks/app/layout-54bebb918ae7f176.js"],"default"]
47:I[7606,["599","static/chunks/ebde5ed1-51545511fe0d5050.js","231","static/chunks/231-34a6a67d2da26855.js","827","static/chunks/827-69594f61c16b8a9c.js","850","static/chunks/850-ecf153581cc02044.js","185","static/chunks/app/layout-54bebb918ae7f176.js"],"default"]
48:I[7510,["599","static/chunks/ebde5ed1-51545511fe0d5050.js","231","static/chunks/231-34a6a67d2da26855.js","827","static/chunks/827-69594f61c16b8a9c.js","850","static/chunks/850-ecf153581cc02044.js","185","static/chunks/app/layout-54bebb918ae7f176.js"],"default"]
49:I[8976,["599","static/chunks/ebde5ed1-51545511fe0d5050.js","231","static/chunks/231-34a6a67d2da26855.js","827","static/chunks/827-69594f61c16b8a9c.js","850","static/chunks/850-ecf153581cc02044.js","185","static/chunks/app/layout-54bebb918ae7f176.js"],"default"]
4:["backend","go"]
5:{"text":"7 min read","minutes":6.775,"time":406500,"words":1355}
7:{"value":"使用新的 mux","url":"#使用新的-mux","depth":2}
8:{"value":"使用新的 mux 重新实现任务服务器","url":"#使用新的-mux-重新实现任务服务器","depth":2}
9:{"value":"结论","url":"#结论-8","depth":2}
6:["$7","$8","$9"]
c:{"@type":"Person","name":"mainJayLai"}
b:["$c"]
a:{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go 1.22 中更优秀的 HTTP 服务器路由","datePublished":"2024-11-21T00:00:00.000Z","dateModified":"2024-11-21T00:00:00.000Z","description":"Go 1.22 将引入增强版 HTTP 路由多路复用器，提供更强大的路径匹配和方法路由能力。新的 ServeMux 支持通配符、方法限定和细粒度路由，有望减少对第三方路由库的依赖，为 Go Web 开发带来便利。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/go/mux","author":"$b"}
3:{"title":"Go 1.22 中更优秀的 HTTP 服务器路由","date":"2024-11-21T00:00:00.000Z","tags":"$4","draft":false,"summary":"Go 1.22 将引入增强版 HTTP 路由多路复用器，提供更强大的路径匹配和方法路由能力。新的 ServeMux 支持通配符、方法限定和细粒度路由，有望减少对第三方路由库的依赖，为 Go Web 开发带来便利。","layout":"PostSimple","type":"Blog","readingTime":"$5","slug":"go/mux","path":"blog/go/mux","filePath":"blog/go/mux.mdx","toc":"$6","structuredData":"$a"}
e:["backend","go"]
f:{"text":"15 min read","minutes":14.77,"time":886200,"words":2954}
11:{"value":"Context 类型","url":"#context-类型","depth":2}
12:{"value":"Context 实战","url":"#context-实战","depth":2}
13:{"value":"WithValue 函数","url":"#withvalue-函数","depth":2}
14:{"value":"WithCancel 函数","url":"#withcancel-函数","depth":2}
15:{"value":"WithTimeout 函数","url":"#withtimeout-函数","depth":2}
16:{"value":"总结","url":"#总结-5","depth":2}
10:["$11","$12","$13","$14","$15","$16"]
19:{"@type":"Person","name":"mainJayLai"}
18:["$19"]
17:{"@context":"https://schema.org","@type":"BlogPosting","headline":"深入理解 Go 的 Context 包","datePublished":"2024-11-18T00:00:00.000Z","dateModified":"2024-11-18T00:00:00.000Z","description":"Go 的 context 包提供了强大的工具，用于管理请求范围内的超时、取消和数据传递。通过函数如 WithCancel、WithTimeout 和 WithValue，开发者可高效处理并发任务和资源释放，是构建健壮程序的重要组件。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/go/go-context","author":"$18"}
d:{"title":"深入理解 Go 的 Context 包","date":"2024-11-18T00:00:00.000Z","tags":"$e","draft":false,"summary":"Go 的 context 包提供了强大的工具，用于管理请求范围内的超时、取消和数据传递。通过函数如 WithCancel、WithTimeout 和 WithValue，开发者可高效处理并发任务和资源释放，是构建健壮程序的重要组件。","layout":"PostSimple","type":"Blog","readingTime":"$f","slug":"go/go-context","path":"blog/go/go-context","filePath":"blog/go/go-context.mdx","toc":"$10","structuredData":"$17"}
1b:["backend","go"]
1c:{"text":"9 min read","minutes":8.22,"time":493200,"words":1644}
1e:{"value":"前提条件","url":"#前提条件","depth":2}
1f:{"value":"开始使用","url":"#开始使用","depth":2}
1d:["$1e","$1f"]
22:{"@type":"Person","name":"mainJayLai"}
21:["$22"]
20:{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用Redis实现Golang API限流","datePublished":"2024-11-15T00:00:00.000Z","dateModified":"2024-11-15T00:00:00.000Z","description":"这篇文章介绍了如何使用Redis在Golang API中实现限流功能。通过Gin框架搭建HTTP服务器，利用go-redis/redis_rate包来追踪和限制每个IP地址的请求频率。文章通过实例代码展示了如何设置每分钟10次的请求限制，并详细说明了限流器的工作原理和实现方法。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/go/redis-ratelimit","author":"$21"}
1a:{"title":"使用Redis实现Golang API限流","date":"2024-11-15T00:00:00.000Z","tags":"$1b","draft":false,"summary":"这篇文章介绍了如何使用Redis在Golang API中实现限流功能。通过Gin框架搭建HTTP服务器，利用go-redis/redis_rate包来追踪和限制每个IP地址的请求频率。文章通过实例代码展示了如何设置每分钟10次的请求限制，并详细说明了限流器的工作原理和实现方法。","layout":"PostSimple","type":"Blog","readingTime":"$1c","slug":"go/redis-ratelimit","path":"blog/go/redis-ratelimit","filePath":"blog/go/redis-ratelimit.mdx","toc":"$1d","structuredData":"$20"}
24:["docker","backend"]
25:{"text":"16 min read","minutes":15.725,"time":943500,"words":3145}
27:{"value":"什么是联合文件系统？","url":"#什么是联合文件系统","depth":2}
28:{"value":"为什么要使用联合文件系统？","url":"#为什么要使用联合文件系统","depth":2}
29:{"value":"它是如何工作的？","url":"#它是如何工作的","depth":2}
2a:{"value":"实际尝试","url":"#实际尝试","depth":2}
2b:{"value":"结论","url":"#结论-4","depth":2}
26:["$27","$28","$29","$2a","$2b"]
2e:{"@type":"Person","name":"mainJayLai"}
2d:["$2e"]
2c:{"@context":"https://schema.org","@type":"BlogPosting","headline":"深入Docker内部原理 - 联合文件系统","datePublished":"2024-11-14T00:00:00.000Z","dateModified":"2024-11-14T00:00:00.000Z","description":"Docker的联合文件系统（如OverlayFS）通过将多个只读镜像层和一个可写容器层合并为一个虚拟文件系统，实现了高效的资源共享和容器隔离。利用写时复制（CoW）技术，容器只在修改文件时复制数据，节省了存储和提高了性能。理解这些原理有助于优化Docker的使用，尤其是在性能和安全性方面。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/docker/union-filesystem","author":"$2d"}
23:{"title":"深入Docker内部原理 - 联合文件系统","date":"2024-11-14T00:00:00.000Z","tags":"$24","draft":false,"summary":"Docker的联合文件系统（如OverlayFS）通过将多个只读镜像层和一个可写容器层合并为一个虚拟文件系统，实现了高效的资源共享和容器隔离。利用写时复制（CoW）技术，容器只在修改文件时复制数据，节省了存储和提高了性能。理解这些原理有助于优化Docker的使用，尤其是在性能和安全性方面。","layout":"PostSimple","type":"Blog","readingTime":"$25","slug":"docker/union-filesystem","path":"blog/docker/union-filesystem","filePath":"blog/docker/union-filesystem.mdx","toc":"$26","structuredData":"$2c"}
30:["frontend","javascript"]
31:{"text":"18 min read","minutes":17.29,"time":1037400,"words":3458}
33:{"value":"1. 纯函数","url":"#1-纯函数","depth":2}
34:{"value":"2. 不变性","url":"#2-不变性","depth":2}
35:{"value":"3. 柯里化","url":"#3-柯里化","depth":2}
36:{"value":"4. 记忆化","url":"#4-记忆化","depth":2}
37:{"value":"5. 单子","url":"#5-单子","depth":2}
38:{"value":"6. 这些概念如何相互关联","url":"#6-这些概念如何相互关联","depth":2}
39:{"value":"结论","url":"#结论-5","depth":4}
32:["$33","$34","$35","$36","$37","$38","$39"]
3c:{"@type":"Person","name":"mainJayLai"}
3b:["$3c"]
3a:{"@context":"https://schema.org","@type":"BlogPosting","headline":"深入探讨 JavaScript 中的函数式编程","datePublished":"2024-11-14T00:00:00.000Z","dateModified":"2024-11-14T00:00:00.000Z","description":"本文深入探讨了 JavaScript 中的函数式编程，重点介绍了纯函数、不变性、柯里化、记忆化和单子等概念。通过这些技术，开发者可以编写更加可预测、可维护和高效的代码。文章展示了如何通过这些概念协同工作，提升代码的可靠性、复用性和性能，是理解和应用函数式编程的重要指南。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/frontend/javascript-function","author":"$3b"}
2f:{"title":"深入探讨 JavaScript 中的函数式编程","date":"2024-11-14T00:00:00.000Z","tags":"$30","draft":false,"summary":"本文深入探讨了 JavaScript 中的函数式编程，重点介绍了纯函数、不变性、柯里化、记忆化和单子等概念。通过这些技术，开发者可以编写更加可预测、可维护和高效的代码。文章展示了如何通过这些概念协同工作，提升代码的可靠性、复用性和性能，是理解和应用函数式编程的重要指南。","layout":"PostSimple","type":"Blog","readingTime":"$31","slug":"frontend/javascript-function","path":"blog/frontend/javascript-function","filePath":"blog/frontend/javascript-function.mdx","toc":"$32","structuredData":"$3a"}
3e:["page","9","d"]
0:["Ts-6BBsjdSlBnGT_Ikyc2",[[["",{"children":["blog",{"children":["page",{"children":[["page","9","d"],{"children":["__PAGE__?{\"page\":\"9\"}",{}]}]}]}]},"$undefined","$undefined",true],["",{"children":["blog",{"children":["page",{"children":[["page","9","d"],{"children":["__PAGE__",{},[["$L1",["$","$L2",null,{"posts":[{"title":"OAuth 图解指南：从零开始理解授权流程","date":"2025-10-24T00:00:00.000Z","tags":["backend","security"],"draft":false,"summary":"本文通过图解的方式详细介绍 OAuth 授权流程，从 OAuth 的诞生背景、工作原理、安全机制到实际应用，帮助你全面理解这一复杂但重要的授权标准。文章涵盖用户同意流程、授权码流程、客户端注册、前后端通道等核心概念。","layout":"PostSimple","type":"Blog","readingTime":{"text":"22 min read","minutes":21.03,"time":1261800,"words":4206},"slug":"backend/oauth-illustrated-guide","path":"blog/backend/oauth-illustrated-guide","filePath":"blog/backend/oauth-illustrated-guide.mdx","toc":[{"value":"目录","url":"#目录-5","depth":2},{"value":"OAuth 如何工作","url":"#oauth-如何工作","depth":2},{"value":"OAuth 流程，第一遍","url":"#oauth-流程第一遍","depth":3},{"value":"最终目标是获得访问令牌","url":"#最终目标是获得访问令牌","depth":3},{"value":"关于安全性的说明","url":"#关于安全性的说明","depth":3},{"value":"OAuth 的两个部分","url":"#oauth-的两个部分","depth":2},{"value":"OAuth 流程，第二遍","url":"#oauth-流程第二遍","depth":2},{"value":"注册新应用","url":"#注册新应用","depth":2},{"value":"前端通道和后端通道","url":"#前端通道和后端通道","depth":2},{"value":"一些最后的想法","url":"#一些最后的想法","depth":2},{"value":"总结","url":"#总结-4","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"OAuth 图解指南：从零开始理解授权流程","datePublished":"2025-10-24T00:00:00.000Z","dateModified":"2025-10-24T00:00:00.000Z","description":"本文通过图解的方式详细介绍 OAuth 授权流程，从 OAuth 的诞生背景、工作原理、安全机制到实际应用，帮助你全面理解这一复杂但重要的授权标准。文章涵盖用户同意流程、授权码流程、客户端注册、前后端通道等核心概念。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/backend/oauth-illustrated-guide","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"使用公平队列防止多租户服务中的吵闹邻居问题","date":"2025-09-25T00:00:00.000Z","tags":["system"],"draft":false,"summary":"本文介绍了在多租户系统中使用公平队列来防止“吵闹邻居”问题，通过Broccoli队列系统实现，确保所有客户公平获得资源。","layout":"PostSimple","type":"Blog","readingTime":{"text":"8 min read","minutes":7.32,"time":439200,"words":1464},"slug":"system/fair-queueing","path":"blog/system/fair-queueing","filePath":"blog/system/fair-queueing.mdx","toc":[{"value":"“吵闹邻居”问题的剖析","url":"#吵闹邻居问题的剖析","depth":2},{"value":"为什么传统修复方案不足","url":"#为什么传统修复方案不足","depth":2},{"value":"A. 节流客户端","url":"#a-节流客户端","depth":3},{"value":"B. 专用工人队列","url":"#b-专用工人队列","depth":3},{"value":"解决方案：公平队列","url":"#解决方案公平队列","depth":2},{"value":"Broccoli 如何实现公平性","url":"#broccoli-如何实现公平性","depth":2},{"value":"当消息到达时（插入操作）：","url":"#当消息到达时插入操作","depth":3},{"value":"当工人准备好处理时（读取操作）：","url":"#当工人准备好处理时读取操作","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用公平队列防止多租户服务中的吵闹邻居问题","datePublished":"2025-09-25T00:00:00.000Z","dateModified":"2025-09-25T00:00:00.000Z","description":"本文介绍了在多租户系统中使用公平队列来防止“吵闹邻居”问题，通过Broccoli队列系统实现，确保所有客户公平获得资源。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/system/fair-queueing","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"GPU网络通信基础","date":"2025-09-05T00:00:00.000Z","tags":["ai","gpu"],"draft":false,"summary":"深入解析大规模AI训练中的GPU网络通信原理、架构设计与优化策略，包括Scale Out/Up方案、层次化交换机拓扑以及通信模式。","layout":"PostSimple","type":"Blog","readingTime":{"text":"15 min read","minutes":14.13,"time":847800,"words":2826},"slug":"ai/gpu-networking-basics","path":"blog/ai/gpu-networking-basics","filePath":"blog/ai/gpu-networking-basics.mdx","toc":[{"value":"目录","url":"#目录","depth":2},{"value":"背景动机","url":"#背景动机","depth":2},{"value":"网络交换机","url":"#网络交换机","depth":2},{"value":"叶脊拓扑结构","url":"#叶脊拓扑结构","depth":3},{"value":"横向扩展(Scale Out)","url":"#横向扩展scale-out","depth":2},{"value":"纵向扩展(Scale Up)","url":"#纵向扩展scale-up","depth":2},{"value":"节点内通信与节点间通信","url":"#节点内通信与节点间通信","depth":3},{"value":"训练过程中的通信","url":"#训练过程中的通信","depth":2},{"value":"结论","url":"#结论","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"GPU网络通信基础","datePublished":"2025-09-05T00:00:00.000Z","dateModified":"2025-09-05T00:00:00.000Z","description":"深入解析大规模AI训练中的GPU网络通信原理、架构设计与优化策略，包括Scale Out/Up方案、层次化交换机拓扑以及通信模式。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/ai/gpu-networking-basics","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"深入理解 Go 的内存对齐与分配机制","date":"2025-08-20T00:00:00.000Z","tags":["backend","go"],"draft":false,"summary":"文章深入介绍了 Go 语言中的内存对齐与内存分配机制，从原理到实践结合示例，展示如何通过结构体字段优化、对象池使用等手段提升性能并减少内存浪费。","layout":"PostSimple","type":"Blog","readingTime":{"text":"7 min read","minutes":6.84,"time":410400,"words":1368},"slug":"go/go-memory-alignment-and-allocation","path":"blog/go/go-memory-alignment-and-allocation","filePath":"blog/go/go-memory-alignment-and-allocation.mdx","toc":[{"value":"一、引言：为什么你需要关心内存对齐和分配？","url":"#一引言为什么你需要关心内存对齐和分配","depth":2},{"value":"二、内存对齐机制详解","url":"#二内存对齐机制详解","depth":2},{"value":"1. 什么是内存对齐？","url":"#1-什么是内存对齐","depth":3},{"value":"2. Go 中的对齐规则","url":"#2-go-中的对齐规则","depth":3},{"value":"3. 示例：字段排列的影响","url":"#3-示例字段排列的影响","depth":3},{"value":"三、Go 的内存分配策略","url":"#三go-的内存分配策略","depth":2},{"value":"1. 内存分配流程","url":"#1-内存分配流程","depth":3},{"value":"2. 分配层级结构","url":"#2-分配层级结构","depth":3},{"value":"3. 示例：小对象与大对象","url":"#3-示例小对象与大对象","depth":3},{"value":"四、实践案例","url":"#四实践案例","depth":2},{"value":"案例 1：结构体内存优化","url":"#案例-1结构体内存优化","depth":3},{"value":"案例 2：减少 GC 压力","url":"#案例-2减少-gc-压力","depth":3},{"value":"五、深入探索","url":"#五深入探索","depth":2},{"value":"1. Cache Line 与伪共享","url":"#1-cache-line-与伪共享","depth":3},{"value":"2. GC 与内存分配器源码","url":"#2-gc-与内存分配器源码","depth":3},{"value":"3. 内存分析工具","url":"#3-内存分析工具","depth":3},{"value":"4. 逃逸分析","url":"#4-逃逸分析","depth":3},{"value":"六、结语","url":"#六结语","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"深入理解 Go 的内存对齐与分配机制","datePublished":"2025-08-20T00:00:00.000Z","dateModified":"2025-08-20T00:00:00.000Z","description":"文章深入介绍了 Go 语言中的内存对齐与内存分配机制，从原理到实践结合示例，展示如何通过结构体字段优化、对象池使用等手段提升性能并减少内存浪费。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/go/go-memory-alignment-and-allocation","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"n8n 深度调研与 AI Agent 架构选型报告","date":"2025-06-20T00:00:00.000Z","tags":["tools"],"draft":false,"summary":"本报告旨在对工作流自动化工具 n8n 进行深度调研，并在此基础上，探讨如何构建自定义 AI Agent 的最佳实践与架构选型。","layout":"PostSimple","type":"Blog","readingTime":{"text":"17 min read","minutes":16.425,"time":985500,"words":3285},"slug":"tools/n8n-introduction","path":"blog/tools/n8n-introduction","filePath":"blog/tools/n8n-introduction.mdx","toc":[{"value":"摘要","url":"#摘要-3","depth":2},{"value":"第一章：n8n 核心概念与学习资源","url":"#第一章n8n-核心概念与学习资源","depth":2},{"value":"1.1 n8n 是什么？","url":"#11-n8n-是什么","depth":3},{"value":"1.2 核心优势","url":"#12-核心优势","depth":3},{"value":"1.3 推荐视频教程","url":"#13-推荐视频教程","depth":3},{"value":"第二章：n8n 源码与自定义节点开发","url":"#第二章n8n-源码与自定义节点开发","depth":2},{"value":"2.1 源码结构分析","url":"#21-源码结构分析","depth":3},{"value":"2.2 节点实现原理","url":"#22-节点实现原理","depth":3},{"value":"2.3 如何开发自定义节点(插件)","url":"#23-如何开发自定义节点插件","depth":3},{"value":"第三章：构建 AI Agent：n8n vs. 专用框架","url":"#第三章构建-ai-agentn8n-vs-专用框架","depth":2},{"value":"3.1 在 n8n 中构建 Agent","url":"#31-在-n8n-中构建-agent","depth":3},{"value":"3.2 主流独立 Agent 框架概览","url":"#32-主流独立-agent-框架概览","depth":3},{"value":"3.3 对比分析","url":"#33-对比分析","depth":3},{"value":"第四章：架构设计与技术选型建议","url":"#第四章架构设计与技术选型建议","depth":2},{"value":"4.1 设计原则：分离编排与智能","url":"#41-设计原则分离编排与智能","depth":3},{"value":"4.2 推荐架构：n8n + Python Agent 服务","url":"#42-推荐架构n8n--python-agent-服务","depth":3},{"value":"4.3 技术选型指南","url":"#43-技术选型指南","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"n8n 深度调研与 AI Agent 架构选型报告","datePublished":"2025-06-20T00:00:00.000Z","dateModified":"2025-06-20T00:00:00.000Z","description":"本报告旨在对工作流自动化工具 n8n 进行深度调研，并在此基础上，探讨如何构建自定义 AI Agent 的最佳实践与架构选型。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/tools/n8n-introduction","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"Amazon VPC图解指南：为什么它被称为云，如果它不是云？","date":"2025-06-13T00:00:00.000Z","tags":["system","cloud"],"draft":false,"summary":"本文深入浅出地介绍了Amazon VPC（虚拟私有云）的工作原理和设计初衷。通过生动的图解和幽默的比喻，解释了为什么VPC是AWS基础架构的核心组件，以及它如何通过映射服务实现网络隔离和私有IP空间的管理，帮助用户构建安全、灵活的云基础设施。","layout":"PostSimple","type":"Blog","readingTime":{"text":"14 min read","minutes":13.17,"time":790200,"words":2634},"slug":"system/aws-vpc","path":"blog/system/aws-vpc","filePath":"blog/system/aws-vpc.mdx","toc":[{"value":"为什么需要VPC？","url":"#为什么需要vpc","depth":2},{"value":"IP地址冲突问题","url":"#ip地址冲突问题","depth":2},{"value":"为什么叫VPC而不是看不见的云！","url":"#为什么叫vpc而不是看不见的云","depth":2},{"value":"这就是VPC背后的核心思想：每个人在AWS内部都获得自己的私有网络。","url":"#这就是vpc背后的核心思想每个人在aws内部都获得自己的私有网络","depth":4},{"value":"VPC是什么？","url":"#vpc是什么","depth":2},{"value":"映射服务","url":"#映射服务","depth":3},{"value":"映射服务就是隔离我们的服务器的关键。","url":"#映射服务就是隔离我们的服务器的关键","depth":4},{"value":"Terraform代码","url":"#terraform代码","depth":2},{"value":"总结","url":"#总结-15","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Amazon VPC图解指南：为什么它被称为云，如果它不是云？","datePublished":"2025-06-13T00:00:00.000Z","dateModified":"2025-06-13T00:00:00.000Z","description":"本文深入浅出地介绍了Amazon VPC（虚拟私有云）的工作原理和设计初衷。通过生动的图解和幽默的比喻，解释了为什么VPC是AWS基础架构的核心组件，以及它如何通过映射服务实现网络隔离和私有IP空间的管理，帮助用户构建安全、灵活的云基础设施。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/system/aws-vpc","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"大型语言模型 (LLM) 与人工智能体 (Agent) 技术深度研究报告","date":"2025-05-27T00:00:00.000Z","tags":["ai"],"draft":false,"summary":"本报告系统梳理了 LLM 与 AI Agent 的核心概念、架构模块、工作流设计及选型评估，兼顾理论深度与实际应用示例。","layout":"PostSimple","type":"Blog","readingTime":{"text":"53 min read","minutes":52.485,"time":3149100,"words":10497},"slug":"ai/llm-agent","path":"blog/ai/llm-agent","filePath":"blog/ai/llm-agent.mdx","toc":[{"value":"目录","url":"#目录-1","depth":2},{"value":"I. 大型语言模型 (LLM) 简介","url":"#i-大型语言模型-llm-简介","depth":2},{"value":"A. 定义 LLM：核心概念与能力","url":"#a-定义-llm核心概念与能力","depth":3},{"value":"B. 底层架构：Transformer 模型","url":"#b-底层架构transformer-模型","depth":3},{"value":"1. 编码器-解码器结构","url":"#1-编码器-解码器结构","depth":4},{"value":"2. 自注意力机制 (Self-Attention Mechanism)","url":"#2-自注意力机制-self-attention-mechanism","depth":4},{"value":"C. LLM 的工作方式：训练、微调与提示 (Prompting)","url":"#c-llm-的工作方式训练微调与提示-prompting","depth":3},{"value":"D. LLM 的类型与应用","url":"#d-llm-的类型与应用","depth":3},{"value":"II. 人工智能体 (AI Agent) 基础","url":"#ii-人工智能体-ai-agent-基础","depth":2},{"value":"A. 定义 AI Agent：自主性与目标导向行为","url":"#a-定义-ai-agent自主性与目标导向行为","depth":3},{"value":"B. AI Agent 的核心组件","url":"#b-ai-agent-的核心组件","depth":3},{"value":"1. 感知：感知环境","url":"#1-感知感知环境","depth":4},{"value":"2. 推理与规划：决策核心","url":"#2-推理与规划决策核心","depth":4},{"value":"3. 行动：与环境交互","url":"#3-行动与环境交互","depth":4},{"value":"4. 学习：适应与改进","url":"#4-学习适应与改进","depth":4},{"value":"C. AI Agent 的分类","url":"#c-ai-agent-的分类","depth":3},{"value":"III. 主流 AI Agent 架构与核心模块","url":"#iii-主流-ai-agent-架构与核心模块","depth":2},{"value":"A. 关键架构模块","url":"#a-关键架构模块","depth":3},{"value":"1. 感知模块 (输入处理与理解)","url":"#1-感知模块-输入处理与理解","depth":4},{"value":"2. 记忆与上下文存储 (短期、长期、外部)","url":"#2-记忆与上下文存储-短期长期外部","depth":4},{"value":"3. 规划与推理引擎","url":"#3-规划与推理引擎","depth":4},{"value":"4. 决策模块","url":"#4-决策模块","depth":4},{"value":"5. 执行层与工具使用 (行动引擎)","url":"#5-执行层与工具使用-行动引擎","depth":4},{"value":"6. 学习与反馈循环","url":"#6-学习与反馈循环","depth":4},{"value":"IV. AI Agent 与 Agentic Workflow (智能体工作流)","url":"#iv-ai-agent-与-agentic-workflow-智能体工作流","depth":2},{"value":"A. 定义 Agentic Workflow：超越单个智能体","url":"#a-定义-agentic-workflow超越单个智能体","depth":3},{"value":"B. 关键区别：自主性、复杂性、主动性、多智能体协作","url":"#b-关键区别自主性复杂性主动性多智能体协作","depth":3},{"value":"C. Agentic Workflow 的核心组件","url":"#c-agentic-workflow-的核心组件","depth":3},{"value":"D. Agentic Workflow 中的常见设计模式","url":"#d-agentic-workflow-中的常见设计模式","depth":3},{"value":"V. AI Agent 的 LLM 模型选型","url":"#v-ai-agent-的-llm-模型选型","depth":2},{"value":"A. 选型标准","url":"#a-选型标准","depth":3},{"value":"B. Agentic系统中LLM的关键评估指标","url":"#b-agentic系统中llm的关键评估指标","depth":3},{"value":"C. 主流 LLM 在 Agent 开发中的比较","url":"#c-主流-llm-在-agent-开发中的比较","depth":3},{"value":"VI. 主流 Agent 实现方案调研","url":"#vi-主流-agent-实现方案调研","depth":2},{"value":"A. Agent 构建框架","url":"#a-agent-构建框架","depth":3},{"value":"1. Langchain","url":"#1-langchain","depth":4},{"value":"a. 设计理念与核心组件","url":"#a-设计理念与核心组件","depth":5},{"value":"b. 工作原理与简单应用示例","url":"#b-工作原理与简单应用示例","depth":5},{"value":"2. AutoGen (Microsoft)","url":"#2-autogen-microsoft","depth":4},{"value":"a. 架构：独立与分布式运行时","url":"#a-架构独立与分布式运行时","depth":5},{"value":"b. 特性","url":"#b-特性","depth":5},{"value":"c. 优缺点与应用场景","url":"#c-优缺点与应用场景","depth":5},{"value":"3. CrewAI","url":"#3-crewai","depth":4},{"value":"a. 架构：Agent、任务、工具、流程、团队 (Crew)","url":"#a-架构agent任务工具流程团队-crew","depth":5},{"value":"b. 特性","url":"#b-特性-1","depth":5},{"value":"c. 优缺点与应用场景","url":"#c-优缺点与应用场景-1","depth":5},{"value":"B. 值得关注的 Agentic 系统与产品","url":"#b-值得关注的-agentic-系统与产品","depth":3},{"value":"1. Microsoft JARVIS (实为 Outshift JARVIS)","url":"#1-microsoft-jarvis-实为-outshift-jarvis","depth":4},{"value":"a. 架构","url":"#a-架构","depth":5},{"value":"b. 关键技术","url":"#b-关键技术","depth":5},{"value":"2. BabyAGI","url":"#2-babyagi","depth":4},{"value":"a. 核心架构","url":"#a-核心架构","depth":5},{"value":"3. 其他有影响力的商业 AI Agent 产品概览 (2024-2025)","url":"#3-其他有影响力的商业-ai-agent-产品概览-2024-2025","depth":4},{"value":"VII. 模型上下文协议 (Model Context Protocol, MCP)","url":"#vii-模型上下文协议-model-context-protocol-mcp","depth":2},{"value":"A. MCP 简介：标准化 Agent-Tool 交互","url":"#a-mcp-简介标准化-agent-tool-交互","depth":3},{"value":"B. MCP 架构：客户端-服务器模型 (主机、客户端、服务器)","url":"#b-mcp-架构客户端-服务器模型-主机客户端服务器","depth":3},{"value":"C. 消息类型与连接生命周期","url":"#c-消息类型与连接生命周期","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"大型语言模型 (LLM) 与人工智能体 (Agent) 技术深度研究报告","datePublished":"2025-05-27T00:00:00.000Z","dateModified":"2025-05-27T00:00:00.000Z","description":"本报告系统梳理了 LLM 与 AI Agent 的核心概念、架构模块、工作流设计及选型评估，兼顾理论深度与实际应用示例。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/ai/llm-agent","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"核心开发者的Git配置秘籍","date":"2025-05-23T00:00:00.000Z","tags":["tools","git"],"draft":false,"summary":"本文详细介绍了Git核心开发者常用但鲜为人知的Git配置选项，包括分支显示优化、差异对比增强、推送和拉取改进等。通过这些配置，你可以显著提升Git使用体验，减少常见错误，提高工作效率。文章将这些配置分为三类：明显改进体验的必备配置、无害且有时有用的配置，以及基于个人喜好的可选配置。","layout":"PostSimple","type":"Blog","readingTime":{"text":"18 min read","minutes":17.535,"time":1052100,"words":3507},"slug":"tools/git-enhanced-configuration","path":"blog/tools/git-enhanced-configuration","filePath":"blog/tools/git-enhanced-configuration.mdx","toc":[{"value":"引言","url":"#引言-6","depth":2},{"value":"明显改进Git体验的必备配置","url":"#明显改进git体验的必备配置","depth":2},{"value":"优化分支和标签显示","url":"#优化分支和标签显示","depth":3},{"value":"分支按提交日期排序","url":"#分支按提交日期排序","depth":4},{"value":"标签按版本号排序","url":"#标签按版本号排序","depth":4},{"value":"设置默认分支名称","url":"#设置默认分支名称","depth":3},{"value":"增强差异比较功能","url":"#增强差异比较功能","depth":3},{"value":"使用更智能的差异算法","url":"#使用更智能的差异算法","depth":4},{"value":"代码移动的彩色显示","url":"#代码移动的彩色显示","depth":4},{"value":"助记符前缀和重命名检测","url":"#助记符前缀和重命名检测","depth":4},{"value":"改进推送行为","url":"#改进推送行为","depth":3},{"value":"智能上游设置","url":"#智能上游设置","depth":4},{"value":"自动推送标签","url":"#自动推送标签","depth":4},{"value":"改进获取行为","url":"#改进获取行为","depth":3},{"value":"无害且有时有用的配置","url":"#无害且有时有用的配置","depth":2},{"value":"自动纠正命令","url":"#自动纠正命令","depth":3},{"value":"提交时显示差异","url":"#提交时显示差异","depth":3},{"value":"重用已解决的冲突","url":"#重用已解决的冲突","depth":3},{"value":"全局忽略文件","url":"#全局忽略文件","depth":3},{"value":"改进变基体验","url":"#改进变基体验","depth":3},{"value":"基于个人喜好的可选配置","url":"#基于个人喜好的可选配置","depth":2},{"value":"改进合并冲突显示","url":"#改进合并冲突显示","depth":3},{"value":"拉取时自动变基","url":"#拉取时自动变基","depth":3},{"value":"文件系统监控","url":"#文件系统监控","depth":3},{"value":"实际应用场景","url":"#实际应用场景","depth":2},{"value":"场景一：处理特性分支","url":"#场景一处理特性分支","depth":3},{"value":"场景二：代码重构","url":"#场景二代码重构","depth":3},{"value":"场景三：多人协作","url":"#场景三多人协作","depth":3},{"value":"结语","url":"#结语-1","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"核心开发者的Git配置秘籍","datePublished":"2025-05-23T00:00:00.000Z","dateModified":"2025-05-23T00:00:00.000Z","description":"本文详细介绍了Git核心开发者常用但鲜为人知的Git配置选项，包括分支显示优化、差异对比增强、推送和拉取改进等。通过这些配置，你可以显著提升Git使用体验，减少常见错误，提高工作效率。文章将这些配置分为三类：明显改进体验的必备配置、无害且有时有用的配置，以及基于个人喜好的可选配置。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/tools/git-enhanced-configuration","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"揭秘恶意软件中的代码混淆把戏：深入原理与实例","date":"2025-05-09T00:00:00.000Z","tags":["network security"],"draft":false,"summary":"恶意软件开发者常利用代码混淆技术来规避检测、隐藏真实意图。本文将深入剖析常见的混淆手段，如字符串编码、动态代码执行、控制流平坦化等，并通过实例揭示其工作原理，帮助开发者和安全研究员更好地识别和防范这些威胁。","layout":"PostSimple","type":"Blog","readingTime":{"text":"26 min read","minutes":25.04,"time":1502400,"words":5008},"slug":"security/demystifying-obfuscation-techniques-in-malware","path":"blog/security/demystifying-obfuscation-techniques-in-malware","filePath":"blog/security/demystifying-obfuscation-techniques-in-malware.mdx","toc":[{"value":"引言：看不见的威胁","url":"#引言看不见的威胁","depth":2},{"value":"什么是代码混淆？","url":"#什么是代码混淆","depth":2},{"value":"常见的代码混淆技术及其原理剖析","url":"#常见的代码混淆技术及其原理剖析","depth":2},{"value":"1. 字符串编码与字符操纵 (Encoded Strings & Character Manipulation)","url":"#1-字符串编码与字符操纵-encoded-strings--character-manipulation","depth":3},{"value":"2. 动态代码生成与执行 (Dynamic Code Generation & Execution)","url":"#2-动态代码生成与执行-dynamic-code-generation--execution","depth":3},{"value":"3. 基于数组的字符串混淆与移位 (Array-Based String Obfuscation and Shifting)","url":"#3-基于数组的字符串混淆与移位-array-based-string-obfuscation-and-shifting","depth":3},{"value":"4. 控制流混淆 (Control Flow Obfuscation)","url":"#4-控制流混淆-control-flow-obfuscation","depth":3},{"value":"5. 无用代码插入 (Dead Code Insertion)","url":"#5-无用代码插入-dead-code-insertion","depth":3},{"value":"6. 基于环境的混淆/检测 (Environment-Based Obfuscation/Detection)","url":"#6-基于环境的混淆检测-environment-based-obfuscationdetection","depth":3},{"value":"从理论到现实：混淆技术实战","url":"#从理论到现实混淆技术实战","depth":2},{"value":"npm 真实案例分析","url":"#npm-真实案例分析","depth":3},{"value":"PyPI 真实案例分析","url":"#pypi-真实案例分析","depth":3},{"value":"如何应对与防范？","url":"#如何应对与防范","depth":2},{"value":"结论","url":"#结论-11","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"揭秘恶意软件中的代码混淆把戏：深入原理与实例","datePublished":"2025-05-09T00:00:00.000Z","dateModified":"2025-05-09T00:00:00.000Z","description":"恶意软件开发者常利用代码混淆技术来规避检测、隐藏真实意图。本文将深入剖析常见的混淆手段，如字符串编码、动态代码执行、控制流平坦化等，并通过实例揭示其工作原理，帮助开发者和安全研究员更好地识别和防范这些威胁。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/security/demystifying-obfuscation-techniques-in-malware","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"使用Zip炸弹保护您的Web服务器免受恶意爬虫攻击","date":"2025-05-09T00:00:00.000Z","tags":["network security","tools"],"draft":false,"summary":"Zip炸弹是一种有效防御恶意爬虫的非常规方法，通过利用压缩原理，可以让恶意爬虫在解压时消耗大量资源而崩溃。本文详细介绍Zip炸弹的原理、实现方法以及在Web服务器防御中的应用，帮助您更好地保护您的服务器安全。","layout":"PostSimple","type":"Blog","readingTime":{"text":"14 min read","minutes":13.52,"time":811200,"words":2704},"slug":"security/zip-bombs-server-protection","path":"blog/security/zip-bombs-server-protection","filePath":"blog/security/zip-bombs-server-protection.mdx","toc":[{"value":"Zip炸弹：Web服务器防御的秘密武器","url":"#zip炸弹web服务器防御的秘密武器","depth":2},{"value":"什么是Zip炸弹？","url":"#什么是zip炸弹","depth":2},{"value":"Web压缩的基本原理","url":"#web压缩的基本原理","depth":2},{"value":"恶意爬虫同样利用压缩机制","url":"#恶意爬虫同样利用压缩机制","depth":2},{"value":"Zip炸弹的工作原理","url":"#zip炸弹的工作原理","depth":2},{"value":"如何创建Zip炸弹","url":"#如何创建zip炸弹","depth":2},{"value":"在Web服务器中部署Zip炸弹防御","url":"#在web服务器中部署zip炸弹防御","depth":2},{"value":"基于更复杂的启发式规则","url":"#基于更复杂的启发式规则","depth":2},{"value":"Zip炸弹防御的优缺点","url":"#zip炸弹防御的优缺点","depth":2},{"value":"优点","url":"#优点-9","depth":3},{"value":"缺点","url":"#缺点-7","depth":3},{"value":"与其他安全措施的结合","url":"#与其他安全措施的结合","depth":2},{"value":"结论","url":"#结论-14","depth":2},{"value":"常见问题","url":"#常见问题-1","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用Zip炸弹保护您的Web服务器免受恶意爬虫攻击","datePublished":"2025-05-09T00:00:00.000Z","dateModified":"2025-05-09T00:00:00.000Z","description":"Zip炸弹是一种有效防御恶意爬虫的非常规方法，通过利用压缩原理，可以让恶意爬虫在解压时消耗大量资源而崩溃。本文详细介绍Zip炸弹的原理、实现方法以及在Web服务器防御中的应用，帮助您更好地保护您的服务器安全。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/security/zip-bombs-server-protection","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"MacBook高效配置指南：Brewfile、系统设置与Zsh插件","date":"2025-05-09T00:00:00.000Z","tags":["tools","macos"],"draft":false,"summary":"本文详细介绍了如何高效设置新的MacBook，包括使用Brewfile批量安装应用程序和工具、通过defaults命令自定义系统设置以及配置实用的Zsh插件，帮助开发者快速打造个性化且高效的工作环境。","layout":"PostSimple","type":"Blog","readingTime":{"text":"10 min read","minutes":9.025,"time":541500,"words":1805},"slug":"tools/mac-setup-guide","path":"blog/tools/mac-setup-guide","filePath":"blog/tools/mac-setup-guide.mdx","toc":[{"value":"引言","url":"#引言-8","depth":2},{"value":"Brewfile：批量安装应用与工具","url":"#brewfile批量安装应用与工具","depth":2},{"value":"如何创建和使用Brewfile","url":"#如何创建和使用brewfile","depth":3},{"value":"Brewfile示例及详解","url":"#brewfile示例及详解","depth":3},{"value":"使用defaults命令自定义系统设置","url":"#使用defaults命令自定义系统设置","depth":2},{"value":"defaults命令的优势","url":"#defaults命令的优势","depth":3},{"value":"常用defaults命令示例","url":"#常用defaults命令示例","depth":3},{"value":"Zsh插件：提升终端体验","url":"#zsh插件提升终端体验","depth":2},{"value":"五大推荐Zsh插件详解","url":"#五大推荐zsh插件详解","depth":3},{"value":"如何安装和配置Zsh插件","url":"#如何安装和配置zsh插件","depth":3},{"value":"结语","url":"#结语-3","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"MacBook高效配置指南：Brewfile、系统设置与Zsh插件","datePublished":"2025-05-09T00:00:00.000Z","dateModified":"2025-05-09T00:00:00.000Z","description":"本文详细介绍了如何高效设置新的MacBook，包括使用Brewfile批量安装应用程序和工具、通过defaults命令自定义系统设置以及配置实用的Zsh插件，帮助开发者快速打造个性化且高效的工作环境。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/tools/mac-setup-guide","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"DoH恶意流量检测研究","date":"2025-03-31T00:00:00.000Z","tags":["network security"],"draft":false,"summary":"DoH协议提升隐私安全，却为恶意流量提供掩护。检测方法包括统计分析与机器学习，CIRA-CIC-DoHBrw-2020数据集和DoHLyzer工具是研究核心。当前挑战涉及实时检测、数据多样性及隐私平衡。未来需优化模型、更新数据集并探索解释性AI，以应对恶意流量演变。","layout":"PostSimple","type":"Blog","readingTime":{"text":"13 min read","minutes":12.2,"time":732000,"words":2440},"slug":"security/doh-research","path":"blog/security/doh-research","filePath":"blog/security/doh-research.mdx","toc":[{"value":"引言","url":"#引言-4","depth":2},{"value":"背景与重要性","url":"#背景与重要性","depth":2},{"value":"检测方法概述","url":"#检测方法概述","depth":2},{"value":"1. 统计分析方法","url":"#1-统计分析方法","depth":3},{"value":"2. 机器学习方法","url":"#2-机器学习方法","depth":3},{"value":"数据集详情","url":"#数据集详情","depth":2},{"value":"开源代码与工具","url":"#开源代码与工具","depth":2},{"value":"相关论文与研究","url":"#相关论文与研究","depth":2},{"value":"挑战与未来方向","url":"#挑战与未来方向","depth":2},{"value":"结论","url":"#结论-13","depth":2},{"value":"关键引用","url":"#关键引用","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"DoH恶意流量检测研究","datePublished":"2025-03-31T00:00:00.000Z","dateModified":"2025-03-31T00:00:00.000Z","description":"DoH协议提升隐私安全，却为恶意流量提供掩护。检测方法包括统计分析与机器学习，CIRA-CIC-DoHBrw-2020数据集和DoHLyzer工具是研究核心。当前挑战涉及实时检测、数据多样性及隐私平衡。未来需优化模型、更新数据集并探索解释性AI，以应对恶意流量演变。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/security/doh-research","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"DNS over HTTPS (DoH) 简介","date":"2025-03-31T00:00:00.000Z","tags":["network security"],"draft":false,"summary":"DNS over HTTPS (DoH) 是一种通过 HTTPS 协议加密 DNS 查询的技术，与传统明文 DNS 相比，它显著提升了用户隐私和安全性。DoH 能防止窃听、DNS 欺骗和中间人攻击，保护用户浏览习惯不被追踪。目前已被主流浏览器和操作系统广泛支持，成为互联网安全的重要进步。","layout":"PostSimple","type":"Blog","readingTime":{"text":"24 min read","minutes":23.01,"time":1380600,"words":4602},"slug":"security/what-is-doh","path":"blog/security/what-is-doh","filePath":"blog/security/what-is-doh.mdx","toc":[{"value":"什么是 DNS？","url":"#什么是-dns","depth":2},{"value":"传统 DNS 处理过程","url":"#传统-dns-处理过程","depth":2},{"value":"与传统 DNS 相关的安全风险","url":"#与传统-dns-相关的安全风险","depth":2},{"value":"DNS over HTTPS (DoH) 介绍","url":"#dns-over-https-doh-介绍","depth":2},{"value":"DNS over HTTPS (DoH) 在增强隐私和安全方面的重要性","url":"#dns-over-https-doh-在增强隐私和安全方面的重要性","depth":2},{"value":"传统 DNS 与 DNS over HTTPS（DoH）对比","url":"#传统-dns-与-dns-over-httpsdoh对比","depth":2},{"value":"DNS over HTTPS 的好处","url":"#dns-over-https-的好处","depth":2},{"value":"增强隐私和安全性","url":"#增强隐私和安全性","depth":3},{"value":"防止窃听","url":"#防止窃听","depth":3},{"value":"保护浏览习惯","url":"#保护浏览习惯","depth":3},{"value":"防止 DNS 欺骗和中间人攻击","url":"#防止-dns-欺骗和中间人攻击","depth":3},{"value":"DoH 与现代浏览器和操作系统的兼容性和支持","url":"#doh-与现代浏览器和操作系统的兼容性和支持","depth":2},{"value":"网络浏览器","url":"#网络浏览器","depth":3},{"value":"操作系统","url":"#操作系统","depth":3},{"value":"DNS over HTTPS (DoH) 的工作原理","url":"#dns-over-https-doh-的工作原理","depth":2},{"value":"DoH 和 DoT 之间的区别","url":"#doh-和-dot-之间的区别","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"DNS over HTTPS (DoH) 简介","datePublished":"2025-03-31T00:00:00.000Z","dateModified":"2025-03-31T00:00:00.000Z","description":"DNS over HTTPS (DoH) 是一种通过 HTTPS 协议加密 DNS 查询的技术，与传统明文 DNS 相比，它显著提升了用户隐私和安全性。DoH 能防止窃听、DNS 欺骗和中间人攻击，保护用户浏览习惯不被追踪。目前已被主流浏览器和操作系统广泛支持，成为互联网安全的重要进步。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/security/what-is-doh","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"为什么 Go 语言的错误处理如此出色","date":"2025-03-28T00:00:00.000Z","tags":["backend","go"],"draft":false,"summary":"Go 的 if err != nil 错误处理模式虽备受争议，却是其设计优势所在。通过将错误视为值，Go 迫使开发者显式处理错误情况，避免了隐藏的控制流，提供了清晰的错误传播链。这种方式虽看似繁琐，却让程序更可靠、透明、可预测，并赋予开发者对错误处理的完全控制权。","layout":"PostSimple","type":"Blog","readingTime":{"text":"12 min read","minutes":11.4,"time":684000,"words":2280},"slug":"go/why-go-error-handling-is-awesome","path":"blog/go/why-go-error-handling-is-awesome","filePath":"blog/go/why-go-error-handling-is-awesome.mdx","toc":[{"value":"Go 的错误处理哲学","url":"#go-的错误处理哲学","depth":2},{"value":"其他语言的做法：抛出异常","url":"#其他语言的做法抛出异常","depth":2},{"value":"为什么 Go 不使用异常进行错误处理","url":"#为什么-go-不使用异常进行错误处理","depth":2},{"value":"Go 的禅理","url":"#go-的禅理","depth":3},{"value":"基于异常的代码通常不透明","url":"#基于异常的代码通常不透明","depth":3},{"value":"Go 错误语法的好处","url":"#go-错误语法的好处","depth":2},{"value":"轻松创建可操作的错误链","url":"#轻松创建可操作的错误链","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"为什么 Go 语言的错误处理如此出色","datePublished":"2025-03-28T00:00:00.000Z","dateModified":"2025-03-28T00:00:00.000Z","description":"Go 的 if err != nil 错误处理模式虽备受争议，却是其设计优势所在。通过将错误视为值，Go 迫使开发者显式处理错误情况，避免了隐藏的控制流，提供了清晰的错误传播链。这种方式虽看似繁琐，却让程序更可靠、透明、可预测，并赋予开发者对错误处理的完全控制权。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/go/why-go-error-handling-is-awesome","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"Kafka 基础知识","date":"2025-02-19T00:00:00.000Z","tags":["backend"],"draft":false,"summary":"Kafka 是构建流式架构的强大工具。本文旨在介绍该技术及其相关的数据生产者和消费者。","layout":"PostSimple","type":"Blog","readingTime":{"text":"26 min read","minutes":25.64,"time":1538400,"words":5128},"slug":"backend/kafka-basic","path":"blog/backend/kafka-basic","filePath":"blog/backend/kafka-basic.mdx","toc":[{"value":"关于 Kafka","url":"#关于-kafka","depth":2},{"value":"内部结构和术语","url":"#内部结构和术语","depth":2},{"value":"生产者和消费者","url":"#生产者和消费者","depth":2},{"value":"生产者","url":"#生产者","depth":3},{"value":"消费者","url":"#消费者","depth":3},{"value":"偏移量","url":"#偏移量","depth":3},{"value":"保留和压缩","url":"#保留和压缩","depth":2},{"value":"模式和原则","url":"#模式和原则","depth":2},{"value":"最终一致性架构","url":"#最终一致性架构","depth":3},{"value":"优化对本地数据库的写入","url":"#优化对本地数据库的写入","depth":3},{"value":"主题之间的参照完整性","url":"#主题之间的参照完整性","depth":3},{"value":"有状态处理","url":"#有状态处理","depth":2},{"value":"缓存策略和并行性","url":"#缓存策略和并行性","depth":3},{"value":"总结","url":"#总结-2","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kafka 基础知识","datePublished":"2025-02-19T00:00:00.000Z","dateModified":"2025-02-19T00:00:00.000Z","description":"Kafka 是构建流式架构的强大工具。本文旨在介绍该技术及其相关的数据生产者和消费者。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/backend/kafka-basic","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"DNS 隧道滥用扩展到跟踪和扫描受害者","date":"2025-02-17T00:00:00.000Z","tags":["network security"],"draft":false,"summary":"DNS 隧道技术被攻击者滥用，不仅用于传统的C2通信，还用于跟踪和扫描受害者网络。通过编码IP地址和时间戳，攻击者能够发现并利用开放解析器的漏洞。防止此类攻击的关键在于限制解析器的服务范围并及时更新软件。","layout":"PostSimple","type":"Blog","readingTime":{"text":"7 min read","minutes":6.975,"time":418500,"words":1395},"slug":"security/dns-tunneling-analysis","path":"blog/security/dns-tunneling-analysis","filePath":"blog/security/dns-tunneling-analysis.mdx","toc":[{"value":"DNS 隧道的工作原理","url":"#dns-隧道的工作原理","depth":2},{"value":"用于跟踪的 DNS 隧道","url":"#用于跟踪的-dns-隧道","depth":2},{"value":"用于扫描的 DNS 隧道","url":"#用于扫描的-dns-隧道","depth":2},{"value":"缓解恶意 DNS 行为","url":"#缓解恶意-dns-行为","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"DNS 隧道滥用扩展到跟踪和扫描受害者","datePublished":"2025-02-17T00:00:00.000Z","dateModified":"2025-02-17T00:00:00.000Z","description":"DNS 隧道技术被攻击者滥用，不仅用于传统的C2通信，还用于跟踪和扫描受害者网络。通过编码IP地址和时间戳，攻击者能够发现并利用开放解析器的漏洞。防止此类攻击的关键在于限制解析器的服务范围并及时更新软件。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/security/dns-tunneling-analysis","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"DNS 隧道：DNS 如何被恶意行为者滥用","date":"2025-02-17T00:00:00.000Z","tags":["network security"],"draft":false,"summary":"DNS隧道是一种利用DNS协议进行数据渗透和命令控制通信的技术。由于DNS的普遍性和开放性，恶意行为者可以通过创建隐蔽的通信渠道来绕过网络安全措施。防御措施包括监控异常DNS查询和加强系统安全。","layout":"PostSimple","type":"Blog","readingTime":{"text":"21 min read","minutes":20.37,"time":1222200,"words":4074},"slug":"security/dns-tunnelling-malicious","path":"blog/security/dns-tunnelling-malicious","filePath":"blog/security/dns-tunnelling-malicious.mdx","toc":[{"value":"DNS","url":"#dns","depth":2},{"value":"数据痕迹","url":"#数据痕迹","depth":2},{"value":"DNS 隧道","url":"#dns-隧道","depth":2},{"value":"C2","url":"#c2","depth":3},{"value":"渗出","url":"#渗出","depth":3},{"value":"渗入","url":"#渗入","depth":3},{"value":"结论","url":"#结论-12","depth":2},{"value":"附录：工具列表","url":"#附录工具列表","depth":2},{"value":"附录：恶意软件列表","url":"#附录恶意软件列表","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"DNS 隧道：DNS 如何被恶意行为者滥用","datePublished":"2025-02-17T00:00:00.000Z","dateModified":"2025-02-17T00:00:00.000Z","description":"DNS隧道是一种利用DNS协议进行数据渗透和命令控制通信的技术。由于DNS的普遍性和开放性，恶意行为者可以通过创建隐蔽的通信渠道来绕过网络安全措施。防御措施包括监控异常DNS查询和加强系统安全。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/security/dns-tunnelling-malicious","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"软件设计的哲学","date":"2025-02-14T00:00:00.000Z","tags":["system"],"draft":false,"summary":"本书《软件设计的哲学》强调减少复杂性、适当拆分组件和简化异常处理的重要性。通过案例说明如何消除冗余逻辑、合理拆分功能并避免过多异常处理，提高代码的可维护性和简洁性。","layout":"PostSimple","type":"Blog","readingTime":{"text":"15 min read","minutes":14.25,"time":855000,"words":2850},"slug":"system/software-design-philosophy","path":"blog/system/software-design-philosophy","filePath":"blog/system/software-design-philosophy.mdx","toc":[{"value":"观点一：对复杂性的零容忍","url":"#观点一对复杂性的零容忍","depth":3},{"value":"观点二：更小的组件不一定更好","url":"#观点二更小的组件不一定更好","depth":3},{"value":"观点三：异常处理增加了复杂性","url":"#观点三异常处理增加了复杂性","depth":3},{"value":"结论","url":"#结论-15","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"软件设计的哲学","datePublished":"2025-02-14T00:00:00.000Z","dateModified":"2025-02-14T00:00:00.000Z","description":"本书《软件设计的哲学》强调减少复杂性、适当拆分组件和简化异常处理的重要性。通过案例说明如何消除冗余逻辑、合理拆分功能并避免过多异常处理，提高代码的可维护性和简洁性。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/system/software-design-philosophy","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"安全赋值操作符","date":"2025-02-01T00:00:00.000Z","tags":["frontend","javascript"],"draft":false,"summary":"在 JavaScript 中引入安全赋值操作符 ?= 的提案引发了讨论。它通过 try/catch 机制简化错误处理，返回一个包含错误和结果的数组。此提案旨在减少显式 try/catch 块的使用，提高代码可读性。","layout":"PostSimple","type":"Blog","readingTime":{"text":"5 min read","minutes":4.305,"time":258300,"words":861},"slug":"frontend/safe-assignment-operator","path":"blog/frontend/safe-assignment-operator","filePath":"blog/frontend/safe-assignment-operator.mdx","toc":[{"value":"常见的 try/catch 烦恼","url":"#常见的-trycatch-烦恼","depth":3},{"value":"非异步实现","url":"#非异步实现","depth":3},{"value":"处理异步函数","url":"#处理异步函数","depth":3},{"value":"最后","url":"#最后","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"安全赋值操作符","datePublished":"2025-02-01T00:00:00.000Z","dateModified":"2025-02-01T00:00:00.000Z","description":"在 JavaScript 中引入安全赋值操作符 ?= 的提案引发了讨论。它通过 try/catch 机制简化错误处理，返回一个包含错误和结果的数组。此提案旨在减少显式 try/catch 块的使用，提高代码可读性。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/frontend/safe-assignment-operator","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"LocalStorage vs. IndexedDB vs. Cookies vs. OPFS vs. WASM-SQLite","date":"2025-01-15T00:00:00.000Z","tags":["frontend"],"draft":false,"summary":"文章比较了多种浏览器存储技术，包括Cookies、LocalStorage、IndexedDB、OPFS和WASM-SQLite。它详细介绍了每种技术的历史、功能、性能和限制，并通过性能测试揭示了不同方法在Web应用程序中写入和读取数据的速度。文章还讨论了可能的改进和未来的技术发展方向。","layout":"PostSimple","type":"Blog","readingTime":{"text":"28 min read","minutes":27.435,"time":1646100,"words":5487},"slug":"frontend/browser-storage-comparison","path":"blog/frontend/browser-storage-comparison","filePath":"blog/frontend/browser-storage-comparison.mdx","toc":[{"value":"现代浏览器中的可用存储 API","url":"#现代浏览器中的可用存储-api","depth":2},{"value":"什么是 Cookies","url":"#什么是-cookies","depth":3},{"value":"什么是 LocalStorage","url":"#什么是-localstorage","depth":3},{"value":"什么是 IndexedDB","url":"#什么是-indexeddb","depth":3},{"value":"什么是 OPFS","url":"#什么是-opfs","depth":3},{"value":"什么是 WASM SQLite","url":"#什么是-wasm-sqlite","depth":3},{"value":"什么是 WebSQL","url":"#什么是-websql","depth":3},{"value":"功能比较","url":"#功能比较","depth":2},{"value":"存储复杂的 JSON 文档","url":"#存储复杂的-json-文档","depth":3},{"value":"多标签页支持","url":"#多标签页支持","depth":3},{"value":"索引支持","url":"#索引支持","depth":3},{"value":"WebWorker 支持","url":"#webworker-支持","depth":3},{"value":"存储大小限制","url":"#存储大小限制","depth":3},{"value":"性能比较","url":"#性能比较","depth":2},{"value":"初始化时间","url":"#初始化时间","depth":3},{"value":"小写入的延迟","url":"#小写入的延迟","depth":3},{"value":"小读取的延迟","url":"#小读取的延迟","depth":3},{"value":"大批量写入","url":"#大批量写入","depth":3},{"value":"大批量读取","url":"#大批量读取","depth":3},{"value":"性能结论","url":"#性能结论","depth":2},{"value":"可能的改进","url":"#可能的改进","depth":2},{"value":"未来的改进","url":"#未来的改进","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"LocalStorage vs. IndexedDB vs. Cookies vs. OPFS vs. WASM-SQLite","datePublished":"2025-01-15T00:00:00.000Z","dateModified":"2025-01-15T00:00:00.000Z","description":"文章比较了多种浏览器存储技术，包括Cookies、LocalStorage、IndexedDB、OPFS和WASM-SQLite。它详细介绍了每种技术的历史、功能、性能和限制，并通过性能测试揭示了不同方法在Web应用程序中写入和读取数据的速度。文章还讨论了可能的改进和未来的技术发展方向。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/frontend/browser-storage-comparison","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"Telegram Mini App 客户端缓存指南","date":"2025-01-15T00:00:00.000Z","tags":["frontend"],"draft":false,"summary":"本文档全面介绍了客户端缓存的各种方法，包括内存缓存、Local Storage、Session Storage、IndexedDB 和 Cookies。每种方法详细说明了实现方式、优缺点及适用场景，并提供高级缓存技术如 Service Worker 和 API 响应缓存的实用案例，帮助开发者提升应用性能和用户体验。","layout":"PostSimple","type":"Blog","readingTime":{"text":"8 min read","minutes":7.25,"time":435000,"words":1450},"slug":"frontend/client-cache","path":"blog/frontend/client-cache","filePath":"blog/frontend/client-cache.mdx","toc":[{"value":"简介","url":"#简介","depth":2},{"value":"1. 客户端缓存类型","url":"#1-客户端缓存类型","depth":2},{"value":"a. 内存缓存","url":"#a-内存缓存","depth":3},{"value":"实现方式","url":"#实现方式","depth":4},{"value":"优点","url":"#优点-2","depth":4},{"value":"缺点","url":"#缺点","depth":4},{"value":"b. Local Storage（本地存储）","url":"#b-local-storage本地存储","depth":3},{"value":"实现方式","url":"#实现方式-1","depth":4},{"value":"优点","url":"#优点-3","depth":4},{"value":"缺点","url":"#缺点-1","depth":4},{"value":"c. Session Storage（会话存储）","url":"#c-session-storage会话存储","depth":3},{"value":"实现方式","url":"#实现方式-2","depth":4},{"value":"优点","url":"#优点-4","depth":4},{"value":"缺点","url":"#缺点-2","depth":4},{"value":"d. IndexedDB","url":"#d-indexeddb","depth":3},{"value":"实现方式","url":"#实现方式-3","depth":4},{"value":"优点","url":"#优点-5","depth":4},{"value":"缺点","url":"#缺点-3","depth":4},{"value":"e. Cookies","url":"#e-cookies","depth":3},{"value":"实现方式","url":"#实现方式-4","depth":4},{"value":"优点","url":"#优点-6","depth":4},{"value":"缺点","url":"#缺点-4","depth":4},{"value":"2. 缓存策略","url":"#2-缓存策略","depth":2},{"value":"a. 短期缓存","url":"#a-短期缓存","depth":3},{"value":"b. 长期缓存","url":"#b-长期缓存","depth":3},{"value":"c. 缓存更新机制","url":"#c-缓存更新机制","depth":3},{"value":"3. 高级缓存技术","url":"#3-高级缓存技术","depth":2},{"value":"a. Service Worker 缓存","url":"#a-service-worker-缓存","depth":3},{"value":"实现方式","url":"#实现方式-5","depth":4},{"value":"优点","url":"#优点-7","depth":4},{"value":"缺点","url":"#缺点-5","depth":4},{"value":"b. API 响应缓存","url":"#b-api-响应缓存","depth":3},{"value":"Local Storage 实现","url":"#local-storage-实现","depth":4},{"value":"优点","url":"#优点-8","depth":4},{"value":"缺点","url":"#缺点-6","depth":4},{"value":"4. 常见问题及解决方案","url":"#4-常见问题及解决方案","depth":2},{"value":"a. 数据过期问题","url":"#a-数据过期问题","depth":3},{"value":"b. 安全性问题","url":"#b-安全性问题","depth":3},{"value":"c. 存储空间限制","url":"#c-存储空间限制","depth":3},{"value":"5. 最佳实践","url":"#5-最佳实践-1","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Telegram Mini App 客户端缓存指南","datePublished":"2025-01-15T00:00:00.000Z","dateModified":"2025-01-15T00:00:00.000Z","description":"本文档全面介绍了客户端缓存的各种方法，包括内存缓存、Local Storage、Session Storage、IndexedDB 和 Cookies。每种方法详细说明了实现方式、优缺点及适用场景，并提供高级缓存技术如 Service Worker 和 API 响应缓存的实用案例，帮助开发者提升应用性能和用户体验。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/frontend/client-cache","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"加密流量相似性对比","date":"2024-12-24T00:00:00.000Z","tags":["paper reading","machine learing","network security"],"draft":false,"summary":"本文综述了多种加密技术，包括基于局部敏感哈希（LSH）的相似性搜索和一维卷积神经网络（1D-CNN）的流量分类。这些方法在加密数据的相似性匹配和分类中展现了出色的性能和安全性，适用于多种应用场景。","layout":"PostSimple","type":"Blog","readingTime":{"text":"7 min read","minutes":6.925,"time":415500,"words":1385},"slug":"paper/encrpyted-similarity","path":"blog/paper/encrpyted-similarity","filePath":"blog/paper/encrpyted-similarity.mdx","toc":[{"value":"加密数据的高效相似性搜索","url":"#加密数据的高效相似性搜索","depth":2},{"value":"全文总结","url":"#全文总结","depth":3},{"value":"主要观点","url":"#主要观点","depth":3},{"value":"流程","url":"#流程","depth":3},{"value":"参考文献","url":"#参考文献-1","depth":3},{"value":"基于一维卷积神经网络的端到端加密流量分类","url":"#基于一维卷积神经网络的端到端加密流量分类","depth":2},{"value":"全文总结","url":"#全文总结-1","depth":3},{"value":"主要观点","url":"#主要观点-1","depth":3},{"value":"流程","url":"#流程-1","depth":3},{"value":"参考文献","url":"#参考文献-2","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"加密流量相似性对比","datePublished":"2024-12-24T00:00:00.000Z","dateModified":"2024-12-24T00:00:00.000Z","description":"本文综述了多种加密技术，包括基于局部敏感哈希（LSH）的相似性搜索和一维卷积神经网络（1D-CNN）的流量分类。这些方法在加密数据的相似性匹配和分类中展现了出色的性能和安全性，适用于多种应用场景。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/paper/encrpyted-similarity","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"基于深度卷积神经网络的 DGA 检测","date":"2024-12-20T00:00:00.000Z","tags":["paper reading","machine learing","network security"],"draft":false,"summary":"论文介绍了一种使用一维卷积神经网络(1D-CNN)来检测域名生成算法(DGA)的方法。研究在包含51个DGA恶意软件家族的数据集上进行评估,结果显示该方法能正确检测97%的DGA域名,误报率仅为0.7%。与LSTM网络相比,1D-CNN在检测性能和训练速度上都表现更好。但对于那些模仿正常域名特征的基于词的DGA,检测仍然具有挑战性。这项研究为DGA检测提供了一个高效可行的解决方案。","layout":"PostSimple","type":"Blog","readingTime":{"text":"33 min read","minutes":32.505,"time":1950300,"words":6501},"slug":"paper/dga_detection_using_cnn","path":"blog/paper/dga_detection_using_cnn","filePath":"blog/paper/dga_detection_using_cnn.mdx","toc":[{"value":"摘要","url":"#摘要-1","depth":2},{"value":"1. 引言","url":"#1-引言","depth":2},{"value":"2. 神经网络架构","url":"#2-神经网络架构","depth":2},{"value":"2.1 嵌入层","url":"#21-嵌入层","depth":3},{"value":"2.2 一维卷积层","url":"#22-一维卷积层","depth":3},{"value":"2.3 全连接层","url":"#23-全连接层","depth":3},{"value":"3. 实验设计","url":"#3-实验设计","depth":2},{"value":"3.1 数据集描述","url":"#31-数据集描述","depth":3},{"value":"3.2 超参数调优","url":"#32-超参数调优","depth":3},{"value":"3.3 未见域名的评估","url":"#33-未见域名的评估","depth":3},{"value":"4. 讨论与分析","url":"#4-讨论与分析","depth":2},{"value":"5. 基于 LSTM 网络的 DGA 检测对比分析","url":"#5-基于-lstm-网络的-dga-检测对比分析","depth":2},{"value":"6. 结论与展望","url":"#6-结论与展望","depth":2},{"value":"参考文献","url":"#参考文献","depth":2},{"value":"示例代码","url":"#示例代码-7","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"基于深度卷积神经网络的 DGA 检测","datePublished":"2024-12-20T00:00:00.000Z","dateModified":"2024-12-20T00:00:00.000Z","description":"论文介绍了一种使用一维卷积神经网络(1D-CNN)来检测域名生成算法(DGA)的方法。研究在包含51个DGA恶意软件家族的数据集上进行评估,结果显示该方法能正确检测97%的DGA域名,误报率仅为0.7%。与LSTM网络相比,1D-CNN在检测性能和训练速度上都表现更好。但对于那些模仿正常域名特征的基于词的DGA,检测仍然具有挑战性。这项研究为DGA检测提供了一个高效可行的解决方案。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/paper/dga_detection_using_cnn","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"RPC vs REST：深入对比分析","date":"2024-12-13T00:00:00.000Z","tags":["backend"],"draft":false,"summary":"RPC 和 REST 是两种主流的服务间通信方式。RPC 通过远程函数调用实现服务交互，性能优越，适合对延迟敏感的内部微服务通信，但耦合度较高；REST 则基于 HTTP 协议对资源进行操作，接口统一且易于理解，扩展性好，特别适合构建公开 API。选择时需要权衡性能需求、架构复杂度和维护成本，在实际应用中可以根据不同场景结合使用这两种方式。","layout":"PostSimple","type":"Blog","readingTime":{"text":"6 min read","minutes":5.075,"time":304500,"words":1015},"slug":"backend/rpc-vs-rest-comparison","path":"blog/backend/rpc-vs-rest-comparison","filePath":"blog/backend/rpc-vs-rest-comparison.mdx","toc":[{"value":"RPC 是什么？","url":"#rpc-是什么","depth":2},{"value":"核心组件","url":"#核心组件","depth":3},{"value":"RPC 工作流程","url":"#rpc-工作流程","depth":3},{"value":"常见实现","url":"#常见实现","depth":3},{"value":"REST 是什么？","url":"#rest-是什么","depth":2},{"value":"核心组件","url":"#核心组件-1","depth":3},{"value":"REST 工作流程","url":"#rest-工作流程","depth":3},{"value":"RPC vs REST 关键差异","url":"#rpc-vs-rest-关键差异","depth":2},{"value":"使用场景选择","url":"#使用场景选择","depth":2},{"value":"选择 RPC 的场景","url":"#选择-rpc-的场景","depth":3},{"value":"选择 REST 的场景","url":"#选择-rest-的场景","depth":3},{"value":"现代趋势","url":"#现代趋势","depth":2},{"value":"结论","url":"#结论-3","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"RPC vs REST：深入对比分析","datePublished":"2024-12-13T00:00:00.000Z","dateModified":"2024-12-13T00:00:00.000Z","description":"RPC 和 REST 是两种主流的服务间通信方式。RPC 通过远程函数调用实现服务交互，性能优越，适合对延迟敏感的内部微服务通信，但耦合度较高；REST 则基于 HTTP 协议对资源进行操作，接口统一且易于理解，扩展性好，特别适合构建公开 API。选择时需要权衡性能需求、架构复杂度和维护成本，在实际应用中可以根据不同场景结合使用这两种方式。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/backend/rpc-vs-rest-comparison","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"Aho-Corasick算法","date":"2024-12-11T00:00:00.000Z","tags":["algorithm"],"draft":false,"summary":"Aho-Corasick 算法是一种高效的多模式字符串匹配算法，通过构建 Trie 和失败指针，实现快速匹配多个模式，广泛应用于文本过滤、生物信息学和网络安全等领域。","layout":"PostSimple","type":"Blog","readingTime":{"text":"4 min read","minutes":3.905,"time":234300,"words":781},"slug":"algorithm/Aho–Corasick","path":"blog/algorithm/Aho–Corasick","filePath":"blog/algorithm/Aho–Corasick.mdx","toc":[{"value":"算法原理","url":"#算法原理","depth":2},{"value":"Trie 构建","url":"#trie-构建","depth":3},{"value":"失败函数构建","url":"#失败函数构建","depth":3},{"value":"匹配过程","url":"#匹配过程","depth":2},{"value":"时间复杂度","url":"#时间复杂度","depth":2},{"value":"应用场景","url":"#应用场景","depth":2},{"value":"示例代码","url":"#示例代码","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Aho-Corasick算法","datePublished":"2024-12-11T00:00:00.000Z","dateModified":"2024-12-11T00:00:00.000Z","description":"Aho-Corasick 算法是一种高效的多模式字符串匹配算法，通过构建 Trie 和失败指针，实现快速匹配多个模式，广泛应用于文本过滤、生物信息学和网络安全等领域。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/algorithm/Aho–Corasick","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"差分数组","date":"2024-12-11T00:00:00.000Z","tags":["algorithm"],"draft":false,"summary":"差分数组是一种高效处理区间更新的数据结构，通过记录变化量实现快速更新。它将区间操作的时间复杂度从 O(n) 降低到 O(1)，适用于频繁更新的场景，如区间加法、乘法和赋值。","layout":"PostSimple","type":"Blog","readingTime":{"text":"4 min read","minutes":3.69,"time":221400,"words":738},"slug":"algorithm/DifferenceArray","path":"blog/algorithm/DifferenceArray","filePath":"blog/algorithm/DifferenceArray.mdx","toc":[{"value":"基本概念","url":"#基本概念","depth":2},{"value":"还原原数组","url":"#还原原数组","depth":2},{"value":"示例","url":"#示例","depth":2},{"value":"差分数组的构建与更新","url":"#差分数组的构建与更新","depth":3},{"value":"还原更新后的数组","url":"#还原更新后的数组","depth":3},{"value":"示例代码","url":"#示例代码-1","depth":2},{"value":"应用场景","url":"#应用场景-1","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"差分数组","datePublished":"2024-12-11T00:00:00.000Z","dateModified":"2024-12-11T00:00:00.000Z","description":"差分数组是一种高效处理区间更新的数据结构，通过记录变化量实现快速更新。它将区间操作的时间复杂度从 O(n) 降低到 O(1)，适用于频繁更新的场景，如区间加法、乘法和赋值。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/algorithm/DifferenceArray","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"Manacher算法","date":"2024-12-11T00:00:00.000Z","tags":["algorithm"],"draft":false,"summary":"Manacher算法是一种高效的算法，用于在O(n)时间复杂度内找到字符串中最长的回文子串。通过预处理字符串和利用对称性，该算法能够快速更新和计算回文子串的长度，是解决回文问题的经典方法。","layout":"PostSimple","type":"Blog","readingTime":{"text":"4 min read","minutes":3.655,"time":219300,"words":731},"slug":"algorithm/Manacher","path":"blog/algorithm/Manacher","filePath":"blog/algorithm/Manacher.mdx","toc":[{"value":"算法思想","url":"#算法思想","depth":2},{"value":"详细步骤","url":"#详细步骤","depth":2},{"value":"代码示例","url":"#代码示例","depth":2},{"value":"相关LeetCode题目","url":"#相关leetcode题目","depth":2},{"value":"总结","url":"#总结","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Manacher算法","datePublished":"2024-12-11T00:00:00.000Z","dateModified":"2024-12-11T00:00:00.000Z","description":"Manacher算法是一种高效的算法，用于在O(n)时间复杂度内找到字符串中最长的回文子串。通过预处理字符串和利用对称性，该算法能够快速更新和计算回文子串的长度，是解决回文问题的经典方法。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/algorithm/Manacher","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"后缀数组","date":"2024-12-11T00:00:00.000Z","tags":["algorithm"],"draft":false,"summary":"后缀数组是一种高效的字符串处理数据结构，存储字符串所有后缀的字典序排序。它在字符串匹配、最长公共前缀计算和重复子串查找等问题中应用广泛。通过倍增算法构建，时间复杂度为 O(n log n)。","layout":"PostSimple","type":"Blog","readingTime":{"text":"4 min read","minutes":3.34,"time":200400,"words":668},"slug":"algorithm/SuffixArray","path":"blog/algorithm/SuffixArray","filePath":"blog/algorithm/SuffixArray.mdx","toc":[{"value":"定义","url":"#定义","depth":2},{"value":"构建后缀数组","url":"#构建后缀数组","depth":2},{"value":"示例代码","url":"#示例代码-2","depth":3},{"value":"应用","url":"#应用","depth":2},{"value":"例子","url":"#例子","depth":2},{"value":"结论","url":"#结论-1","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"后缀数组","datePublished":"2024-12-11T00:00:00.000Z","dateModified":"2024-12-11T00:00:00.000Z","description":"后缀数组是一种高效的字符串处理数据结构，存储字符串所有后缀的字典序排序。它在字符串匹配、最长公共前缀计算和重复子串查找等问题中应用广泛。通过倍增算法构建，时间复杂度为 O(n log n)。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/algorithm/SuffixArray","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"字典树（Trie）","date":"2024-12-11T00:00:00.000Z","tags":["algorithm"],"draft":false,"summary":"字典树（Trie）是一种高效的树形数据结构，用于存储和快速查找字符串集合。它通过共享公共前缀来节省空间，适用于自动补全、拼写检查和IP路由等场景。","layout":"PostSimple","type":"Blog","readingTime":{"text":"4 min read","minutes":3.115,"time":186900,"words":623},"slug":"algorithm/Trie","path":"blog/algorithm/Trie","filePath":"blog/algorithm/Trie.mdx","toc":[{"value":"基本结构","url":"#基本结构","depth":2},{"value":"操作","url":"#操作","depth":2},{"value":"插入","url":"#插入","depth":3},{"value":"查找","url":"#查找","depth":3},{"value":"删除","url":"#删除","depth":3},{"value":"优点","url":"#优点","depth":2},{"value":"应用","url":"#应用-1","depth":2},{"value":"示例","url":"#示例-1","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"字典树（Trie）","datePublished":"2024-12-11T00:00:00.000Z","dateModified":"2024-12-11T00:00:00.000Z","description":"字典树（Trie）是一种高效的树形数据结构，用于存储和快速查找字符串集合。它通过共享公共前缀来节省空间，适用于自动补全、拼写检查和IP路由等场景。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/algorithm/Trie","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"域名生成算法","date":"2024-12-11T00:00:00.000Z","tags":["network security"],"draft":false,"summary":"域名生成算法（DGA）是一种用于生成大量新域名的程序，网络犯罪分子利用它频繁更换攻击域名以避开检测。DGA通过伪随机数、字符或字典生成域名，帮助攻击者与命令和控制服务器保持联系。组织可通过更新软件、培训用户、使用URL过滤和DNS安全解决方案等措施检测和防御DGA。","layout":"PostSimple","type":"Blog","readingTime":{"text":"10 min read","minutes":9.89,"time":593400,"words":1978},"slug":"security/domain-generation-algorithms","path":"blog/security/domain-generation-algorithms","filePath":"blog/security/domain-generation-algorithms.mdx","toc":[{"value":"什么是域名生成算法？","url":"#什么是域名生成算法","depth":2},{"value":"为什么网络犯罪分子使用域名生成算法？","url":"#为什么网络犯罪分子使用域名生成算法","depth":2},{"value":"域名生成算法如何工作？","url":"#域名生成算法如何工作","depth":2},{"value":"DGA的类型有哪些？","url":"#dga的类型有哪些","depth":2},{"value":"组织如何检测DGA域名？","url":"#组织如何检测dga域名","depth":2},{"value":"常见问题解答（FAQ）","url":"#常见问题解答faq","depth":2},{"value":"总结","url":"#总结-13","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"域名生成算法","datePublished":"2024-12-11T00:00:00.000Z","dateModified":"2024-12-11T00:00:00.000Z","description":"域名生成算法（DGA）是一种用于生成大量新域名的程序，网络犯罪分子利用它频繁更换攻击域名以避开检测。DGA通过伪随机数、字符或字典生成域名，帮助攻击者与命令和控制服务器保持联系。组织可通过更新软件、培训用户、使用URL过滤和DNS安全解决方案等措施检测和防御DGA。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/security/domain-generation-algorithms","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"域名生成算法的生死对决","date":"2024-12-05T00:00:00.000Z","tags":["network security"],"draft":false,"summary":"域名生成算法（DGA）是恶意软件用于隐藏其命令和控制服务器位置的工具。安全研究人员通过逆向工程和机器学习方法努力识别和阻止这些DGA，双方在这场技术对抗中不断进化。","layout":"PostSimple","type":"Blog","readingTime":{"text":"15 min read","minutes":14.69,"time":881400,"words":2938},"slug":"security/dga-battle","path":"blog/security/dga-battle","filePath":"blog/security/dga-battle.mdx","toc":[{"value":"DGA战场","url":"#dga战场","depth":2},{"value":"魔术数字种子","url":"#魔术数字种子","depth":2},{"value":"其他类型的种子","url":"#其他类型的种子","depth":2},{"value":"好的DGA，坏的DGA","url":"#好的dga坏的dga","depth":2},{"value":"基于字典的DGA","url":"#基于字典的dga","depth":3},{"value":"高碰撞DGA","url":"#高碰撞dga","depth":3},{"value":"非DGA","url":"#非dga","depth":3},{"value":"总结","url":"#总结-12","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"域名生成算法的生死对决","datePublished":"2024-12-05T00:00:00.000Z","dateModified":"2024-12-05T00:00:00.000Z","description":"域名生成算法（DGA）是恶意软件用于隐藏其命令和控制服务器位置的工具。安全研究人员通过逆向工程和机器学习方法努力识别和阻止这些DGA，双方在这场技术对抗中不断进化。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/security/dga-battle","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"网络安全：攻击者使用的域名生成算法（DGA）","date":"2024-12-04T00:00:00.000Z","tags":["network security"],"draft":false,"summary":"域名生成算法（DGA）是网络攻击者用来生成大量域名以逃避检测的工具。它们通过复杂的算法生成域名，挑战传统安全措施。通过机器学习和大数据等技术，网络安全专家可以更有效地检测和阻止DGA驱动的威胁。","layout":"PostSimple","type":"Blog","readingTime":{"text":"21 min read","minutes":20.13,"time":1207800,"words":4026},"slug":"security/cybersecurity-dga","path":"blog/security/cybersecurity-dga","filePath":"blog/security/cybersecurity-dga.mdx","toc":[{"value":"了解域名生成算法（DGA）","url":"#了解域名生成算法dga","depth":2},{"value":"DGA的功能：","url":"#dga的功能","depth":3},{"value":"网络安全的挑战：","url":"#网络安全的挑战","depth":3},{"value":"检测和缓解策略：","url":"#检测和缓解策略","depth":3},{"value":"DGA的工作原理","url":"#dga的工作原理","depth":2},{"value":"算法复杂性","url":"#算法复杂性","depth":3},{"value":"域名生成：","url":"#域名生成","depth":3},{"value":"规避和弹性：","url":"#规避和弹性","depth":3},{"value":"检测和保护：","url":"#检测和保护","depth":3},{"value":"威胁的规模：","url":"#威胁的规模","depth":3},{"value":"DGA对网络安全的影响","url":"#dga对网络安全的影响","depth":2},{"value":"分析利用DGA的著名历史恶意软件","url":"#分析利用dga的著名历史恶意软件","depth":2},{"value":"攻击者如何利用DGA：","url":"#攻击者如何利用dga","depth":3},{"value":"防范这些DGA驱动的威胁的最佳实践：","url":"#防范这些dga驱动的威胁的最佳实践","depth":3},{"value":"未来展望","url":"#未来展望","depth":2},{"value":"常见问题","url":"#常见问题","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"网络安全：攻击者使用的域名生成算法（DGA）","datePublished":"2024-12-04T00:00:00.000Z","dateModified":"2024-12-04T00:00:00.000Z","description":"域名生成算法（DGA）是网络攻击者用来生成大量域名以逃避检测的工具。它们通过复杂的算法生成域名，挑战传统安全措施。通过机器学习和大数据等技术，网络安全专家可以更有效地检测和阻止DGA驱动的威胁。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/security/cybersecurity-dga","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"DGA 域名检测研究","date":"2024-12-04T00:00:00.000Z","tags":["network security"],"draft":false,"summary":"文章介绍了域名生成算法（DGA）域名检测的研究资源，包括数据集、DGA生成器、工具和模型。它强调了DGA域名在恶意软件中的应用及其检测的挑战，并提供了相关的开源项目和研究论文作为参考。","layout":"PostSimple","type":"Blog","readingTime":{"text":"8 min read","minutes":7.86,"time":471600,"words":1572},"slug":"security/dga-research","path":"blog/security/dga-research","filePath":"blog/security/dga-research.mdx","toc":[{"value":"数据：","url":"#数据","depth":2},{"value":"DGA 数据：","url":"#dga-数据","depth":3},{"value":"DGA 生成器：","url":"#dga-生成器","depth":3},{"value":"基于单词/字典的 DGA 资源：","url":"#基于单词字典的-dga-资源","depth":3},{"value":"“良性”/非 DGA 数据：","url":"#良性非-dga-数据","depth":3},{"value":"更多良性训练集策划的启发式：","url":"#更多良性训练集策划的启发式","depth":3},{"value":"工具：","url":"#工具-1","depth":2},{"value":"域名解析器：","url":"#域名解析器","depth":3},{"value":"域名解析：","url":"#域名解析","depth":3},{"value":"模型：","url":"#模型","depth":2},{"value":"研究：","url":"#研究","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"DGA 域名检测研究","datePublished":"2024-12-04T00:00:00.000Z","dateModified":"2024-12-04T00:00:00.000Z","description":"文章介绍了域名生成算法（DGA）域名检测的研究资源，包括数据集、DGA生成器、工具和模型。它强调了DGA域名在恶意软件中的应用及其检测的挑战，并提供了相关的开源项目和研究论文作为参考。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/security/dga-research","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"Kafka 重平衡挑战及 AutoMQ 的解决方案","date":"2024-12-02T00:00:00.000Z","tags":["backend"],"draft":false,"summary":"文章详细介绍了 Kafka 在重平衡过程中面临的挑战，以及 AutoMQ 如何通过创新的存储计算分离架构来解决这些问题。通过将数据存储在对象存储中，AutoMQ 无需在 broker 间移动数据就能实现重平衡，大大提高了效率。文章还介绍了 AutoMQ 的自平衡组件 AutoBalancer 的工作原理和优势。","layout":"PostSimple","type":"Blog","readingTime":{"text":"24 min read","minutes":23.445,"time":1406700,"words":4689},"slug":"backend/kafka-rebalancing-automq","path":"blog/backend/kafka-rebalancing-automq","filePath":"blog/backend/kafka-rebalancing-automq.mdx","toc":[{"value":"引言","url":"#引言-1","depth":2},{"value":"Kafka 分区基础","url":"#kafka-分区基础","depth":2},{"value":"副本重分配在 Kafka 中","url":"#副本重分配在-kafka-中","depth":2},{"value":"LinkedIn 的 Cruise Control","url":"#linkedin-的-cruise-control","depth":2},{"value":"AutoMQ：无需移动数据","url":"#automq无需移动数据","depth":2},{"value":"AutoBalancer：AutoMQ 的自平衡功能","url":"#autobalancerautomq-的自平衡功能","depth":2},{"value":"目标","url":"#目标","depth":3},{"value":"组件","url":"#组件","depth":3},{"value":"典型流程","url":"#典型流程","depth":3},{"value":"场景","url":"#场景","depth":3},{"value":"AutoBalancer 与 Cruise Control 的对比","url":"#autobalancer-与-cruise-control-的对比","depth":3},{"value":"总结","url":"#总结-3","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kafka 重平衡挑战及 AutoMQ 的解决方案","datePublished":"2024-12-02T00:00:00.000Z","dateModified":"2024-12-02T00:00:00.000Z","description":"文章详细介绍了 Kafka 在重平衡过程中面临的挑战，以及 AutoMQ 如何通过创新的存储计算分离架构来解决这些问题。通过将数据存储在对象存储中，AutoMQ 无需在 broker 间移动数据就能实现重平衡，大大提高了效率。文章还介绍了 AutoMQ 的自平衡组件 AutoBalancer 的工作原理和优势。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/backend/kafka-rebalancing-automq","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"AutoMQ 如何几乎消除了 100% 的 Kafka 跨可用区数据传输成本","date":"2024-11-29T00:00:00.000Z","tags":["backend"],"draft":false,"summary":"这篇文章介绍了 AutoMQ 如何通过创新的 WAL 存储架构和智能的服务发现机制，让生产者与同可用区的 broker 通信，并利用对象存储替代传统数据复制方案，从而几乎完全消除了 Kafka 中的跨可用区数据传输成本。","layout":"PostSimple","type":"Blog","readingTime":{"text":"16 min read","minutes":15.935,"time":956100,"words":3187},"slug":"backend/automq-kafka-cost","path":"blog/backend/automq-kafka-cost","filePath":"blog/backend/automq-kafka-cost.mdx","toc":[{"value":"引言","url":"#引言","depth":2},{"value":"跨可用区成本","url":"#跨可用区成本","depth":2},{"value":"AutoMQ 概述","url":"#automq-概述","depth":2},{"value":"AutoMQ 如何降低跨可用区成本","url":"#automq-如何降低跨可用区成本","depth":2},{"value":"生产路径","url":"#生产路径","depth":3},{"value":"消费路径","url":"#消费路径","depth":3},{"value":"观察结果","url":"#观察结果","depth":2},{"value":"总结","url":"#总结-1","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"AutoMQ 如何几乎消除了 100% 的 Kafka 跨可用区数据传输成本","datePublished":"2024-11-29T00:00:00.000Z","dateModified":"2024-11-29T00:00:00.000Z","description":"这篇文章介绍了 AutoMQ 如何通过创新的 WAL 存储架构和智能的服务发现机制，让生产者与同可用区的 broker 通信，并利用对象存储替代传统数据复制方案，从而几乎完全消除了 Kafka 中的跨可用区数据传输成本。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/backend/automq-kafka-cost","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"如何让 Kafka 完全运行在对象存储上？","date":"2024-11-28T00:00:00.000Z","tags":["backend"],"draft":false,"summary":"文章介绍了 AutoMQ 如何通过创新的存储架构,让 Kafka 完全运行在对象存储上。它通过堆外缓存处理实时读写,使用 EBS 作为预写日志确保可靠性,并将所有数据最终存储在对象存储中。这种设计既保持了 Kafka 的高性能,又解决了传统 Kafka 存储扩展的局限性。","layout":"PostSimple","type":"Blog","readingTime":{"text":"22 min read","minutes":21.64,"time":1298400,"words":4328},"slug":"backend/kafka-object-storage","path":"blog/backend/kafka-object-storage","filePath":"blog/backend/kafka-object-storage.mdx","toc":[{"value":"概述","url":"#概述","depth":2},{"value":"AutoMQ 存储架构","url":"#automq-存储架构","depth":2},{"value":"缓存","url":"#缓存","depth":3},{"value":"预写日志(WAL)","url":"#预写日志wal","depth":3},{"value":"对象存储","url":"#对象存储","depth":3},{"value":"写入过程","url":"#写入过程","depth":3},{"value":"从缓存到 WAL 的旅程","url":"#从缓存到-wal-的旅程","depth":3},{"value":"从缓存到对象存储的旅程","url":"#从缓存到对象存储的旅程","depth":3},{"value":"读取过程","url":"#读取过程","depth":3},{"value":"恢复机制","url":"#恢复机制","depth":3},{"value":"元数据管理","url":"#元数据管理","depth":3},{"value":"结语","url":"#结语","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"如何让 Kafka 完全运行在对象存储上？","datePublished":"2024-11-28T00:00:00.000Z","dateModified":"2024-11-28T00:00:00.000Z","description":"文章介绍了 AutoMQ 如何通过创新的存储架构,让 Kafka 完全运行在对象存储上。它通过堆外缓存处理实时读写,使用 EBS 作为预写日志确保可靠性,并将所有数据最终存储在对象存储中。这种设计既保持了 Kafka 的高性能,又解决了传统 Kafka 存储扩展的局限性。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/backend/kafka-object-storage","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"2024office官网正版下载","date":"2024-11-27T00:00:00.000Z","tags":["tools"],"draft":false,"summary":"本文介绍了如何在Windows系统上下载、解压、配置和安装Office部署工具，并激活Office许可证。通过详细步骤和图片说明，帮助用户顺利完成Office的安装和激活过程。","layout":"PostSimple","type":"Blog","readingTime":{"text":"5 min read","minutes":4.22,"time":253200,"words":844},"slug":"tools/office-crack","path":"blog/tools/office-crack","filePath":"blog/tools/office-crack.mdx","toc":[{"value":"安装","url":"#安装-8","depth":2},{"value":"1. 下载office部署工具","url":"#1-下载office部署工具","depth":3},{"value":"2. 解压部署工具","url":"#2-解压部署工具","depth":3},{"value":"3. 下载配置文件","url":"#3-下载配置文件","depth":3},{"value":"4. 下载和安装office","url":"#4-下载和安装office","depth":3},{"value":"5. 激活office","url":"#5-激活office","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"2024office官网正版下载","datePublished":"2024-11-27T00:00:00.000Z","dateModified":"2024-11-27T00:00:00.000Z","description":"本文介绍了如何在Windows系统上下载、解压、配置和安装Office部署工具，并激活Office许可证。通过详细步骤和图片说明，帮助用户顺利完成Office的安装和激活过程。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/tools/office-crack","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"如何安全地存储密码在数据库","date":"2024-11-26T00:00:00.000Z","tags":["network security","database","backend"],"draft":false,"summary":"安全存储密码需要三步：哈希将密码不可逆转为指纹，避免明文泄露；加盐为每个用户生成唯一盐，抵御彩虹表攻击；延展重复哈希多次，延缓暴力破解。结合 bcrypt 等算法，确保密码保护更安全高效，切勿直接存储明文密码。","layout":"PostSimple","type":"Blog","readingTime":{"text":"6 min read","minutes":5.575,"time":334500,"words":1115},"slug":"security/database-password","path":"blog/security/database-password","filePath":"blog/security/database-password.mdx","toc":[{"value":"一、哈希（Hashing）","url":"#一哈希hashing","depth":2},{"value":"什么是哈希函数？","url":"#什么是哈希函数","depth":3},{"value":"哈希的实现流程","url":"#哈希的实现流程","depth":3},{"value":"二、加盐（Salting）","url":"#二加盐salting","depth":2},{"value":"什么是彩虹表？","url":"#什么是彩虹表","depth":3},{"value":"如何抵御彩虹表攻击？","url":"#如何抵御彩虹表攻击","depth":3},{"value":"加盐的实现流程","url":"#加盐的实现流程","depth":3},{"value":"三、延展（Stretching）","url":"#三延展stretching","depth":2},{"value":"什么是延展？","url":"#什么是延展","depth":3},{"value":"延展的最佳实践","url":"#延展的最佳实践","depth":3},{"value":"小结","url":"#小结","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"如何安全地存储密码在数据库","datePublished":"2024-11-26T00:00:00.000Z","dateModified":"2024-11-26T00:00:00.000Z","description":"安全存储密码需要三步：哈希将密码不可逆转为指纹，避免明文泄露；加盐为每个用户生成唯一盐，抵御彩虹表攻击；延展重复哈希多次，延缓暴力破解。结合 bcrypt 等算法，确保密码保护更安全高效，切勿直接存储明文密码。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/security/database-password","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"Go Generate 完全指南","date":"2024-11-25T00:00:00.000Z","tags":["backend","go"],"draft":false,"summary":"Go 的代码生成功能虽然简单，但非常强大和实用。通过 go generate 命令，我们可以实现自动化重复性代码的生成，实现类似泛型功能（在 Go 1.18 之前特别有用），生成高效的查找表和常量，自动化字符串表示的生成，集成各种代码生成工具。通过正确使用这些功能，我们可以大大提高 Go 开发的效率和代码质量。","layout":"PostSimple","type":"Blog","readingTime":{"text":"23 min read","minutes":22.765,"time":1365900,"words":4553},"slug":"go/go-generate","path":"blog/go/go-generate","filePath":"blog/go/go-generate.mdx","toc":[{"value":"基础知识","url":"#基础知识","depth":2},{"value":"一个简单的例子","url":"#一个简单的例子","depth":2},{"value":"生成器能做什么？","url":"#生成器能做什么","depth":2},{"value":"生成器深入探讨：stringer","url":"#生成器深入探讨stringer","depth":2},{"value":"源码生成器和构建标签","url":"#源码生成器和构建标签","depth":2},{"value":"高级特性","url":"#高级特性","depth":2},{"value":"-command 标志","url":"#-command-标志","depth":3},{"value":"-run 标志","url":"#-run-标志","depth":3},{"value":"DOLLAR 环境变量","url":"#dollar-环境变量","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go Generate 完全指南","datePublished":"2024-11-25T00:00:00.000Z","dateModified":"2024-11-25T00:00:00.000Z","description":"Go 的代码生成功能虽然简单，但非常强大和实用。通过 go generate 命令，我们可以实现自动化重复性代码的生成，实现类似泛型功能（在 Go 1.18 之前特别有用），生成高效的查找表和常量，自动化字符串表示的生成，集成各种代码生成工具。通过正确使用这些功能，我们可以大大提高 Go 开发的效率和代码质量。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/go/go-generate","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"基于 Postgres 的通知模式（Notifier Pattern）","date":"2024-11-22T00:00:00.000Z","tags":["backend","go","database"],"draft":false,"summary":"Postgres 的 LISTEN/NOTIFY 功能通过通知器模式优化了连接管理，减少了每个程序需要的数据库连接数量，避免了为每个主题创建多个连接。通过使用缓冲通道和非阻塞发送，通知器能够高效处理大量通知。同时，结合上下文超时机制和“让它崩溃”策略，可以确保系统在出现问题时快速恢复。PgBouncer 的会话池模式支持 LISTEN，提高连接效率。","layout":"PostSimple","type":"Blog","readingTime":{"text":"13 min read","minutes":12.31,"time":738600,"words":2462},"slug":"go/postgres-notifier","path":"blog/go/postgres-notifier","filePath":"blog/go/postgres-notifier.mdx","toc":[{"value":"通知器模式的核心原则","url":"#通知器模式的核心原则","depth":2},{"value":"通知器的实现细节","url":"#通知器的实现细节","depth":2},{"value":"重要实现细节","url":"#重要实现细节","depth":3},{"value":"可中断的接收机制","url":"#可中断的接收机制","depth":2},{"value":"内部闭包的处理机制","url":"#内部闭包的处理机制","depth":2},{"value":"“让它崩溃” 的思想","url":"#让它崩溃-的思想","depth":2},{"value":"PgBouncer 的使用","url":"#pgbouncer-的使用","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"基于 Postgres 的通知模式（Notifier Pattern）","datePublished":"2024-11-22T00:00:00.000Z","dateModified":"2024-11-22T00:00:00.000Z","description":"Postgres 的 LISTEN/NOTIFY 功能通过通知器模式优化了连接管理，减少了每个程序需要的数据库连接数量，避免了为每个主题创建多个连接。通过使用缓冲通道和非阻塞发送，通知器能够高效处理大量通知。同时，结合上下文超时机制和“让它崩溃”策略，可以确保系统在出现问题时快速恢复。PgBouncer 的会话池模式支持 LISTEN，提高连接效率。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/go/postgres-notifier","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"Go 1.22 中更优秀的 HTTP 服务器路由","date":"2024-11-21T00:00:00.000Z","tags":["backend","go"],"draft":false,"summary":"Go 1.22 将引入增强版 HTTP 路由多路复用器，提供更强大的路径匹配和方法路由能力。新的 ServeMux 支持通配符、方法限定和细粒度路由，有望减少对第三方路由库的依赖，为 Go Web 开发带来便利。","layout":"PostSimple","type":"Blog","readingTime":{"text":"7 min read","minutes":6.775,"time":406500,"words":1355},"slug":"go/mux","path":"blog/go/mux","filePath":"blog/go/mux.mdx","toc":[{"value":"使用新的 mux","url":"#使用新的-mux","depth":2},{"value":"使用新的 mux 重新实现任务服务器","url":"#使用新的-mux-重新实现任务服务器","depth":2},{"value":"结论","url":"#结论-8","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go 1.22 中更优秀的 HTTP 服务器路由","datePublished":"2024-11-21T00:00:00.000Z","dateModified":"2024-11-21T00:00:00.000Z","description":"Go 1.22 将引入增强版 HTTP 路由多路复用器，提供更强大的路径匹配和方法路由能力。新的 ServeMux 支持通配符、方法限定和细粒度路由，有望减少对第三方路由库的依赖，为 Go Web 开发带来便利。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/go/mux","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"深入理解 Go 的 Context 包","date":"2024-11-18T00:00:00.000Z","tags":["backend","go"],"draft":false,"summary":"Go 的 context 包提供了强大的工具，用于管理请求范围内的超时、取消和数据传递。通过函数如 WithCancel、WithTimeout 和 WithValue，开发者可高效处理并发任务和资源释放，是构建健壮程序的重要组件。","layout":"PostSimple","type":"Blog","readingTime":{"text":"15 min read","minutes":14.77,"time":886200,"words":2954},"slug":"go/go-context","path":"blog/go/go-context","filePath":"blog/go/go-context.mdx","toc":[{"value":"Context 类型","url":"#context-类型","depth":2},{"value":"Context 实战","url":"#context-实战","depth":2},{"value":"WithValue 函数","url":"#withvalue-函数","depth":2},{"value":"WithCancel 函数","url":"#withcancel-函数","depth":2},{"value":"WithTimeout 函数","url":"#withtimeout-函数","depth":2},{"value":"总结","url":"#总结-5","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"深入理解 Go 的 Context 包","datePublished":"2024-11-18T00:00:00.000Z","dateModified":"2024-11-18T00:00:00.000Z","description":"Go 的 context 包提供了强大的工具，用于管理请求范围内的超时、取消和数据传递。通过函数如 WithCancel、WithTimeout 和 WithValue，开发者可高效处理并发任务和资源释放，是构建健壮程序的重要组件。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/go/go-context","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"使用Redis实现Golang API限流","date":"2024-11-15T00:00:00.000Z","tags":["backend","go"],"draft":false,"summary":"这篇文章介绍了如何使用Redis在Golang API中实现限流功能。通过Gin框架搭建HTTP服务器，利用go-redis/redis_rate包来追踪和限制每个IP地址的请求频率。文章通过实例代码展示了如何设置每分钟10次的请求限制，并详细说明了限流器的工作原理和实现方法。","layout":"PostSimple","type":"Blog","readingTime":{"text":"9 min read","minutes":8.22,"time":493200,"words":1644},"slug":"go/redis-ratelimit","path":"blog/go/redis-ratelimit","filePath":"blog/go/redis-ratelimit.mdx","toc":[{"value":"前提条件","url":"#前提条件","depth":2},{"value":"开始使用","url":"#开始使用","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用Redis实现Golang API限流","datePublished":"2024-11-15T00:00:00.000Z","dateModified":"2024-11-15T00:00:00.000Z","description":"这篇文章介绍了如何使用Redis在Golang API中实现限流功能。通过Gin框架搭建HTTP服务器，利用go-redis/redis_rate包来追踪和限制每个IP地址的请求频率。文章通过实例代码展示了如何设置每分钟10次的请求限制，并详细说明了限流器的工作原理和实现方法。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/go/redis-ratelimit","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"深入Docker内部原理 - 联合文件系统","date":"2024-11-14T00:00:00.000Z","tags":["docker","backend"],"draft":false,"summary":"Docker的联合文件系统（如OverlayFS）通过将多个只读镜像层和一个可写容器层合并为一个虚拟文件系统，实现了高效的资源共享和容器隔离。利用写时复制（CoW）技术，容器只在修改文件时复制数据，节省了存储和提高了性能。理解这些原理有助于优化Docker的使用，尤其是在性能和安全性方面。","layout":"PostSimple","type":"Blog","readingTime":{"text":"16 min read","minutes":15.725,"time":943500,"words":3145},"slug":"docker/union-filesystem","path":"blog/docker/union-filesystem","filePath":"blog/docker/union-filesystem.mdx","toc":[{"value":"什么是联合文件系统？","url":"#什么是联合文件系统","depth":2},{"value":"为什么要使用联合文件系统？","url":"#为什么要使用联合文件系统","depth":2},{"value":"它是如何工作的？","url":"#它是如何工作的","depth":2},{"value":"实际尝试","url":"#实际尝试","depth":2},{"value":"结论","url":"#结论-4","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"深入Docker内部原理 - 联合文件系统","datePublished":"2024-11-14T00:00:00.000Z","dateModified":"2024-11-14T00:00:00.000Z","description":"Docker的联合文件系统（如OverlayFS）通过将多个只读镜像层和一个可写容器层合并为一个虚拟文件系统，实现了高效的资源共享和容器隔离。利用写时复制（CoW）技术，容器只在修改文件时复制数据，节省了存储和提高了性能。理解这些原理有助于优化Docker的使用，尤其是在性能和安全性方面。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/docker/union-filesystem","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"深入探讨 JavaScript 中的函数式编程","date":"2024-11-14T00:00:00.000Z","tags":["frontend","javascript"],"draft":false,"summary":"本文深入探讨了 JavaScript 中的函数式编程，重点介绍了纯函数、不变性、柯里化、记忆化和单子等概念。通过这些技术，开发者可以编写更加可预测、可维护和高效的代码。文章展示了如何通过这些概念协同工作，提升代码的可靠性、复用性和性能，是理解和应用函数式编程的重要指南。","layout":"PostSimple","type":"Blog","readingTime":{"text":"18 min read","minutes":17.29,"time":1037400,"words":3458},"slug":"frontend/javascript-function","path":"blog/frontend/javascript-function","filePath":"blog/frontend/javascript-function.mdx","toc":[{"value":"1. 纯函数","url":"#1-纯函数","depth":2},{"value":"2. 不变性","url":"#2-不变性","depth":2},{"value":"3. 柯里化","url":"#3-柯里化","depth":2},{"value":"4. 记忆化","url":"#4-记忆化","depth":2},{"value":"5. 单子","url":"#5-单子","depth":2},{"value":"6. 这些概念如何相互关联","url":"#6-这些概念如何相互关联","depth":2},{"value":"结论","url":"#结论-5","depth":4}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"深入探讨 JavaScript 中的函数式编程","datePublished":"2024-11-14T00:00:00.000Z","dateModified":"2024-11-14T00:00:00.000Z","description":"本文深入探讨了 JavaScript 中的函数式编程，重点介绍了纯函数、不变性、柯里化、记忆化和单子等概念。通过这些技术，开发者可以编写更加可预测、可维护和高效的代码。文章展示了如何通过这些概念协同工作，提升代码的可靠性、复用性和性能，是理解和应用函数式编程的重要指南。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/frontend/javascript-function","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"深入理解Go SQL内部机制","date":"2024-11-13T00:00:00.000Z","tags":["database","backend","go"],"draft":false,"summary":"这是一篇关于Go SQL内部机制的深度解析文章。文章详细探讨了预处理语句的工作原理、连接池的生命周期管理，以及实际生产环境中常见的问题和解决方案。同时提供了具体的客户端和服务器端配置建议，对于构建高性能Go数据库应用具有重要的参考价值。","layout":"PostSimple","type":"Blog","readingTime":{"text":"17 min read","minutes":16.91,"time":1014600,"words":3382},"slug":"go/go-sql","path":"blog/go/go-sql","filePath":"blog/go/go-sql.mdx","toc":[{"value":"引言","url":"#引言-3","depth":2},{"value":"为什么这很重要","url":"#为什么这很重要","depth":3},{"value":"预处理语句","url":"#预处理语句","depth":2},{"value":"预处理语句生命周期","url":"#预处理语句生命周期","depth":3},{"value":"语句准备","url":"#语句准备","depth":3},{"value":"查询执行","url":"#查询执行","depth":3},{"value":"释放连接","url":"#释放连接","depth":3},{"value":"获取连接","url":"#获取连接","depth":3},{"value":"连接重用尝试","url":"#连接重用尝试","depth":4},{"value":"处理连接稀缺","url":"#处理连接稀缺","depth":4},{"value":"实际问题","url":"#实际问题","depth":2},{"value":"WaitCount增加问题","url":"#waitcount增加问题","depth":3},{"value":"内部错误增加","url":"#内部错误增加","depth":3},{"value":"最大连接数","url":"#最大连接数","depth":3},{"value":"建议","url":"#建议","depth":2},{"value":"客户端建议","url":"#客户端建议","depth":3},{"value":"服务器端建议","url":"#服务器端建议","depth":3},{"value":"动手实践","url":"#动手实践","depth":2},{"value":"结论","url":"#结论-7","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"深入理解Go SQL内部机制","datePublished":"2024-11-13T00:00:00.000Z","dateModified":"2024-11-13T00:00:00.000Z","description":"这是一篇关于Go SQL内部机制的深度解析文章。文章详细探讨了预处理语句的工作原理、连接池的生命周期管理，以及实际生产环境中常见的问题和解决方案。同时提供了具体的客户端和服务器端配置建议，对于构建高性能Go数据库应用具有重要的参考价值。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/go/go-sql","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"Go语言 HTTP 服务模糊测试教程","date":"2024-11-12T00:00:00.000Z","tags":["backend","go"],"draft":false,"summary":"Go语言的模糊测试（Fuzzing）是一种通过输入大量随机数据来发现程序潜在bug的自动化测试技术。Go 1.18后，它被加入标准库，使开发者能更容易地对HTTP服务和其他函数进行模糊测试。这种测试方法特别擅长发现那些在常规测试中难以发现的边界情况和异常问题。","layout":"PostSimple","type":"Blog","readingTime":{"text":"12 min read","minutes":11.085,"time":665100,"words":2217},"slug":"go/fuzzing-test","path":"blog/go/fuzzing-test","filePath":"blog/go/fuzzing-test.mdx","toc":[{"value":"什么是模糊测试？","url":"#什么是模糊测试","depth":2},{"value":"Go中的模糊测试","url":"#go中的模糊测试","depth":2},{"value":"HTTP服务的模糊测试","url":"#http服务的模糊测试","depth":2},{"value":"结论","url":"#结论-6","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go语言 HTTP 服务模糊测试教程","datePublished":"2024-11-12T00:00:00.000Z","dateModified":"2024-11-12T00:00:00.000Z","description":"Go语言的模糊测试（Fuzzing）是一种通过输入大量随机数据来发现程序潜在bug的自动化测试技术。Go 1.18后，它被加入标准库，使开发者能更容易地对HTTP服务和其他函数进行模糊测试。这种测试方法特别擅长发现那些在常规测试中难以发现的边界情况和异常问题。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/go/fuzzing-test","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"ThrottleX——高性能分布式限流库","date":"2024-11-11T00:00:00.000Z","tags":["backend","go"],"draft":false,"summary":"ThrottleX 是一个用 Go 语言实现的高性能分布式限流库，提供了三种主流限流算法的实现。该项目特别注重性能优化和分布式场景支持，可以轻松应对高并发环境下的限流需求。ThrottleX 根据定义的策略（如固定窗口、滑动窗口和令牌桶）限制可以到达后端（无论是 Web 服务器、API 等）的请求数量，从而管理请求流。","layout":"PostSimple","type":"Blog","readingTime":{"text":"20 min read","minutes":19.355,"time":1161300,"words":3871},"slug":"go/ThrottleX","path":"blog/go/ThrottleX","filePath":"blog/go/ThrottleX.mdx","toc":[{"value":"目录","url":"#目录-9","depth":2},{"value":"项目简介","url":"#项目简介","depth":2},{"value":"项目链接","url":"#项目链接","depth":2},{"value":"系统架构图","url":"#系统架构图","depth":2},{"value":"总架构","url":"#总架构","depth":3},{"value":"请求流","url":"#请求流","depth":3},{"value":"数据存储和限流规则","url":"#数据存储和限流规则","depth":3},{"value":"核心功能","url":"#核心功能","depth":2},{"value":"1. 多种限流算法","url":"#1-多种限流算法","depth":3},{"value":"1.1 固定窗口限流","url":"#11-固定窗口限流","depth":4},{"value":"1.2 滑动窗口限流","url":"#12-滑动窗口限流","depth":4},{"value":"1.3 令牌桶限流","url":"#13-令牌桶限流","depth":4},{"value":"2. 存储层设计","url":"#2-存储层设计","depth":3},{"value":"2.1 统一存储接口","url":"#21-统一存储接口","depth":4},{"value":"2.2 内存存储实现","url":"#22-内存存储实现","depth":4},{"value":"2.3 Redis 存储实现","url":"#23-redis-存储实现","depth":4},{"value":"3. 并发控制","url":"#3-并发控制","depth":3},{"value":"3.1 互斥锁设计","url":"#31-互斥锁设计","depth":4},{"value":"关键优化","url":"#关键优化","depth":2},{"value":"内存优化","url":"#内存优化","depth":3},{"value":"Redis 优化","url":"#redis-优化","depth":3},{"value":"断路器以防止过载","url":"#断路器以防止过载","depth":3},{"value":"存在的问题","url":"#存在的问题","depth":2},{"value":"Go 的垃圾收集","url":"#go-的垃圾收集","depth":3},{"value":"Redis 复制延迟","url":"#redis-复制延迟","depth":3},{"value":"网络延迟","url":"#网络延迟","depth":3},{"value":"自适应速率限制","url":"#自适应速率限制","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"ThrottleX——高性能分布式限流库","datePublished":"2024-11-11T00:00:00.000Z","dateModified":"2024-11-11T00:00:00.000Z","description":"ThrottleX 是一个用 Go 语言实现的高性能分布式限流库，提供了三种主流限流算法的实现。该项目特别注重性能优化和分布式场景支持，可以轻松应对高并发环境下的限流需求。ThrottleX 根据定义的策略（如固定窗口、滑动窗口和令牌桶）限制可以到达后端（无论是 Web 服务器、API 等）的请求数量，从而管理请求流。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/go/ThrottleX","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"Databricks 集群与 Spark 高并发场景优化指南","date":"2024-11-07T00:00:00.000Z","tags":["backend"],"draft":false,"summary":"本文介绍了针对Databricks集群在高并发场景下的优化策略。主要包括两个层面：集群优化(启用Photon加速、Delta缓存、高并发模式等)和代码优化(合理使用UDFs、collect()、广播变量、分区调优等)。通过这些措施可以显著提升集群性能，建议根据实际场景选择合适的优化组合。","layout":"PostSimple","type":"Blog","readingTime":{"text":"5 min read","minutes":4.505,"time":270300,"words":901},"slug":"backend/spark-optimize","path":"blog/backend/spark-optimize","filePath":"blog/backend/spark-optimize.mdx","toc":[{"value":"集群级别优化","url":"#集群级别优化","depth":2},{"value":"1. 启用 Photon 加速引擎","url":"#1-启用-photon-加速引擎","depth":3},{"value":"2. 启用磁盘缓存(Delta 缓存)","url":"#2-启用磁盘缓存delta-缓存","depth":3},{"value":"3. 高并发集群模式","url":"#3-高并发集群模式","depth":3},{"value":"4. 调整 Spark 最大并发运行数","url":"#4-调整-spark-最大并发运行数","depth":3},{"value":"5. 启用删除向量","url":"#5-启用删除向量","depth":3},{"value":"代码层面优化","url":"#代码层面优化","depth":2},{"value":"1. 使用 Databricks 特有功能","url":"#1-使用-databricks-特有功能","depth":3},{"value":"2. 谨慎使用 Spark UDFs","url":"#2-谨慎使用-spark-udfs","depth":3},{"value":"3. 合理使用 collect()","url":"#3-合理使用-collect","depth":3},{"value":"4. broadcast 变量的使用","url":"#4-broadcast-变量的使用","depth":3},{"value":"5. 分区调优","url":"#5-分区调优","depth":3},{"value":"6. 启用自适应查询执行(AQE)","url":"#6-启用自适应查询执行aqe","depth":3},{"value":"7. 谓词下推","url":"#7-谓词下推","depth":3},{"value":"8. 合理使用数据框缓存","url":"#8-合理使用数据框缓存","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Databricks 集群与 Spark 高并发场景优化指南","datePublished":"2024-11-07T00:00:00.000Z","dateModified":"2024-11-07T00:00:00.000Z","description":"本文介绍了针对Databricks集群在高并发场景下的优化策略。主要包括两个层面：集群优化(启用Photon加速、Delta缓存、高并发模式等)和代码优化(合理使用UDFs、collect()、广播变量、分区调优等)。通过这些措施可以显著提升集群性能，建议根据实际场景选择合适的优化组合。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/backend/spark-optimize","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"树状数组（Binary Indexed Tree/Fenwick Tree）详解","date":"2024-11-06T00:00:00.000Z","tags":["algorithm"],"draft":false,"summary":"树状数组是一种高效的数据结构，用于处理前缀和查询和单点修改的问题。它通过二进制分段的方式，实现高效的修改和查询操作。相比线段树，它的实现更简单，常数更小，但功能相对受限。在实际应用中，如果问题可以用树状数组解决，它通常是比线段树更好的选择。","layout":"PostSimple","type":"Blog","readingTime":{"text":"9 min read","minutes":8.905,"time":534300,"words":1781},"slug":"algorithm/binary-indexed-tree","path":"blog/algorithm/binary-indexed-tree","filePath":"blog/algorithm/binary-indexed-tree.mdx","toc":[{"value":"1. 为什么需要树状数组？","url":"#1-为什么需要树状数组","depth":2},{"value":"1.1 问题起源","url":"#11-问题起源","depth":3},{"value":"1.2 树状数组的本质","url":"#12-树状数组的本质","depth":3},{"value":"2. 树状数组的设计思想","url":"#2-树状数组的设计思想","depth":2},{"value":"2.1 核心思想","url":"#21-核心思想","depth":3},{"value":"2.2 为什么这样设计是高效的？","url":"#22-为什么这样设计是高效的","depth":3},{"value":"3. 树状数组的应用场景","url":"#3-树状数组的应用场景","depth":2},{"value":"3.1 实际应用场景","url":"#31-实际应用场景","depth":3},{"value":"3.2 算法题中的应用","url":"#32-算法题中的应用","depth":3},{"value":"4. 基本操作","url":"#4-基本操作","depth":2},{"value":"4.1 完整的树状数组实现","url":"#41-完整的树状数组实现","depth":3},{"value":"4.2 二维树状数组","url":"#42-二维树状数组","depth":3},{"value":"5. 树状数组的优化和扩展","url":"#5-树状数组的优化和扩展","depth":2},{"value":"5.1 区间修改","url":"#51-区间修改","depth":3},{"value":"5.2 离散化处理","url":"#52-离散化处理","depth":3},{"value":"6. LeetCode 练习题","url":"#6-leetcode-练习题","depth":2},{"value":"6.1 基础题目","url":"#61-基础题目","depth":3},{"value":"6.2 进阶题目","url":"#62-进阶题目","depth":3},{"value":"6.3 高级题目","url":"#63-高级题目","depth":3},{"value":"6.4 练习建议","url":"#64-练习建议","depth":3},{"value":"7. 总结","url":"#7-总结","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"树状数组（Binary Indexed Tree/Fenwick Tree）详解","datePublished":"2024-11-06T00:00:00.000Z","dateModified":"2024-11-06T00:00:00.000Z","description":"树状数组是一种高效的数据结构，用于处理前缀和查询和单点修改的问题。它通过二进制分段的方式，实现高效的修改和查询操作。相比线段树，它的实现更简单，常数更小，但功能相对受限。在实际应用中，如果问题可以用树状数组解决，它通常是比线段树更好的选择。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/algorithm/binary-indexed-tree","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"线段树（Segment Tree）详解","date":"2024-11-06T00:00:00.000Z","tags":["algorithm"],"draft":false,"summary":"线段树是一种高效的数据结构，用于处理区间查询和修改操作。它通过将区间划分为多个小区间，并用树状结构管理这些区间的数据，从而在查询和修改操作之间取得了很好的平衡。","layout":"PostSimple","type":"Blog","readingTime":{"text":"14 min read","minutes":13.57,"time":814200,"words":2714},"slug":"algorithm/segment-tree","path":"blog/algorithm/segment-tree","filePath":"blog/algorithm/segment-tree.mdx","toc":[{"value":"1. 为什么需要线段树？","url":"#1-为什么需要线段树","depth":2},{"value":"1.1 问题起源","url":"#11-问题起源-1","depth":3},{"value":"1.2 线段树的本质","url":"#12-线段树的本质","depth":3},{"value":"2. 线段树的设计思想","url":"#2-线段树的设计思想","depth":2},{"value":"2.1 核心思想","url":"#21-核心思想-1","depth":3},{"value":"2.2 为什么这样设计是高效的？","url":"#22-为什么这样设计是高效的-1","depth":3},{"value":"3. 线段树的应用场景","url":"#3-线段树的应用场景","depth":2},{"value":"3.1 实际应用场景","url":"#31-实际应用场景-1","depth":3},{"value":"3.2 算法题中的应用","url":"#32-算法题中的应用-1","depth":3},{"value":"4. 线段树的优化技巧","url":"#4-线段树的优化技巧","depth":2},{"value":"4.1 内存优化","url":"#41-内存优化","depth":3},{"value":"4.2 性能优化","url":"#42-性能优化","depth":3},{"value":"5. 线段树的扩展","url":"#5-线段树的扩展","depth":2},{"value":"5.1 二维线段树","url":"#51-二维线段树","depth":3},{"value":"5.2 可持久化线段树","url":"#52-可持久化线段树","depth":3},{"value":"6. 基本操作","url":"#6-基本操作","depth":2},{"value":"6.1 完整的线段树实现","url":"#61-完整的线段树实现","depth":3},{"value":"6.2 其他常见操作的实现","url":"#62-其他常见操作的实现","depth":3},{"value":"7. 总结","url":"#7-总结-1","depth":2},{"value":"8. LeetCode 练习题","url":"#8-leetcode-练习题","depth":2},{"value":"8.1 基础题目","url":"#81-基础题目","depth":3},{"value":"8.2 进阶题目","url":"#82-进阶题目","depth":3},{"value":"8.3 高级题目","url":"#83-高级题目","depth":3},{"value":"8.4 扩展应用","url":"#84-扩展应用","depth":3},{"value":"8.5 练习建议","url":"#85-练习建议","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"线段树（Segment Tree）详解","datePublished":"2024-11-06T00:00:00.000Z","dateModified":"2024-11-06T00:00:00.000Z","description":"线段树是一种高效的数据结构，用于处理区间查询和修改操作。它通过将区间划分为多个小区间，并用树状结构管理这些区间的数据，从而在查询和修改操作之间取得了很好的平衡。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/algorithm/segment-tree","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"InnoDB 引擎","date":"2024-10-22T00:00:00.000Z","tags":["database"],"draft":false,"summary":"InnoDB 是 MySQL 的默认存储引擎，提供了 ACID 事务支持、行级锁定、外键约束等特性。通过多版本并发控制（MVCC）机制实现了高并发性能，同时保证了数据的一致性和可靠性。","layout":"PostSimple","type":"Blog","readingTime":{"text":"13 min read","minutes":12.585,"time":755100,"words":2517},"slug":"database/Innodb-engine","path":"blog/database/Innodb-engine","filePath":"blog/database/Innodb-engine.mdx","toc":[{"value":"InnoDB 简介","url":"#innodb-简介","depth":2},{"value":"InnoDB 的主要优势","url":"#innodb-的主要优势","depth":3},{"value":"InnoDB 表的规则","url":"#innodb-表的规则","depth":3},{"value":"InnoDB 和 ACID 模型","url":"#innodb-和-acid-模型","depth":2},{"value":"A: 原子性","url":"#a-原子性","depth":3},{"value":"C: 一致性","url":"#c-一致性","depth":3},{"value":"I: 隔离性","url":"#i-隔离性","depth":3},{"value":"D: 持久性","url":"#d-持久性","depth":3},{"value":"InnoDB 多版本控制","url":"#innodb-多版本控制","depth":2},{"value":"多版本控制和二级索引","url":"#多版本控制和二级索引","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"InnoDB 引擎","datePublished":"2024-10-22T00:00:00.000Z","dateModified":"2024-10-22T00:00:00.000Z","description":"InnoDB 是 MySQL 的默认存储引擎，提供了 ACID 事务支持、行级锁定、外键约束等特性。通过多版本并发控制（MVCC）机制实现了高并发性能，同时保证了数据的一致性和可靠性。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/database/Innodb-engine","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"加密流量中邮件协议的识别","date":"2024-10-21T00:00:00.000Z","tags":["network security"],"draft":false,"summary":"加密邮件协议（SMTP、POP3、IMAP）可通过特定端口号、SNI、服务器证书信息和流量模式来识别。SMTP 通常使用 465 或 587 端口，POP3 使用 995 端口，IMAP 使用 993 端口。分析 TLS 握手特征和证书的 Common Name 也有助于识别。这种识别对网络管理、安全分析和性能优化至关重要，能帮助更好地理解和管理网络通信。","layout":"PostSimple","type":"Blog","readingTime":{"text":"5 min read","minutes":4.02,"time":241200,"words":804},"slug":"security/encrypted-email-protocol","path":"blog/security/encrypted-email-protocol","filePath":"blog/security/encrypted-email-protocol.mdx","toc":[{"value":"1. SMTP (Simple Mail Transfer Protocol)","url":"#1-smtp-simple-mail-transfer-protocol","depth":2},{"value":"1.1 Python 代码示例 (使用163邮箱服务器)","url":"#11-python-代码示例-使用163邮箱服务器","depth":3},{"value":"1.2 流量特征分析","url":"#12-流量特征分析","depth":3},{"value":"1.2.1 通过端口和 SNI 识别","url":"#121-通过端口和-sni-识别","depth":4},{"value":"1.2.2 TLS 握手特征","url":"#122-tls-握手特征","depth":4},{"value":"1.2.3 指纹","url":"#123-指纹","depth":4},{"value":"2. POP3 (Post Office Protocol version 3)","url":"#2-pop3-post-office-protocol-version-3","depth":2},{"value":"2.1 Python 代码示例","url":"#21-python-代码示例","depth":3},{"value":"2.2 流量特征分析","url":"#22-流量特征分析","depth":3},{"value":"2.2.1 通过端口和 SNI 识别","url":"#221-通过端口和-sni-识别","depth":4},{"value":"2.2.2 证书信息","url":"#222-证书信息","depth":4},{"value":"2.2.3 流量模式","url":"#223-流量模式","depth":4},{"value":"3. IMAP (Internet Message Access Protocol)","url":"#3-imap-internet-message-access-protocol","depth":2},{"value":"3.1 Python 代码示例","url":"#31-python-代码示例","depth":3},{"value":"3.2 流量特征分析","url":"#32-流量特征分析","depth":3},{"value":"3.2.1 通过端口和 SNI 识别","url":"#321-通过端口和-sni-识别","depth":4},{"value":"3.2.2 证书信息","url":"#322-证书信息","depth":4},{"value":"3.2.3 流量模式","url":"#323-流量模式","depth":4},{"value":"总结","url":"#总结-14","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"加密流量中邮件协议的识别","datePublished":"2024-10-21T00:00:00.000Z","dateModified":"2024-10-21T00:00:00.000Z","description":"加密邮件协议（SMTP、POP3、IMAP）可通过特定端口号、SNI、服务器证书信息和流量模式来识别。SMTP 通常使用 465 或 587 端口，POP3 使用 995 端口，IMAP 使用 993 端口。分析 TLS 握手特征和证书的 Common Name 也有助于识别。这种识别对网络管理、安全分析和性能优化至关重要，能帮助更好地理解和管理网络通信。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/security/encrypted-email-protocol","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"获取非加密邮件协议中的用户名和密码——安全风险演示","date":"2024-10-18T00:00:00.000Z","tags":["tools","network security"],"draft":false,"summary":"本文演示了如何通过Python脚本和Wireshark工具获取非加密协议中的用户名和密码,揭示了使用非加密邮件协议的安全风险。文章强调了采用加密协议、启用双因素认证等安全措施的重要性,旨在提高读者的网络安全意识。","layout":"PostSimple","type":"Blog","readingTime":{"text":"7 min read","minutes":6.345,"time":380700,"words":1269},"slug":"tools/hack-email","path":"blog/tools/hack-email","filePath":"blog/tools/hack-email.mdx","toc":[{"value":"引言","url":"#引言-7","depth":2},{"value":"背景知识","url":"#背景知识","depth":2},{"value":"步骤","url":"#步骤-2","depth":2},{"value":"SMTP","url":"#smtp","depth":3},{"value":"1. 使用Python脚本登录邮箱服务器","url":"#1-使用python脚本登录邮箱服务器","depth":4},{"value":"2. 使用Wireshark抓取SMTP协议流量","url":"#2-使用wireshark抓取smtp协议流量","depth":4},{"value":"3. 分析抓取的数据包","url":"#3-分析抓取的数据包","depth":4},{"value":"4. 解码认证信息","url":"#4-解码认证信息","depth":4},{"value":"POP3","url":"#pop3","depth":3},{"value":"1. 使用Python脚本连接POP3服务器","url":"#1-使用python脚本连接pop3服务器","depth":4},{"value":"2. 使用Wireshark抓取POP3协议流量","url":"#2-使用wireshark抓取pop3协议流量","depth":4},{"value":"3. 分析抓取的数据包","url":"#3-分析抓取的数据包-1","depth":4},{"value":"IMAP","url":"#imap","depth":3},{"value":"1. 使用Python脚本连接IMAP服务器","url":"#1-使用python脚本连接imap服务器","depth":4},{"value":"2. 使用Wireshark抓取IMAP协议流量","url":"#2-使用wireshark抓取imap协议流量","depth":4},{"value":"3. 分析抓取的数据包","url":"#3-分析抓取的数据包-2","depth":4},{"value":"安全隐患及防护措施","url":"#安全隐患及防护措施","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"获取非加密邮件协议中的用户名和密码——安全风险演示","datePublished":"2024-10-18T00:00:00.000Z","dateModified":"2024-10-18T00:00:00.000Z","description":"本文演示了如何通过Python脚本和Wireshark工具获取非加密协议中的用户名和密码,揭示了使用非加密邮件协议的安全风险。文章强调了采用加密协议、启用双因素认证等安全措施的重要性,旨在提高读者的网络安全意识。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/tools/hack-email","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"Go语言的内存镇流器","date":"2024-10-17T00:00:00.000Z","tags":["backend","go"],"draft":false,"summary":"我们通过引入内存镇流器减少了Go应用程序的垃圾回收（GC）周期频率，从而改善了API响应时间。这种做法允许堆在更大范围内增长，减少了GC辅助延迟，而镇流器的虚拟内存分配几乎不消耗实际RAM。相比调整GOGC值，使用镇流器更易于推理与管理。最后，深入分析性能瓶颈是提高应用效率的关键。","layout":"PostSimple","type":"Blog","readingTime":{"text":"27 min read","minutes":26.45,"time":1587000,"words":5290},"slug":"go/memory-ballast","path":"blog/go/memory-ballast","filePath":"blog/go/memory-ballast.mdx","toc":[{"value":"背景介绍","url":"#背景介绍","depth":2},{"value":"挑战与应对","url":"#挑战与应对","depth":2},{"value":"方案调研","url":"#方案调研","depth":2},{"value":"什么是垃圾收集器（GC）？","url":"#什么是垃圾收集器gc","depth":2},{"value":"Go的垃圾收集器","url":"#go的垃圾收集器","depth":2},{"value":"标记和清除阶段","url":"#标记和清除阶段","depth":3},{"value":"关键术语","url":"#关键术语","depth":3},{"value":"标记阶段与性能的关系","url":"#标记阶段与性能的关系","depth":3},{"value":"Visage应用程序中的实际问题","url":"#visage应用程序中的实际问题","depth":3},{"value":"Pacer（步调控制器）","url":"#pacer步调控制器","depth":2},{"value":"引入内存镇流器（Ballast）","url":"#引入内存镇流器ballast","depth":3},{"value":"解释","url":"#解释","depth":3},{"value":"1. 为什么使用内存镇流器？","url":"#1-为什么使用内存镇流器","depth":4},{"value":"2. 这不会浪费10 GiB的物理内存吗？","url":"#2-这不会浪费10-gib的物理内存吗","depth":4},{"value":"API延迟","url":"#api延迟","depth":2},{"value":"GC assists","url":"#gc-assists","depth":3},{"value":"API延迟的影响","url":"#api延迟的影响","depth":4},{"value":"总结","url":"#总结-6","depth":2},{"value":"一些最后的思考","url":"#一些最后的思考","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go语言的内存镇流器","datePublished":"2024-10-17T00:00:00.000Z","dateModified":"2024-10-17T00:00:00.000Z","description":"我们通过引入内存镇流器减少了Go应用程序的垃圾回收（GC）周期频率，从而改善了API响应时间。这种做法允许堆在更大范围内增长，减少了GC辅助延迟，而镇流器的虚拟内存分配几乎不消耗实际RAM。相比调整GOGC值，使用镇流器更易于推理与管理。最后，深入分析性能瓶颈是提高应用效率的关键。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/go/memory-ballast","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"领队随想","date":"2024-09-17T00:00:00.000Z","tags":["diary"],"draft":false,"summary":"领队随想","layout":"PostSimple","type":"Blog","readingTime":{"text":"4 min read","minutes":3.735,"time":224100,"words":747},"slug":"diary/2024-09-17","path":"blog/diary/2024-09-17","filePath":"blog/diary/2024-09-17.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"领队随想","datePublished":"2024-09-17T00:00:00.000Z","dateModified":"2024-09-17T00:00:00.000Z","description":"领队随想","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/diary/2024-09-17","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"解锁Web3社区力量：掌握Guild SDK，打造你的去中心化王国","date":"2024-09-03T00:00:00.000Z","tags":["tools"],"draft":false,"summary":"Guild SDK是构建去中心化自治组织(DAO)的强大工具。本教程带你深入了解SDK的核心功能，从安装到高级应用。无论你是区块链新手还是经验丰富的开发者，都能在这里找到构建下一代Web3社区的关键。","layout":"PostSimple","type":"Blog","readingTime":{"text":"16 min read","minutes":15.425,"time":925500,"words":3085},"slug":"tools/guild-sdk","path":"blog/tools/guild-sdk","filePath":"blog/tools/guild-sdk.mdx","toc":[{"value":"目录","url":"#目录-15","depth":2},{"value":"简介","url":"#简介-1","depth":2},{"value":"安装","url":"#安装-1","depth":2},{"value":"导入包并创建Guild客户端","url":"#导入包并创建guild客户端","depth":2},{"value":"签名函数和认证","url":"#签名函数和认证","depth":2},{"value":"从ethers钱包创建签名者","url":"#从ethers钱包创建签名者","depth":3},{"value":"为web3-react创建自定义签名者","url":"#为web3-react创建自定义签名者","depth":3},{"value":"为wagmi创建自定义签名者","url":"#为wagmi创建自定义签名者","depth":3},{"value":"支持EIP-1271智能合约钱包","url":"#支持eip-1271智能合约钱包","depth":3},{"value":"客户端","url":"#客户端","depth":2},{"value":"Guild客户端","url":"#guild客户端","depth":3},{"value":"积分系统","url":"#积分系统","depth":4},{"value":"Guild管理员客户端","url":"#guild管理员客户端","depth":3},{"value":"Guild奖励客户端","url":"#guild奖励客户端","depth":3},{"value":"角色客户端","url":"#角色客户端","depth":3},{"value":"需求客户端","url":"#需求客户端","depth":3},{"value":"角色奖励客户端","url":"#角色奖励客户端","depth":3},{"value":"用户客户端","url":"#用户客户端","depth":3},{"value":"用户地址客户端","url":"#用户地址客户端","depth":3},{"value":"用户平台客户端","url":"#用户平台客户端","depth":3},{"value":"模块化/多平台架构","url":"#模块化多平台架构","depth":2},{"value":"示例","url":"#示例-2","depth":2},{"value":"从创建 Guild 到加入的示例流程","url":"#从创建-guild-到加入的示例流程","depth":3},{"value":"多个 Telegram 群组的 Guild","url":"#多个-telegram-群组的-guild","depth":3},{"value":"结语","url":"#结语-2","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"解锁Web3社区力量：掌握Guild SDK，打造你的去中心化王国","datePublished":"2024-09-03T00:00:00.000Z","dateModified":"2024-09-03T00:00:00.000Z","description":"Guild SDK是构建去中心化自治组织(DAO)的强大工具。本教程带你深入了解SDK的核心功能，从安装到高级应用。无论你是区块链新手还是经验丰富的开发者，都能在这里找到构建下一代Web3社区的关键。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/tools/guild-sdk","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"掌握网络侦察利器：深入解析5大操作系统指纹识别工具","date":"2024-08-26T00:00:00.000Z","tags":["network security","tools"],"draft":false,"summary":"本文深入探讨了Nmap、RING、p0f、Ettercap和NetworkMiner五款强大的操作系统指纹识别工具。从安装步骤到使用方法，再到结果分析，文章全面介绍了这些工具的核心功能和应用场景，为网络安全专业人员提供了实用的指南。","layout":"PostSimple","type":"Blog","readingTime":{"text":"29 min read","minutes":28.515,"time":1710900,"words":5703},"slug":"tools/intrusion-detection-tools","path":"blog/tools/intrusion-detection-tools","filePath":"blog/tools/intrusion-detection-tools.mdx","toc":[{"value":"目录","url":"#目录-16","depth":2},{"value":"Nmap","url":"#nmap","depth":2},{"value":"安装","url":"#安装-2","depth":3},{"value":"Windows系统","url":"#windows系统","depth":4},{"value":"Linux系统","url":"#linux系统","depth":4},{"value":"macOS系统","url":"#macos系统","depth":4},{"value":"基本使用","url":"#基本使用","depth":3},{"value":"基本的操作系统扫描","url":"#基本的操作系统扫描","depth":4},{"value":"更详细的操作系统扫描","url":"#更详细的操作系统扫描","depth":4},{"value":"解释操作系统指纹结果","url":"#解释操作系统指纹结果","depth":4},{"value":"RING","url":"#ring","depth":2},{"value":"安装RING","url":"#安装ring","depth":3},{"value":"1. 下载RING","url":"#1-下载ring","depth":4},{"value":"2. 编译和安装","url":"#2-编译和安装","depth":4},{"value":"3. 验证安装","url":"#3-验证安装","depth":4},{"value":"使用","url":"#使用-1","depth":3},{"value":"1. 基本命令格式","url":"#1-基本命令格式","depth":4},{"value":"2. 参数说明","url":"#2-参数说明","depth":4},{"value":"3. 示例使用","url":"#3-示例使用","depth":4},{"value":"4. 分析结果","url":"#4-分析结果","depth":4},{"value":"5. 高级选项","url":"#5-高级选项","depth":4},{"value":"Xprobe2","url":"#xprobe2","depth":2},{"value":"安装","url":"#安装-3","depth":3},{"value":"系统要求","url":"#系统要求","depth":4},{"value":"安装步骤","url":"#安装步骤","depth":4},{"value":"使用","url":"#使用-2","depth":3},{"value":"基本命令格式","url":"#基本命令格式","depth":4},{"value":"常用选项","url":"#常用选项","depth":4},{"value":"示例使用","url":"#示例使用","depth":4},{"value":"输出结果","url":"#输出结果-1","depth":4},{"value":"输出结果分析","url":"#输出结果分析","depth":4},{"value":"p0f","url":"#p0f","depth":2},{"value":"安装","url":"#安装-4","depth":3},{"value":"1. 系统要求","url":"#1-系统要求","depth":4},{"value":"2. 安装步骤","url":"#2-安装步骤","depth":4},{"value":"使用","url":"#使用-3","depth":3},{"value":"1. 启动p0f","url":"#1-启动p0f","depth":4},{"value":"2. 监听网络流量","url":"#2-监听网络流量","depth":4},{"value":"3. 查看识别结果","url":"#3-查看识别结果","depth":4},{"value":"4. 其他命令选项","url":"#4-其他命令选项","depth":4},{"value":"Ettercap","url":"#ettercap","depth":2},{"value":"安装","url":"#安装-5","depth":3},{"value":"1. 系统要求","url":"#1-系统要求-1","depth":4},{"value":"2. 安装步骤","url":"#2-安装步骤-1","depth":4},{"value":"使用","url":"#使用-4","depth":3},{"value":"输出结果分析","url":"#输出结果分析-1","depth":3},{"value":"NetworkMiner","url":"#networkminer","depth":2},{"value":"安装","url":"#安装-6","depth":3},{"value":"1. 系统要求","url":"#1-系统要求-2","depth":4},{"value":"2. 安装步骤","url":"#2-安装步骤-2","depth":4},{"value":"使用","url":"#使用-5","depth":3},{"value":"1. 捕获网络流量","url":"#1-捕获网络流量","depth":4},{"value":"2. 分析捕获的流量","url":"#2-分析捕获的流量","depth":4},{"value":"3. 提取凭据","url":"#3-提取凭据","depth":4},{"value":"4. 主机清单","url":"#4-主机清单","depth":4},{"value":"5. 操作系统识别","url":"#5-操作系统识别","depth":4},{"value":"SinFP","url":"#sinfp","depth":2},{"value":"安装SinFP","url":"#安装sinfp","depth":3},{"value":"1. 系统要求","url":"#1-系统要求-3","depth":4},{"value":"2. 安装步骤","url":"#2-安装步骤-3","depth":4},{"value":"使用","url":"#使用-6","depth":3},{"value":"1. 基本命令格式","url":"#1-基本命令格式-1","depth":4},{"value":"2. 示例使用","url":"#2-示例使用","depth":4},{"value":"3. 输出结果示例","url":"#3-输出结果示例","depth":4},{"value":"4. 高级选项","url":"#4-高级选项","depth":4},{"value":"ZMap","url":"#zmap","depth":2},{"value":"安装","url":"#安装-7","depth":3},{"value":"软件库安装","url":"#软件库安装","depth":4},{"value":"源码安装","url":"#源码安装","depth":4},{"value":"使用","url":"#使用-7","depth":3},{"value":"扫描指定端口","url":"#扫描指定端口","depth":4},{"value":"扫描所有端口","url":"#扫描所有端口","depth":4},{"value":"输出结果","url":"#输出结果-2","depth":4},{"value":"输出结果分析","url":"#输出结果分析-2","depth":4},{"value":"其他选项","url":"#其他选项","depth":4}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"掌握网络侦察利器：深入解析5大操作系统指纹识别工具","datePublished":"2024-08-26T00:00:00.000Z","dateModified":"2024-08-26T00:00:00.000Z","description":"本文深入探讨了Nmap、RING、p0f、Ettercap和NetworkMiner五款强大的操作系统指纹识别工具。从安装步骤到使用方法，再到结果分析，文章全面介绍了这些工具的核心功能和应用场景，为网络安全专业人员提供了实用的指南。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/tools/intrusion-detection-tools","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"解密数字足迹:突破性网络流量指纹识别技术揭秘","date":"2024-08-19T00:00:00.000Z","tags":["paper reading","machine learing","network security"],"draft":false,"summary":"本文深入探讨四种前沿网络流量指纹识别技术,涵盖从细粒度动态指纹提取到基于哈希的快速识别。我们剖析每种方法的核心理念、创新特点及潜在应用,为读者呈现网络安全领域的最新进展。无论您是安全专家还是技术爱好者,都能在此找到启发性的见解和实用的应用思路。","layout":"PostSimple","type":"Blog","readingTime":{"text":"16 min read","minutes":15.84,"time":950400,"words":3168},"slug":"paper/fringerprint-identification-papers","path":"blog/paper/fringerprint-identification-papers","filePath":"blog/paper/fringerprint-identification-papers.mdx","toc":[{"value":"目录","url":"#目录-13","depth":2},{"value":"Fine-Grained High-Utility Dynamic Fingerprinting Extraction for Network Traffic Analysis","url":"#fine-grained-high-utility-dynamic-fingerprinting-extraction-for-network-traffic-analysis","depth":2},{"value":"概要","url":"#概要","depth":3},{"value":"数据集","url":"#数据集-2","depth":3},{"value":"输出结果","url":"#输出结果","depth":3},{"value":"总结","url":"#总结-8","depth":3},{"value":"FLOWPRINT: Semi-Supervised Mobile-App Fingerprinting on Encrypted Network Traffic","url":"#flowprint-semi-supervised-mobile-app-fingerprinting-on-encrypted-network-traffic","depth":2},{"value":"概要","url":"#概要-1","depth":3},{"value":"数据集","url":"#数据集-3","depth":3},{"value":"特征值","url":"#特征值","depth":3},{"value":"源代码","url":"#源代码-1","depth":3},{"value":"总结","url":"#总结-9","depth":3},{"value":"Locality Sensitive Hashing for Network Traffic Fingerprinting","url":"#locality-sensitive-hashing-for-network-traffic-fingerprinting","depth":2},{"value":"概述","url":"#概述-3","depth":3},{"value":"特点","url":"#特点","depth":3},{"value":"数据集","url":"#数据集-4","depth":3},{"value":"总结","url":"#总结-10","depth":3},{"value":"Fingerprinting Network Entities Based on Traffic Analysis in High-Speed Network Environment","url":"#fingerprinting-network-entities-based-on-traffic-analysis-in-high-speed-network-environment","depth":2},{"value":"概要","url":"#概要-2","depth":3},{"value":"数据集","url":"#数据集-5","depth":3},{"value":"特征值","url":"#特征值-1","depth":3},{"value":"总结","url":"#总结-11","depth":3},{"value":"附录","url":"#附录","depth":2},{"value":"表1: 操作系统指纹识别","url":"#表1-操作系统指纹识别","depth":3},{"value":"表2: 网站指纹识别","url":"#表2-网站指纹识别","depth":3},{"value":"表3: 应用程序指纹识别","url":"#表3-应用程序指纹识别","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"解密数字足迹:突破性网络流量指纹识别技术揭秘","datePublished":"2024-08-19T00:00:00.000Z","dateModified":"2024-08-19T00:00:00.000Z","description":"本文深入探讨四种前沿网络流量指纹识别技术,涵盖从细粒度动态指纹提取到基于哈希的快速识别。我们剖析每种方法的核心理念、创新特点及潜在应用,为读者呈现网络安全领域的最新进展。无论您是安全专家还是技术爱好者,都能在此找到启发性的见解和实用的应用思路。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/paper/fringerprint-identification-papers","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"高效日志管理与监控","date":"2024-08-16T00:00:00.000Z","tags":["backend"],"draft":false,"summary":"本文详细介绍了如何将Django的日志记录与ELK Stack（Elasticsearch、Logstash、Kibana）及Prometheus + Grafana结合使用。通过配置Django的日志系统、设置Logstash接收日志、使用Elasticsearch存储数据，以及在Kibana和Grafana中可视化监控指标，开发者可以实现全面的日志管理和性能监控，提升应用程序的可维护性和可靠性。","layout":"PostSimple","type":"Blog","readingTime":{"text":"15 min read","minutes":14.41,"time":864600,"words":2882},"slug":"backend/log","path":"blog/backend/log","filePath":"blog/backend/log.mdx","toc":[{"value":"目录","url":"#目录-3","depth":2},{"value":"1. Django日志管理","url":"#1-django日志管理","depth":2},{"value":"1.1 Django日志配置","url":"#11-django日志配置","depth":3},{"value":"1.2 在Django中使用日志","url":"#12-在django中使用日志","depth":3},{"value":"2. ELK Stack: 高级日志管理解决方案","url":"#2-elk-stack-高级日志管理解决方案","depth":2},{"value":"2.1 Elasticsearch","url":"#21-elasticsearch","depth":3},{"value":"关键特性:","url":"#关键特性","depth":4},{"value":"安装和基本配置:","url":"#安装和基本配置","depth":4},{"value":"基本操作:","url":"#基本操作","depth":4},{"value":"2.2 Logstash","url":"#22-logstash","depth":3},{"value":"关键特性:","url":"#关键特性-1","depth":4},{"value":"配置Logstash:","url":"#配置logstash","depth":4},{"value":"2.3 Kibana","url":"#23-kibana","depth":3},{"value":"关键特性:","url":"#关键特性-2","depth":4},{"value":"安装和配置Kibana:","url":"#安装和配置kibana","depth":4},{"value":"使用Kibana:","url":"#使用kibana","depth":4},{"value":"3. Prometheus和Grafana: 实时监控解决方案","url":"#3-prometheus和grafana-实时监控解决方案","depth":2},{"value":"3.1 Prometheus","url":"#31-prometheus","depth":3},{"value":"安装和配置Prometheus:","url":"#安装和配置prometheus","depth":4},{"value":"使用Prometheus:","url":"#使用prometheus","depth":4},{"value":"3.2 在Django中集成Prometheus","url":"#32-在django中集成prometheus","depth":3},{"value":"3.3 Grafana","url":"#33-grafana","depth":3},{"value":"安装和配置Grafana:","url":"#安装和配置grafana","depth":4},{"value":"使用Grafana:","url":"#使用grafana","depth":4},{"value":"4. 整合使用","url":"#4-整合使用","depth":2},{"value":"4.1 Django配置","url":"#41-django配置","depth":3},{"value":"4.2 数据流","url":"#42-数据流","depth":3},{"value":"5. 最佳实践","url":"#5-最佳实践","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"高效日志管理与监控","datePublished":"2024-08-16T00:00:00.000Z","dateModified":"2024-08-16T00:00:00.000Z","description":"本文详细介绍了如何将Django的日志记录与ELK Stack（Elasticsearch、Logstash、Kibana）及Prometheus + Grafana结合使用。通过配置Django的日志系统、设置Logstash接收日志、使用Elasticsearch存储数据，以及在Kibana和Grafana中可视化监控指标，开发者可以实现全面的日志管理和性能监控，提升应用程序的可维护性和可靠性。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/backend/log","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"深入了解六种身份验证方法","date":"2024-08-14T00:00:00.000Z","tags":["backend"],"draft":false,"summary":"本文详细介绍了六种主流身份验证方法：JWT、OAuth、Basic Authentication、Token Authentication、Cookie-Based Authentication 和 SAML。每种方法的核心原理、工作流程及代码示例均涵盖，帮助您全面了解如何选择和实现适合的身份验证策略以确保安全和效率。","layout":"PostSimple","type":"Blog","readingTime":{"text":"28 min read","minutes":27.945,"time":1676700,"words":5589},"slug":"backend/authentication","path":"blog/backend/authentication","filePath":"blog/backend/authentication.mdx","toc":[{"value":"目录","url":"#目录-2","depth":2},{"value":"JWT","url":"#jwt","depth":2},{"value":"JWT 的结构","url":"#jwt-的结构","depth":4},{"value":"JWT 的验证流程","url":"#jwt-的验证流程","depth":4},{"value":"示例代码","url":"#示例代码-3","depth":4},{"value":"OAuth","url":"#oauth","depth":2},{"value":"OAuth 的基本原理","url":"#oauth-的基本原理","depth":3},{"value":"OAuth 授权流程","url":"#oauth-授权流程","depth":3},{"value":"示例代码","url":"#示例代码-4","depth":3},{"value":"Basic Authentication","url":"#basic-authentication","depth":2},{"value":"原理与工作流程","url":"#原理与工作流程","depth":3},{"value":"示例代码","url":"#示例代码-5","depth":3},{"value":"服务器端：Node.js 示例","url":"#服务器端nodejs-示例","depth":4},{"value":"客户端：使用 cURL 进行请求","url":"#客户端使用-curl-进行请求","depth":4},{"value":"注意事项","url":"#注意事项","depth":3},{"value":"Token authentication","url":"#token-authentication","depth":2},{"value":"原理","url":"#原理","depth":3},{"value":"优点","url":"#优点-1","depth":3},{"value":"Token Authentication 实例代码","url":"#token-authentication-实例代码","depth":3},{"value":"1. 安装依赖","url":"#1-安装依赖","depth":4},{"value":"2. 创建服务器","url":"#2-创建服务器","depth":4},{"value":"3. 运行步骤","url":"#3-运行步骤","depth":4},{"value":"注意事项","url":"#注意事项-1","depth":3},{"value":"Cookie-Based Authentication","url":"#cookie-based-authentication","depth":2},{"value":"原理","url":"#原理-1","depth":3},{"value":"步骤","url":"#步骤","depth":3},{"value":"示例代码","url":"#示例代码-6","depth":3},{"value":"服务器端代码（Node.js 和 Express）","url":"#服务器端代码nodejs-和-express","depth":4},{"value":"注意事项","url":"#注意事项-2","depth":4},{"value":"SAML Authentication","url":"#saml-authentication","depth":2},{"value":"SAML 认证的原理","url":"#saml-认证的原理","depth":3},{"value":"SAML 认证的基本流程","url":"#saml-认证的基本流程","depth":3},{"value":"SAML 认证的事例代码","url":"#saml-认证的事例代码","depth":3},{"value":"OpenID Authentication","url":"#openid-authentication","depth":2},{"value":"原理","url":"#原理-2","depth":3},{"value":"步骤","url":"#步骤-1","depth":3},{"value":"事例代码","url":"#事例代码","depth":3},{"value":"详细解释","url":"#详细解释","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"深入了解六种身份验证方法","datePublished":"2024-08-14T00:00:00.000Z","dateModified":"2024-08-14T00:00:00.000Z","description":"本文详细介绍了六种主流身份验证方法：JWT、OAuth、Basic Authentication、Token Authentication、Cookie-Based Authentication 和 SAML。每种方法的核心原理、工作流程及代码示例均涵盖，帮助您全面了解如何选择和实现适合的身份验证策略以确保安全和效率。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/backend/authentication","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"数据库分片如何提升性能","date":"2024-08-14T00:00:00.000Z","tags":["database"],"draft":false,"summary":"分片是应对网络应用进化挑战的有效方法，但不应忽视其他解决方案如云数据库和新数据库架构。虽然技术趋势不断变化，判断一项技术应基于其实际性、效率和成本效益。保持对新趋势的开放态度，同时也应重视成熟技术的优势。","layout":"PostSimple","type":"Blog","readingTime":{"text":"25 min read","minutes":24.055,"time":1443300,"words":4811},"slug":"database/database-sharding","path":"blog/database/database-sharding","filePath":"blog/database/database-sharding.mdx","toc":[{"value":"目录","url":"#目录-6","depth":2},{"value":"引言","url":"#引言-2","depth":2},{"value":"数据库碎片化","url":"#数据库碎片化","depth":2},{"value":"为什么需要分片","url":"#为什么需要分片","depth":2},{"value":"如何对数据库进行分片","url":"#如何对数据库进行分片","depth":2},{"value":"步骤 1：分析场景查询和数据分布以找到分片键和分片算法","url":"#步骤-1分析场景查询和数据分布以找到分片键和分片算法","depth":3},{"value":"RANGE","url":"#range","depth":4},{"value":"MOD","url":"#mod","depth":4},{"value":"TAG","url":"#tag","depth":4},{"value":"步骤 2：迁移现有数据","url":"#步骤-2迁移现有数据","depth":3},{"value":"步骤 3：将流量切换到新集群","url":"#步骤-3将流量切换到新集群","depth":3},{"value":"什么是良好的分片","url":"#什么是良好的分片","depth":2},{"value":"分片和复制","url":"#分片和复制","depth":2},{"value":"如何隐藏应用程序的复杂性","url":"#如何隐藏应用程序的复杂性","depth":2},{"value":"结论与趋势","url":"#结论与趋势","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"数据库分片如何提升性能","datePublished":"2024-08-14T00:00:00.000Z","dateModified":"2024-08-14T00:00:00.000Z","description":"分片是应对网络应用进化挑战的有效方法，但不应忽视其他解决方案如云数据库和新数据库架构。虽然技术趋势不断变化，判断一项技术应基于其实际性、效率和成本效益。保持对新趋势的开放态度，同时也应重视成熟技术的优势。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/database/database-sharding","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"CICFlowMeter：强大的网络流量分析工具","date":"2024-08-14T00:00:00.000Z","tags":["tools","network security"],"draft":false,"summary":"CICFlowMeter 是一款功能强大的网络流量生成器和分析器，广泛应用于网络流量分析和网络安全研究。它能够生成双向流并计算大量网络流量特征，支持实时捕获和离线分析，为研究人员和安全专家提供了丰富的数据分析能力。","layout":"PostSimple","type":"Blog","readingTime":{"text":"7 min read","minutes":6.525,"time":391500,"words":1305},"slug":"tools/cicflowmeter","path":"blog/tools/cicflowmeter","filePath":"blog/tools/cicflowmeter.mdx","toc":[{"value":"介绍","url":"#介绍-2","depth":2},{"value":"安装","url":"#安装","depth":2},{"value":"使用方法","url":"#使用方法","depth":2},{"value":"提取的特征值","url":"#提取的特征值","depth":2},{"value":"1. 流的基本特征","url":"#1-流的基本特征","depth":3},{"value":"2. 时间相关特征","url":"#2-时间相关特征","depth":3},{"value":"3. 分组大小相关特征","url":"#3-分组大小相关特征","depth":3},{"value":"4. 字节数相关特征","url":"#4-字节数相关特征","depth":3},{"value":"5. 标志位特征","url":"#5-标志位特征","depth":3},{"value":"6. 流的比率特征","url":"#6-流的比率特征","depth":3},{"value":"7. 标志的分布特征","url":"#7-标志的分布特征","depth":3},{"value":"8. 时间窗口相关特征","url":"#8-时间窗口相关特征","depth":3},{"value":"9. 字节和分组的累积特征","url":"#9-字节和分组的累积特征","depth":3},{"value":"高级用法","url":"#高级用法","depth":2},{"value":"注意事项","url":"#注意事项-4","depth":2},{"value":"结论","url":"#结论-16","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"CICFlowMeter：强大的网络流量分析工具","datePublished":"2024-08-14T00:00:00.000Z","dateModified":"2024-08-14T00:00:00.000Z","description":"CICFlowMeter 是一款功能强大的网络流量生成器和分析器，广泛应用于网络流量分析和网络安全研究。它能够生成双向流并计算大量网络流量特征，支持实时捕获和离线分析，为研究人员和安全专家提供了丰富的数据分析能力。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/tools/cicflowmeter","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"网络协议性能测试与抓包工具比较分析","date":"2024-08-13T00:00:00.000Z","tags":["tools","network security"],"draft":false,"summary":"本文详细比较了Scapy、tcpdump和tshark三种抓包工具在HTTP、DNS和ICMP协议下的性能表现。通过JMeter、dnsperf和fping进行压力测试，分析了各工具的抓包数量、丢包率、资源占用等指标。结果显示，Scapy灵活但效率较低，适合小规模分析；tcpdump高效轻量，适合大规模捕获；tshark则在协议分析能力上表现出色。文章还针对不同场景给出了工具选择建议，为网络管理员和安全分析师提供了valuable insights。","layout":"PostSimple","type":"Blog","readingTime":{"text":"10 min read","minutes":9.37,"time":562200,"words":1874},"slug":"tools/flow-collection-test","path":"blog/tools/flow-collection-test","filePath":"blog/tools/flow-collection-test.mdx","toc":[{"value":"HTTP 协议","url":"#http-协议","depth":2},{"value":"设置 JMeter 进行压力测试","url":"#设置-jmeter-进行压力测试","depth":3},{"value":"数据分析","url":"#数据分析","depth":3},{"value":"HTTP 实验结果","url":"#http-实验结果","depth":3},{"value":"DNS 协议","url":"#dns-协议","depth":2},{"value":"准备 DNS 查询文件","url":"#准备-dns-查询文件","depth":3},{"value":"使用 dnsperf 进行 DNS 压力测试","url":"#使用-dnsperf-进行-dns-压力测试","depth":3},{"value":"DNS 实验结果","url":"#dns-实验结果","depth":3},{"value":"ICMP 协议","url":"#icmp-协议","depth":2},{"value":"准备ip文件","url":"#准备ip文件","depth":3},{"value":"使用 fping 进行压力测试","url":"#使用-fping-进行压力测试-1","depth":3},{"value":"ICMP 实验结果","url":"#icmp-实验结果","depth":3},{"value":"结果评估","url":"#结果评估-1","depth":2},{"value":"结论","url":"#结论-17","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"网络协议性能测试与抓包工具比较分析","datePublished":"2024-08-13T00:00:00.000Z","dateModified":"2024-08-13T00:00:00.000Z","description":"本文详细比较了Scapy、tcpdump和tshark三种抓包工具在HTTP、DNS和ICMP协议下的性能表现。通过JMeter、dnsperf和fping进行压力测试，分析了各工具的抓包数量、丢包率、资源占用等指标。结果显示，Scapy灵活但效率较低，适合小规模分析；tcpdump高效轻量，适合大规模捕获；tshark则在协议分析能力上表现出色。文章还针对不同场景给出了工具选择建议，为网络管理员和安全分析师提供了valuable insights。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/tools/flow-collection-test","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"网络协议流量捕获和压力测试工具比较","date":"2024-08-12T00:00:00.000Z","tags":["network security","tools"],"draft":false,"summary":"本文详细介绍了多种网络流量捕获和分析工具，包括scapy、tshark和tcpdump，比较了它们在捕获HTTP、DNS和ICMP协议流量时的性能和资源消耗。文章提供了每种工具的安装方法、使用脚本和命令行示例，以及如何测量CPU使用率和内存占用。此外，还介绍了ICMP协议的压力测试方法，包括使用ping、fping、hping和nping等工具。这些信息对网络管理员和开发人员进行网络分析、调试和性能评估非常有用。","layout":"PostSimple","type":"Blog","readingTime":{"text":"14 min read","minutes":13.61,"time":816600,"words":2722},"slug":"tools/capture-traffic-tools","path":"blog/tools/capture-traffic-tools","filePath":"blog/tools/capture-traffic-tools.mdx","toc":[{"value":"引言","url":"#引言-5","depth":2},{"value":"介绍","url":"#介绍-1","depth":3},{"value":"工具","url":"#工具-2","depth":2},{"value":"安装 tcpdump","url":"#安装-tcpdump","depth":3},{"value":"安装 tshark","url":"#安装-tshark","depth":3},{"value":"安装 scapy","url":"#安装-scapy","depth":3},{"value":"HTTP协议","url":"#http协议","depth":2},{"value":"使用 scapy 捕获 HTTP 流量","url":"#使用-scapy-捕获-http-流量","depth":3},{"value":"使用 tshark 捕获 HTTP 流量","url":"#使用-tshark-捕获-http-流量","depth":3},{"value":"使用 tcpdump 捕获 HTTP 流量","url":"#使用-tcpdump-捕获-http-流量","depth":3},{"value":"DNS协议","url":"#dns协议","depth":2},{"value":"安装工具","url":"#安装工具","depth":3},{"value":"安装 dnsperf","url":"#安装-dnsperf","depth":4},{"value":"使用 scapy 捕获 DNS 流量","url":"#使用-scapy-捕获-dns-流量","depth":3},{"value":"使用 tshark 捕获 DNS 流量","url":"#使用-tshark-捕获-dns-流量","depth":3},{"value":"使用 tcpdump 捕获 DNS 流量","url":"#使用-tcpdump-捕获-dns-流量","depth":3},{"value":"ICMP协议","url":"#icmp协议","depth":2},{"value":"压力测试工具","url":"#压力测试工具","depth":3},{"value":"使用","url":"#使用","depth":3},{"value":"使用 ping 进行压力测试","url":"#使用-ping-进行压力测试","depth":4},{"value":"使用 fping 进行压力测试","url":"#使用-fping-进行压力测试","depth":4},{"value":"使用 hping 进行压力测试","url":"#使用-hping-进行压力测试","depth":4},{"value":"使用 nping 进行压力测试","url":"#使用-nping-进行压力测试","depth":4}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"网络协议流量捕获和压力测试工具比较","datePublished":"2024-08-12T00:00:00.000Z","dateModified":"2024-08-12T00:00:00.000Z","description":"本文详细介绍了多种网络流量捕获和分析工具，包括scapy、tshark和tcpdump，比较了它们在捕获HTTP、DNS和ICMP协议流量时的性能和资源消耗。文章提供了每种工具的安装方法、使用脚本和命令行示例，以及如何测量CPU使用率和内存占用。此外，还介绍了ICMP协议的压力测试方法，包括使用ping、fping、hping和nping等工具。这些信息对网络管理员和开发人员进行网络分析、调试和性能评估非常有用。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/tools/capture-traffic-tools","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"网络流量分析与入侵检测：特征降维、深度学习与数据集评估","date":"2024-08-01T00:00:00.000Z","tags":["paper reading","machine learing","network security"],"draft":false,"summary":"本文综合探讨了网络流量分析和入侵检测的多个方面。首先介绍了使用朴素贝叶斯分类器和特征降维技术进行入侵检测的方法，包括CFS、IG、GR和FVBRM等特征选择算法。其次讨论了利用卷积神经网络进行恶意软件流量分类的创新方法，强调了表示学习的优势。最后对多个网络流量数据集进行了全面评估，从实时性、指纹提取效果和研究应用等方面进行了排序和分析，为相关研究提供了valuable insights。","layout":"PostSimple","type":"Blog","readingTime":{"text":"19 min read","minutes":18.5,"time":1110000,"words":3700},"slug":"paper/feature-extraction","path":"blog/paper/feature-extraction","filePath":"blog/paper/feature-extraction.mdx","toc":[{"value":"使用朴素贝叶斯分类器进行特征降维的入侵检测","url":"#使用朴素贝叶斯分类器进行特征降维的入侵检测","depth":2},{"value":"概述","url":"#概述-1","depth":3},{"value":"数据集：NSL-KDD","url":"#数据集nsl-kdd","depth":3},{"value":"特征选择","url":"#特征选择","depth":3},{"value":"实验设置","url":"#实验设置","depth":3},{"value":"实验结果","url":"#实验结果","depth":3},{"value":"结论","url":"#结论-9","depth":3},{"value":"使用卷积神经网络进行恶意软件流量分类的表示学习方法","url":"#使用卷积神经网络进行恶意软件流量分类的表示学习方法","depth":2},{"value":"概述","url":"#概述-2","depth":3},{"value":"数据集","url":"#数据集","depth":3},{"value":"特征与数据预处理","url":"#特征与数据预处理","depth":3},{"value":"流量表示方式","url":"#流量表示方式","depth":3},{"value":"实验设置与结果","url":"#实验设置与结果","depth":3},{"value":"实验场景","url":"#实验场景","depth":4},{"value":"分类器","url":"#分类器","depth":4},{"value":"CNN架构","url":"#cnn架构","depth":4},{"value":"训练参数","url":"#训练参数","depth":4},{"value":"实验结果","url":"#实验结果-1","depth":4},{"value":"结论","url":"#结论-10","depth":3},{"value":"数据集","url":"#数据集-1","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"网络流量分析与入侵检测：特征降维、深度学习与数据集评估","datePublished":"2024-08-01T00:00:00.000Z","dateModified":"2024-08-01T00:00:00.000Z","description":"本文综合探讨了网络流量分析和入侵检测的多个方面。首先介绍了使用朴素贝叶斯分类器和特征降维技术进行入侵检测的方法，包括CFS、IG、GR和FVBRM等特征选择算法。其次讨论了利用卷积神经网络进行恶意软件流量分类的创新方法，强调了表示学习的优势。最后对多个网络流量数据集进行了全面评估，从实时性、指纹提取效果和研究应用等方面进行了排序和分析，为相关研究提供了valuable insights。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/paper/feature-extraction","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"流量指纹识别技术调研报告","date":"2024-07-18T00:00:00.000Z","tags":["paper reading","machine learing","network security"],"draft":false,"summary":"本文是对流量指纹识别技术的调研报告，主要介绍了流量指纹识别技术的基本概念、发展历程、技术原理、研究现状和未来发展方向。","layout":"PostSimple","type":"Blog","readingTime":{"text":"48 min read","minutes":47.125,"time":2827500,"words":9425},"slug":"paper/Fingerprint-identification-survey","path":"blog/paper/Fingerprint-identification-survey","filePath":"blog/paper/Fingerprint-identification-survey.mdx","toc":[{"value":"目录","url":"#目录-12","depth":2},{"value":"1. 引言","url":"#1-引言-1","depth":2},{"value":"2. 网络流量指纹概述","url":"#2-网络流量指纹概述","depth":2},{"value":"2.1 定义","url":"#21-定义","depth":3},{"value":"2.2 应用场景","url":"#22-应用场景","depth":3},{"value":"2.3 指纹提取的基本流程","url":"#23-指纹提取的基本流程","depth":3},{"value":"3. 数据捕获","url":"#3-数据捕获","depth":2},{"value":"3.1 工具简介","url":"#31-工具简介","depth":3},{"value":"3.1.1 基于人工智能的网络嗅探工具","url":"#311-基于人工智能的网络嗅探工具","depth":4},{"value":"3.1.2 分布式网络嗅探系统","url":"#312-分布式网络嗅探系统","depth":4},{"value":"3.1.3 云端网络嗅探服务","url":"#313-云端网络嗅探服务","depth":4},{"value":"3.1.4 本地网络嗅探工具","url":"#314-本地网络嗅探工具","depth":4},{"value":"3.2 实例操作","url":"#32-实例操作","depth":3},{"value":"3.2.1 使用Python和Scapy库捕获流量","url":"#321-使用python和scapy库捕获流量","depth":4},{"value":"3.2.2 使用Tshark命令行工具捕获流量","url":"#322-使用tshark命令行工具捕获流量","depth":4},{"value":"3.2.3 使用dpkt进行实时流量分析","url":"#323-使用dpkt进行实时流量分析","depth":4},{"value":"3.2.4 使用wireshark提供的 api进行实时流量分析","url":"#324-使用wireshark提供的-api进行实时流量分析","depth":4},{"value":"3.3 网络流量实时快速实时抓取实现","url":"#33-网络流量实时快速实时抓取实现","depth":3},{"value":"4. 指纹提取技术","url":"#4-指纹提取技术","depth":2},{"value":"4.1 基于端口的识别","url":"#41-基于端口的识别","depth":3},{"value":"4.1.1 原理","url":"#411-原理","depth":4},{"value":"4.1.2 优缺点","url":"#412-优缺点","depth":4},{"value":"4.1.3 实现方法","url":"#413-实现方法","depth":4},{"value":"4.2 深度包检测(DPI)","url":"#42-深度包检测dpi","depth":3},{"value":"4.2.1 原理","url":"#421-原理","depth":4},{"value":"4.2.2 优缺点","url":"#422-优缺点","depth":4},{"value":"4.2.3 实现方法和工具","url":"#423-实现方法和工具","depth":4},{"value":"4.3 基于机器学习的方法","url":"#43-基于机器学习的方法","depth":3},{"value":"4.3.1 主要方法","url":"#431-主要方法","depth":4},{"value":"4.3.2 实现示例","url":"#432-实现示例","depth":4},{"value":"4.4 启发式方法","url":"#44-启发式方法","depth":3},{"value":"4.4.1 主要技术","url":"#441-主要技术","depth":4},{"value":"4.4.2 实现示例","url":"#442-实现示例","depth":4},{"value":"4.5 论文算法对应的特征值","url":"#45-论文算法对应的特征值","depth":3},{"value":"5 开源数据集下载","url":"#5-开源数据集下载","depth":2},{"value":"相关论文","url":"#相关论文","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"流量指纹识别技术调研报告","datePublished":"2024-07-18T00:00:00.000Z","dateModified":"2024-07-18T00:00:00.000Z","description":"本文是对流量指纹识别技术的调研报告，主要介绍了流量指纹识别技术的基本概念、发展历程、技术原理、研究现状和未来发展方向。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/paper/Fingerprint-identification-survey","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"深入剖析数据库索引","date":"2024-07-09T00:00:00.000Z","tags":["database"],"draft":false,"summary":"数据库索引的使用需谨慎，它们能显著提升读操作效率，但也增加了内存消耗和写操作成本。选择合适数量和类型的索引至关重要，基数（即列中不同值的数量）对索引效果至关重要。定期维护索引是必要的，以避免内存浪费。深入理解数据库索引的各个方面，将有助于优化应用程序性能和设计决策。","layout":"PostSimple","type":"Blog","readingTime":{"text":"53 min read","minutes":52.33,"time":3139800,"words":10466},"slug":"database","path":"blog/database","filePath":"blog/database/index.mdx","toc":[{"value":"目录","url":"#目录-7","depth":2},{"value":"如何验证我们正在使用InnoDB引擎","url":"#如何验证我们正在使用innodb引擎","depth":4},{"value":"主键","url":"#主键","depth":2},{"value":"如果你没有自己创建任何主键会发生什么？","url":"#如果你没有自己创建任何主键会发生什么","depth":3},{"value":"关键字和索引之间的区别是什么？","url":"#关键字和索引之间的区别是什么","depth":3},{"value":"聚簇索引","url":"#聚簇索引","depth":2},{"value":"物理数据组织","url":"#物理数据组织","depth":3},{"value":"物理数据块的管理","url":"#物理数据块的管理","depth":3},{"value":"聚簇索引的优势","url":"#聚簇索引的优势","depth":3},{"value":"聚簇索引的限制","url":"#聚簇索引的限制","depth":3},{"value":"主键与聚簇索引的关系","url":"#主键与聚簇索引的关系","depth":3},{"value":"结构化主键（聚簇）索引","url":"#结构化主键聚簇索引","depth":3},{"value":"能否在非主键列上创建主索引？","url":"#能否在非主键列上创建主索引","depth":3},{"value":"是否可以删除一个主键？","url":"#是否可以删除一个主键","depth":3},{"value":"主索引的优势","url":"#主索引的优势","depth":3},{"value":"主索引的缺点","url":"#主索引的缺点","depth":3},{"value":"次要索引","url":"#次要索引","depth":2},{"value":"何时需要次要索引？","url":"#何时需要次要索引","depth":3},{"value":"如何在MySQL中创建次要索引？","url":"#如何在mysql中创建次要索引","depth":3},{"value":"次要索引的结构","url":"#次要索引的结构","depth":3},{"value":"次要索引的优势","url":"#次要索引的优势","depth":3},{"value":"次要索引的缺点","url":"#次要索引的缺点","depth":3},{"value":"删除主键索引前的考虑事项","url":"#删除主键索引前的考虑事项","depth":3},{"value":"UNIQUE Key Index（唯一键索引）","url":"#unique-key-index唯一键索引","depth":2},{"value":"注意事项","url":"#注意事项-3","depth":3},{"value":"Composite Index（复合索引）","url":"#composite-index复合索引","depth":2},{"value":"为什么使用复合索引？为什么不定义多个次要索引？","url":"#为什么使用复合索引为什么不定义多个次要索引","depth":3},{"value":"复合索引的优势","url":"#复合索引的优势","depth":3},{"value":"复合索引的工作原理","url":"#复合索引的工作原理","depth":3},{"value":"如何确定是否需要使用复合索引","url":"#如何确定是否需要使用复合索引","depth":3},{"value":"分析查询模式","url":"#分析查询模式","depth":4},{"value":"示例考虑","url":"#示例考虑","depth":4},{"value":"覆盖索引","url":"#覆盖索引","depth":2},{"value":"部分索引","url":"#部分索引","depth":2},{"value":"索引背后的运作原理","url":"#索引背后的运作原理","depth":3},{"value":"索引的一般指导原则","url":"#索引的一般指导原则","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"深入剖析数据库索引","datePublished":"2024-07-09T00:00:00.000Z","dateModified":"2024-07-09T00:00:00.000Z","description":"数据库索引的使用需谨慎，它们能显著提升读操作效率，但也增加了内存消耗和写操作成本。选择合适数量和类型的索引至关重要，基数（即列中不同值的数量）对索引效果至关重要。定期维护索引是必要的，以避免内存浪费。深入理解数据库索引的各个方面，将有助于优化应用程序性能和设计决策。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/database","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"深入探讨：如何优化你的网站后端","date":"2024-07-07T00:00:00.000Z","tags":["backend"],"draft":false,"summary":"本文深入探讨了Web后端优化的多个层面，包括应用层、数据库层和基础设施层。我们讨论了各种优化技术，如算法优化、异步编程、数据库索引、查询优化、网络架构评估和API技术选择等。文章强调了性能测试和持续监控的重要性，并指出优化策略应根据具体应用需求来制定。","layout":"PostSimple","type":"Blog","readingTime":{"text":"28 min read","minutes":27.205,"time":1632300,"words":5441},"slug":"backend/optimize","path":"blog/backend/optimize","filePath":"blog/backend/optimize.mdx","toc":[{"value":"目录","url":"#目录-4","depth":2},{"value":"在不同层面进行优化","url":"#在不同层面进行优化","depth":2},{"value":"应用层优化","url":"#应用层优化","depth":2},{"value":"数据库层优化","url":"#数据库层优化","depth":2},{"value":"1. 索引能力","url":"#1-索引能力","depth":3},{"value":"2. 选择性查询","url":"#2-选择性查询","depth":3},{"value":"3. 数据库扩展","url":"#3-数据库扩展","depth":3},{"value":"4. 数据分区","url":"#4-数据分区","depth":3},{"value":"5. 重新设计数据库解决方案","url":"#5-重新设计数据库解决方案","depth":3},{"value":"基础设施层优化","url":"#基础设施层优化","depth":2},{"value":"1. 内容分发网络（CDN）","url":"#1-内容分发网络cdn","depth":3},{"value":"2. 评估网络架构","url":"#2-评估网络架构","depth":3},{"value":"3. 升级HTTP版本","url":"#3-升级http版本","depth":3},{"value":"4. TCP协议优化","url":"#4-tcp协议优化","depth":3},{"value":"5. 数据压缩","url":"#5-数据压缩","depth":3},{"value":"6. API技术选择","url":"#6-api技术选择","depth":3},{"value":"7. 应用程序复制","url":"#7-应用程序复制","depth":3},{"value":"结论","url":"#结论-2","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"深入探讨：如何优化你的网站后端","datePublished":"2024-07-07T00:00:00.000Z","dateModified":"2024-07-07T00:00:00.000Z","description":"本文深入探讨了Web后端优化的多个层面，包括应用层、数据库层和基础设施层。我们讨论了各种优化技术，如算法优化、异步编程、数据库索引、查询优化、网络架构评估和API技术选择等。文章强调了性能测试和持续监控的重要性，并指出优化策略应根据具体应用需求来制定。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/backend/optimize","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"JavaScript秘技：15个惊艳功能","date":"2024-07-06T00:00:00.000Z","tags":["frontend","javascript"],"draft":false,"summary":"本博客介绍了 15 个 javascript 的小技巧，希望对你们有帮助🙂。","layout":"PostSimple","type":"Blog","readingTime":{"text":"43 min read","minutes":42.99,"time":2579400,"words":8598},"slug":"frontend/javascript-trick","path":"blog/frontend/javascript-trick","filePath":"blog/frontend/javascript-trick.mdx","toc":[{"value":"目录","url":"#目录-8","depth":2},{"value":"1. 获取操作系统信息","url":"#1-获取操作系统信息","depth":2},{"value":"2. 使用void(0)防止页面刷新","url":"#2-使用void0防止页面刷新","depth":2},{"value":"3. 重定向到新页面","url":"#3-重定向到新页面","depth":2},{"value":"4. 电子邮件地址验证","url":"#4-电子邮件地址验证","depth":2},{"value":"完整的电子邮件验证","url":"#完整的电子邮件验证","depth":3},{"value":"简化版（支持Unicode）","url":"#简化版支持unicode","depth":3},{"value":"使用建议","url":"#使用建议","depth":3},{"value":"5. 获取当前URL","url":"#5-获取当前url","depth":2},{"value":"使用 window.location.href","url":"#使用-windowlocationhref","depth":3},{"value":"使用 document.URL","url":"#使用-documenturl","depth":3},{"value":"使用建议","url":"#使用建议-1","depth":3},{"value":"6. 使用正则表达式检测移动浏览器","url":"#6-使用正则表达式检测移动浏览器","depth":2},{"value":"7. 不使用正则表达式检测移动浏览器","url":"#7-不使用正则表达式检测移动浏览器","depth":2},{"value":"8. 检测页面上的JavaScript是否被禁用","url":"#8-检测页面上的javascript是否被禁用","depth":2},{"value":"9. 获取模块的元数据","url":"#9-获取模块的元数据","depth":2},{"value":"10. 获取日期的时区偏移","url":"#10-获取日期的时区偏移","depth":2},{"value":"11. 将鼠标光标设置为等待状态","url":"#11-将鼠标光标设置为等待状态","depth":2},{"value":"12. 获取复选框的状态","url":"#12-获取复选框的状态","depth":2},{"value":"13. 为控制台消息添加 CSS 样式","url":"#13-为控制台消息添加-css-样式","depth":2},{"value":"14. 禁用网页右键点击","url":"#14-禁用网页右键点击","depth":2},{"value":"15. 捕获浏览器的后退按钮事件","url":"#15-捕获浏览器的后退按钮事件","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"JavaScript秘技：15个惊艳功能","datePublished":"2024-07-06T00:00:00.000Z","dateModified":"2024-07-06T00:00:00.000Z","description":"本博客介绍了 15 个 javascript 的小技巧，希望对你们有帮助🙂。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/frontend/javascript-trick","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"从零开始：如何设计一个现代化聊天系统","date":"2024-07-02T00:00:00.000Z","tags":["system"],"draft":false,"summary":"博客介绍了一种可扩展且可靠的聊天系统架构，该架构支持一对一和小群聊，并有可能扩展到处理媒体文件。该系统采用客户端-服务器架构，由聊天服务器、Presence 服务器、推送通知服务器、键值存储和 API 服务器组成。它利用了 WebSocket、服务发现、消息传递、在线状态管理和推送通知等技术。该架构具有可扩展性、高可用性和易用性等优点，使其适用于各种规模的聊天应用程序。","layout":"PostSimple","type":"Blog","readingTime":{"text":"61 min read","minutes":60.155,"time":3609300,"words":12031},"slug":"system/chat-system","path":"blog/system/chat-system","filePath":"blog/system/chat-system.mdx","toc":[{"value":"第一步 - 理解问题并确立设计范围","url":"#第一步---理解问题并确立设计范围","depth":2},{"value":"第二步 - 提出高层设计并获得认可","url":"#第二步---提出高层设计并获得认可","depth":2},{"value":"轮询（Polling）","url":"#轮询polling","depth":3},{"value":"长轮询（Long Polling）","url":"#长轮询long-polling","depth":3},{"value":"WebSocket","url":"#websocket","depth":3},{"value":"高层设计","url":"#高层设计","depth":3},{"value":"无状态服务","url":"#无状态服务","depth":4},{"value":"有状态服务","url":"#有状态服务","depth":4},{"value":"第三方集成","url":"#第三方集成","depth":4},{"value":"可扩展性","url":"#可扩展性","depth":4},{"value":"存储","url":"#存储","depth":4},{"value":"数据模型","url":"#数据模型","depth":3},{"value":"1 对 1 聊天消息表","url":"#1-对-1-聊天消息表","depth":4},{"value":"群聊消息表","url":"#群聊消息表","depth":4},{"value":"消息 ID 生成","url":"#消息-id-生成","depth":4},{"value":"第三步 - 系统设计深度剖析","url":"#第三步---系统设计深度剖析","depth":2},{"value":"服务发现 (Service Discovery)","url":"#服务发现-service-discovery","depth":3},{"value":"消息流 (Messaging Flows)","url":"#消息流-messaging-flows","depth":3},{"value":"1 对 1 聊天","url":"#1-对-1-聊天","depth":4},{"value":"消息同步多个设备","url":"#消息同步多个设备","depth":4},{"value":"小型群聊消息流","url":"#小型群聊消息流","depth":4},{"value":"在线/离线状态管理","url":"#在线离线状态管理","depth":3},{"value":"用户登录","url":"#用户登录","depth":4},{"value":"用户登出","url":"#用户登出","depth":4},{"value":"用户断线","url":"#用户断线","depth":4},{"value":"在线状态推送","url":"#在线状态推送","depth":4},{"value":"第四步 - 系统设计总结","url":"#第四步---系统设计总结","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"从零开始：如何设计一个现代化聊天系统","datePublished":"2024-07-02T00:00:00.000Z","dateModified":"2024-07-02T00:00:00.000Z","description":"博客介绍了一种可扩展且可靠的聊天系统架构，该架构支持一对一和小群聊，并有可能扩展到处理媒体文件。该系统采用客户端-服务器架构，由聊天服务器、Presence 服务器、推送通知服务器、键值存储和 API 服务器组成。它利用了 WebSocket、服务发现、消息传递、在线状态管理和推送通知等技术。该架构具有可扩展性、高可用性和易用性等优点，使其适用于各种规模的聊天应用程序。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/system/chat-system","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"从零到百万用户的扩展之路","date":"2024-07-02T00:00:00.000Z","tags":["system"],"draft":false,"summary":"实现系统的可扩展性至数百万用户，关键在于保持Web层无状态、构建全方位冗余、有效缓存和分片数据层、支持多数据中心、利用CDN托管静态资产、采用微服务架构、监控系统并自动化操作。这些策略不仅提高性能和可靠性，还支持持续优化和应对新挑战，确保系统在不断增长的用户需求下保持高效运行。","layout":"PostSimple","bibliography":"references-data.bib","type":"Blog","readingTime":{"text":"58 min read","minutes":57.37,"time":3442200,"words":11474},"slug":"system/design-system","path":"blog/system/design-system","filePath":"blog/system/design-system.mdx","toc":[{"value":"单服务器设置","url":"#单服务器设置","depth":2},{"value":"数据库","url":"#数据库","depth":2},{"value":"数据库的选择","url":"#数据库的选择","depth":3},{"value":"垂直扩展 VS 水平扩展","url":"#垂直扩展-vs-水平扩展","depth":2},{"value":"负载均衡器","url":"#负载均衡器","depth":2},{"value":"数据库复制","url":"#数据库复制","depth":2},{"value":"缓存","url":"#缓存-1","depth":2},{"value":"缓存层","url":"#缓存层","depth":3},{"value":"使用缓存的建议","url":"#使用缓存的建议","depth":3},{"value":"内容交付网络（CDN）","url":"#内容交付网络cdn","depth":2},{"value":"使用CDN的建议","url":"#使用cdn的建议","depth":3},{"value":"无状态web服务器","url":"#无状态web服务器","depth":2},{"value":"有状态的结构","url":"#有状态的结构","depth":3},{"value":"无状态的结构","url":"#无状态的结构","depth":3},{"value":"数据中心","url":"#数据中心","depth":2},{"value":"消息队列","url":"#消息队列","depth":2},{"value":"日志记录、度量和自动化","url":"#日志记录度量和自动化","depth":2},{"value":"日志记录","url":"#日志记录","depth":3},{"value":"度量","url":"#度量","depth":3},{"value":"自动化","url":"#自动化","depth":3},{"value":"数据库扩展","url":"#数据库扩展","depth":2},{"value":"纵向扩展","url":"#纵向扩展","depth":3},{"value":"横向扩展","url":"#横向扩展","depth":3},{"value":"总结","url":"#总结-16","depth":2},{"value":"参考文献","url":"#参考文献-4","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"从零到百万用户的扩展之路","datePublished":"2024-07-02T00:00:00.000Z","dateModified":"2024-07-02T00:00:00.000Z","description":"实现系统的可扩展性至数百万用户，关键在于保持Web层无状态、构建全方位冗余、有效缓存和分片数据层、支持多数据中心、利用CDN托管静态资产、采用微服务架构、监控系统并自动化操作。这些策略不仅提高性能和可靠性，还支持持续优化和应对新挑战，确保系统在不断增长的用户需求下保持高效运行。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/system/design-system","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"数据库锁之间有哪些区别？","date":"2024-07-01T00:00:00.000Z","tags":["database"],"draft":false,"summary":"数据库锁（Database Locks）是确保数据一致性和完整性的重要机制，防止多个事务同时访问同一数据资源导致数据冲突。不同类型的锁有不同的特性和用途。","layout":"PostSimple","type":"Blog","readingTime":{"text":"8 min read","minutes":7.16,"time":429600,"words":1432},"slug":"database/lock","path":"blog/database/lock","filePath":"blog/database/lock.mdx","toc":[{"value":"1. 共享锁（Shared Lock，S Lock）","url":"#1-共享锁shared-locks-lock","depth":3},{"value":"2. 排他锁（Exclusive Lock，X Lock）","url":"#2-排他锁exclusive-lockx-lock","depth":3},{"value":"3. 更新锁（Update Lock，U Lock）","url":"#3-更新锁update-locku-lock","depth":3},{"value":"4. 模式锁（Schema Lock）","url":"#4-模式锁schema-lock","depth":3},{"value":"5. 批量更新锁（Bulk Update Lock，BU Lock）","url":"#5-批量更新锁bulk-update-lockbu-lock","depth":3},{"value":"6. 键范围锁（Key-Range Lock）","url":"#6-键范围锁key-range-lock","depth":3},{"value":"7. 行级锁（Row-Level Lock）","url":"#7-行级锁row-level-lock","depth":3},{"value":"8. 页级锁（Page-Level Lock）","url":"#8-页级锁page-level-lock","depth":3},{"value":"9. 表级锁（Table-Level Lock）","url":"#9-表级锁table-level-lock","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"数据库锁之间有哪些区别？","datePublished":"2024-07-01T00:00:00.000Z","dateModified":"2024-07-01T00:00:00.000Z","description":"数据库锁（Database Locks）是确保数据一致性和完整性的重要机制，防止多个事务同时访问同一数据资源导致数据冲突。不同类型的锁有不同的特性和用途。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/database/lock","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"ATT&CK学习笔记","date":"2024-06-24T00:00:00.000Z","tags":["paper reading","network security"],"draft":false,"summary":"ATT&CK的学习笔记","layout":"PostSimple","type":"Blog","readingTime":{"text":"973 min read","minutes":972.635,"time":58358100,"words":194527},"slug":"paper/ATTCK","path":"blog/paper/ATTCK","filePath":"blog/paper/ATTCK.mdx","toc":[{"value":"目录","url":"#目录-10","depth":2},{"value":"前言知识","url":"#前言知识","depth":2},{"value":"定义","url":"#定义-1","depth":2},{"value":"战术详解","url":"#战术详解","depth":2},{"value":"一、 侦察","url":"#一-侦察","depth":3},{"value":"1. 主动扫描","url":"#1-主动扫描","depth":4},{"value":"IP扫描","url":"#ip扫描","depth":5},{"value":"漏洞扫描","url":"#漏洞扫描","depth":5},{"value":"字表扫描","url":"#字表扫描","depth":5},{"value":"2.收集受害者宿主信息","url":"#2收集受害者宿主信息","depth":4},{"value":"硬件","url":"#硬件","depth":5},{"value":"软件","url":"#软件","depth":5},{"value":"固件","url":"#固件","depth":5},{"value":"客户端配置","url":"#客户端配置","depth":5},{"value":"3.收集受害者身份信息","url":"#3收集受害者身份信息","depth":4},{"value":"资格证书","url":"#资格证书","depth":5},{"value":"电子邮件地址","url":"#电子邮件地址","depth":5},{"value":"员工姓名","url":"#员工姓名","depth":5},{"value":"4.收集受害者网络信息","url":"#4收集受害者网络信息","depth":4},{"value":"域属性","url":"#域属性","depth":5},{"value":"域名服务器","url":"#域名服务器","depth":5},{"value":"网络信任依赖项","url":"#网络信任依赖项","depth":5},{"value":"网络拓扑","url":"#网络拓扑","depth":5},{"value":"IP地址","url":"#ip地址","depth":5},{"value":"网络安全设备","url":"#网络安全设备","depth":5},{"value":"5.收集受害者组织信息","url":"#5收集受害者组织信息","depth":4},{"value":"确定物理位置","url":"#确定物理位置","depth":5},{"value":"业务关系","url":"#业务关系","depth":5},{"value":"识别业务时间","url":"#识别业务时间","depth":5},{"value":"确定角色","url":"#确定角色","depth":5},{"value":"6.信息网络钓鱼","url":"#6信息网络钓鱼","depth":4},{"value":"网络钓鱼服务","url":"#网络钓鱼服务","depth":5},{"value":"网络钓鱼附件","url":"#网络钓鱼附件","depth":5},{"value":"网络钓鱼链接","url":"#网络钓鱼链接","depth":5},{"value":"网络钓鱼语音","url":"#网络钓鱼语音","depth":5},{"value":"7.搜索关闭的源","url":"#7搜索关闭的源","depth":4},{"value":"威胁英特尔供应商","url":"#威胁英特尔供应商","depth":5},{"value":"采购技术数据","url":"#采购技术数据","depth":5},{"value":"8.搜索开放的技术数据库","url":"#8搜索开放的技术数据库","depth":4},{"value":"DNS/被动DNS","url":"#dns被动dns","depth":5},{"value":"WHOIS","url":"#whois","depth":5},{"value":"数字证书","url":"#数字证书","depth":5},{"value":"CDN","url":"#cdn","depth":5},{"value":"扫描数据库","url":"#扫描数据库","depth":5},{"value":"9.搜索打开的网站/域","url":"#9搜索打开的网站域","depth":4},{"value":"社会化媒体","url":"#社会化媒体","depth":5},{"value":"搜索引擎","url":"#搜索引擎","depth":5},{"value":"代码存储库","url":"#代码存储库","depth":5},{"value":"10.搜索受害者拥有的网站","url":"#10搜索受害者拥有的网站","depth":4},{"value":"二、资源开发","url":"#二资源开发","depth":3},{"value":"1.获取访问权限","url":"#1获取访问权限","depth":4},{"value":"2.收购基础设施","url":"#2收购基础设施","depth":4},{"value":"域","url":"#域","depth":5},{"value":"DNS服务器","url":"#dns服务器","depth":5},{"value":"虚拟专用服务器","url":"#虚拟专用服务器","depth":5},{"value":"服务器","url":"#服务器","depth":5},{"value":"Botnet","url":"#botnet","depth":5},{"value":"Web服务","url":"#web服务","depth":5},{"value":"无服务器","url":"#无服务器","depth":5},{"value":"恶意广告","url":"#恶意广告","depth":5},{"value":"3.入侵账户","url":"#3入侵账户","depth":4},{"value":"社交媒体账户","url":"#社交媒体账户","depth":5},{"value":"电子邮件账户","url":"#电子邮件账户","depth":5},{"value":"云账户","url":"#云账户","depth":5},{"value":"4.入侵基础设施","url":"#4入侵基础设施","depth":4},{"value":"域名","url":"#域名","depth":5},{"value":"DNS服务器","url":"#dns服务器-1","depth":5},{"value":"虚拟专用服务器（VPS）","url":"#虚拟专用服务器vps","depth":5},{"value":"服务器","url":"#服务器-1","depth":5},{"value":"僵尸网络","url":"#僵尸网络","depth":5},{"value":"网络服务","url":"#网络服务","depth":5},{"value":"5. 发展能力","url":"#5-发展能力","depth":4},{"value":"恶意软件","url":"#恶意软件","depth":5},{"value":"代码签名证书","url":"#代码签名证书","depth":5},{"value":"数字证书","url":"#数字证书-1","depth":5},{"value":"漏洞利用","url":"#漏洞利用","depth":5},{"value":"6.建立账户","url":"#6建立账户","depth":4},{"value":"社交媒体账户","url":"#社交媒体账户-1","depth":5},{"value":"电子邮件账户","url":"#电子邮件账户-1","depth":5},{"value":"云账户","url":"#云账户-1","depth":5},{"value":"7. 获取能力","url":"#7-获取能力","depth":4},{"value":"恶意软件","url":"#恶意软件-1","depth":5},{"value":"工具","url":"#工具","depth":5},{"value":"代码签名证书","url":"#代码签名证书-1","depth":5},{"value":"数字证书","url":"#数字证书-2","depth":5},{"value":"漏洞利用","url":"#漏洞利用-1","depth":5},{"value":"漏洞","url":"#漏洞","depth":5},{"value":"人工智能","url":"#人工智能","depth":5},{"value":"8.阶段功能","url":"#8阶段功能","depth":4},{"value":"上传恶意软件","url":"#上传恶意软件","depth":5},{"value":"上传工具","url":"#上传工具","depth":5},{"value":"安装数字证书","url":"#安装数字证书","depth":5},{"value":"无意中的目标","url":"#无意中的目标","depth":5},{"value":"链接目标","url":"#链接目标","depth":5},{"value":"SEO毒化","url":"#seo毒化","depth":5},{"value":"三、初始访问","url":"#三初始访问","depth":3},{"value":"1.内容注入","url":"#1内容注入","depth":4},{"value":"2.驾车路过妥协","url":"#2驾车路过妥协","depth":4},{"value":"3.开发面向公众的应用程序","url":"#3开发面向公众的应用程序","depth":4},{"value":"4.外部远程服务","url":"#4外部远程服务","depth":4},{"value":"5.硬件添加","url":"#5硬件添加","depth":4},{"value":"6.网络钓鱼","url":"#6网络钓鱼","depth":4},{"value":"网络钓鱼附件","url":"#网络钓鱼附件-1","depth":5},{"value":"网络钓鱼链接","url":"#网络钓鱼链接-1","depth":5},{"value":"通过服务进行网络钓鱼","url":"#通过服务进行网络钓鱼","depth":5},{"value":"网络钓鱼语音","url":"#网络钓鱼语音-1","depth":5},{"value":"7.通过可移动介质进行复制","url":"#7通过可移动介质进行复制","depth":4},{"value":"8.供应链妥协","url":"#8供应链妥协","depth":4},{"value":"折衷软件依赖关系和开发工具","url":"#折衷软件依赖关系和开发工具","depth":5},{"value":"损害软件供应链","url":"#损害软件供应链","depth":5},{"value":"损害硬件供应链","url":"#损害硬件供应链","depth":5},{"value":"9.受信任的关系","url":"#9受信任的关系","depth":4},{"value":"10.有效帐户","url":"#10有效帐户","depth":4},{"value":"默认帐户","url":"#默认帐户","depth":5},{"value":"域帐户","url":"#域帐户","depth":5},{"value":"本地帐户","url":"#本地帐户","depth":5},{"value":"云帐户","url":"#云帐户","depth":5},{"value":"四、执行","url":"#四执行","depth":3},{"value":"1.云管理命令","url":"#1云管理命令","depth":4},{"value":"2.命令和脚本解释器","url":"#2命令和脚本解释器","depth":4},{"value":"PowerShell","url":"#powershell","depth":5},{"value":"AppleScript","url":"#applescript","depth":5},{"value":"Windows命令行shell","url":"#windows命令行shell","depth":5},{"value":"Unixshell","url":"#unixshell","depth":5},{"value":"Visual Basic","url":"#visual-basic","depth":5},{"value":"Python","url":"#python","depth":5},{"value":"JavaScript","url":"#javascript","depth":5},{"value":"网络设备CLI","url":"#网络设备cli","depth":5},{"value":"云API","url":"#云api","depth":5},{"value":"AutoHotKey和AutoIT","url":"#autohotkey和autoit","depth":5},{"value":"3.容器管理命令","url":"#3容器管理命令","depth":4},{"value":"4.部署容器","url":"#4部署容器","depth":4},{"value":"5.利用客户端执行","url":"#5利用客户端执行","depth":4},{"value":"6.进程间通信","url":"#6进程间通信","depth":4},{"value":"组件对象模型","url":"#组件对象模型","depth":5},{"value":"动态数据交换","url":"#动态数据交换","depth":5},{"value":"XPC服务","url":"#xpc服务","depth":5},{"value":"7.本机API","url":"#7本机api","depth":4},{"value":"8.计划任务/作业","url":"#8计划任务作业","depth":4},{"value":"At","url":"#at","depth":5},{"value":"Cron","url":"#cron","depth":5},{"value":"Launchd","url":"#launchd","depth":5},{"value":"计划的任务","url":"#计划的任务","depth":5},{"value":"系统计时器","url":"#系统计时器","depth":5},{"value":"容器编排作业","url":"#容器编排作业","depth":5},{"value":"9.无服务器执行","url":"#9无服务器执行","depth":4},{"value":"10.共享模块","url":"#10共享模块","depth":4},{"value":"11.软件部署工具","url":"#11软件部署工具","depth":4},{"value":"12.系统服务","url":"#12系统服务","depth":4},{"value":"Launchctl","url":"#launchctl","depth":5},{"value":"服务执行","url":"#服务执行","depth":5},{"value":"13.用户执行","url":"#13用户执行","depth":4},{"value":"恶意链接","url":"#恶意链接","depth":5},{"value":"恶意文件","url":"#恶意文件","depth":5},{"value":"恶意图片","url":"#恶意图片","depth":5},{"value":"14.Windows Management Instrumentation","url":"#14windows-management-instrumentation","depth":4},{"value":"五、持久化","url":"#五持久化","depth":3},{"value":"1.账户操纵","url":"#1账户操纵","depth":4},{"value":"其他云凭据","url":"#其他云凭据","depth":5},{"value":"其他电子邮件委派权限","url":"#其他电子邮件委派权限","depth":5},{"value":"其他云角色","url":"#其他云角色","depth":5},{"value":"SSH授权密钥","url":"#ssh授权密钥","depth":5},{"value":"设备注册","url":"#设备注册","depth":5},{"value":"其他容器群集角色","url":"#其他容器群集角色","depth":5},{"value":"2.BITS作业","url":"#2bits作业","depth":4},{"value":"3.启动或登录自动启动执行","url":"#3启动或登录自动启动执行","depth":4},{"value":"注册表运行密钥/启动文件夹","url":"#注册表运行密钥启动文件夹","depth":5},{"value":"身份验证包","url":"#身份验证包","depth":5},{"value":"时间提供程序","url":"#时间提供程序","depth":5},{"value":"Winlogon帮助程序DLL","url":"#winlogon帮助程序dll","depth":5},{"value":"安全支持提供商","url":"#安全支持提供商","depth":5},{"value":"内核模块和扩展","url":"#内核模块和扩展","depth":5},{"value":"重新打开的应用程序","url":"#重新打开的应用程序","depth":5},{"value":"LSASS驱动程序","url":"#lsass驱动程序","depth":5},{"value":"快捷方式修改","url":"#快捷方式修改","depth":5},{"value":"端口监视器","url":"#端口监视器","depth":5},{"value":"打印处理器","url":"#打印处理器","depth":5},{"value":"XDG自动启动条目","url":"#xdg自动启动条目","depth":5},{"value":"活动设置","url":"#活动设置","depth":5},{"value":"登录项","url":"#登录项","depth":5},{"value":"4.启动或登录初始化脚本","url":"#4启动或登录初始化脚本","depth":4},{"value":"登录脚本（Windows）","url":"#登录脚本windows","depth":5},{"value":"登录挂钩","url":"#登录挂钩","depth":5},{"value":"网络登录脚本","url":"#网络登录脚本","depth":5},{"value":"RC脚本","url":"#rc脚本","depth":5},{"value":"启动项目","url":"#启动项目","depth":5},{"value":"5.扩充套件","url":"#5扩充套件","depth":4},{"value":"6.折衷主机软件二进制","url":"#6折衷主机软件二进制","depth":4},{"value":"7.创建帐户","url":"#7创建帐户","depth":4},{"value":"本地帐户","url":"#本地帐户-1","depth":5},{"value":"域帐户","url":"#域帐户-1","depth":5},{"value":"云帐户","url":"#云帐户-1","depth":5},{"value":"8.创建或修改系统流程","url":"#8创建或修改系统流程","depth":4},{"value":"启动代理","url":"#启动代理","depth":5},{"value":"系统化服务","url":"#系统化服务","depth":5},{"value":"Windows服务","url":"#windows服务","depth":5},{"value":"启动精灵","url":"#启动精灵","depth":5},{"value":"集装箱服务","url":"#集装箱服务","depth":5},{"value":"9.事件触发的执行","url":"#9事件触发的执行","depth":4},{"value":"更改默认文件关联","url":"#更改默认文件关联","depth":5},{"value":"屏幕保护程序","url":"#屏幕保护程序","depth":5},{"value":"Windows Management Instrumentation事件订阅","url":"#windows-management-instrumentation事件订阅","depth":5},{"value":"Unixshell配置修改","url":"#unixshell配置修改","depth":5},{"value":"陷阱","url":"#陷阱","depth":5},{"value":"LC_LOAD_DYLIB添加","url":"#lc_load_dylib添加","depth":5},{"value":"Netsh帮助程序DLL","url":"#netsh帮助程序dll","depth":5},{"value":"辅助功能","url":"#辅助功能","depth":5},{"value":"AppCert DLL","url":"#appcert-dll","depth":5},{"value":"AppInit DLL","url":"#appinit-dll","depth":5},{"value":"应用程序填隙","url":"#应用程序填隙","depth":5},{"value":"图像文件执行选项注入","url":"#图像文件执行选项注入","depth":5},{"value":"PowerShell配置文件","url":"#powershell配置文件","depth":5},{"value":"Emond","url":"#emond","depth":5},{"value":"组件对象模型劫持","url":"#组件对象模型劫持","depth":5},{"value":"安装程序包","url":"#安装程序包","depth":5},{"value":"10.外部远程服务","url":"#10外部远程服务","depth":4},{"value":"11.劫持执行流程","url":"#11劫持执行流程","depth":4},{"value":"DLL搜索顺序劫持","url":"#dll搜索顺序劫持","depth":5},{"value":"DLL侧面加载","url":"#dll侧面加载","depth":5},{"value":"Dylib劫持","url":"#dylib劫持","depth":5},{"value":"可执行安装程序文件权限弱点","url":"#可执行安装程序文件权限弱点","depth":5},{"value":"动态链接劫持","url":"#动态链接劫持","depth":5},{"value":"Path环境变量的路径拦截","url":"#path环境变量的路径拦截","depth":5},{"value":"搜索顺序劫持的路径拦截","url":"#搜索顺序劫持的路径拦截","depth":5},{"value":"未引用路径的路径拦截","url":"#未引用路径的路径拦截","depth":5},{"value":"服务文件权限弱点","url":"#服务文件权限弱点","depth":5},{"value":"服务注册表权限弱点","url":"#服务注册表权限弱点","depth":5},{"value":"COR_PROFILER","url":"#cor_profiler","depth":5},{"value":"内核回调表","url":"#内核回调表","depth":5},{"value":"AppDomainManager","url":"#appdomainmanager","depth":5},{"value":"12.植入物内部图像","url":"#12植入物内部图像","depth":4},{"value":"13.修改身份验证过程","url":"#13修改身份验证过程","depth":4},{"value":"域控制器身份验证","url":"#域控制器身份验证","depth":5},{"value":"密码筛选器DLL","url":"#密码筛选器dll","depth":5},{"value":"验证模块","url":"#验证模块","depth":5},{"value":"网络设备身份验证","url":"#网络设备身份验证","depth":5},{"value":"可逆加密","url":"#可逆加密","depth":5},{"value":"多因素身份验证","url":"#多因素身份验证","depth":5},{"value":"混合身份","url":"#混合身份","depth":5},{"value":"网络提供程序DLL","url":"#网络提供程序dll","depth":5},{"value":"条件访问策略","url":"#条件访问策略","depth":5},{"value":"14.Office应用程序启动","url":"#14office应用程序启动","depth":4},{"value":"Office模板宏","url":"#office模板宏","depth":5},{"value":"Office测试","url":"#office测试","depth":5},{"value":"Outlook窗体","url":"#outlook窗体","depth":5},{"value":"Outlook主页","url":"#outlook主页","depth":5},{"value":"Outlook规则","url":"#outlook规则","depth":5},{"value":"加载项","url":"#加载项","depth":5},{"value":"15.电源设置","url":"#15电源设置","depth":4},{"value":"16.操作系统前引导","url":"#16操作系统前引导","depth":4},{"value":"系统固件","url":"#系统固件","depth":5},{"value":"组件固件","url":"#组件固件","depth":5},{"value":"Bootkit","url":"#bootkit","depth":5},{"value":"ROMMONkit","url":"#rommonkit","depth":5},{"value":"TFTP引导","url":"#tftp引导","depth":5},{"value":"17.计划任务/作业","url":"#17计划任务作业","depth":4},{"value":"18.服务器软件组件","url":"#18服务器软件组件","depth":4},{"value":"SQL存储过程","url":"#sql存储过程","depth":5},{"value":"运输代理","url":"#运输代理","depth":5},{"value":"Webshell","url":"#webshell","depth":5},{"value":"IIS组件","url":"#iis组件","depth":5},{"value":"终端服务DLL","url":"#终端服务dll","depth":5},{"value":"19.交通信号","url":"#19交通信号","depth":4},{"value":"端口敲击","url":"#端口敲击","depth":5},{"value":"套接字筛选器","url":"#套接字筛选器","depth":5},{"value":"20.有效帐户","url":"#20有效帐户","depth":4},{"value":"默认帐户","url":"#默认帐户-1","depth":5},{"value":"域帐户","url":"#域帐户-2","depth":5},{"value":"本地帐户","url":"#本地帐户-2","depth":5},{"value":"云帐户","url":"#云帐户-2","depth":5},{"value":"六、特权升级","url":"#六特权升级","depth":3},{"value":"1.滥用高程控制机制","url":"#1滥用高程控制机制","depth":4},{"value":"Setuid和Setgid","url":"#setuid和setgid","depth":5},{"value":"绕过用户帐户控制","url":"#绕过用户帐户控制","depth":5},{"value":"Sudo和Sudo缓存","url":"#sudo和sudo缓存","depth":5},{"value":"快速提升执行","url":"#快速提升执行","depth":5},{"value":"临时高架云访问","url":"#临时高架云访问","depth":5},{"value":"TCC操纵","url":"#tcc操纵","depth":5},{"value":"2.访问令牌操作","url":"#2访问令牌操作","depth":4},{"value":"代币假冒/盗窃","url":"#代币假冒盗窃","depth":5},{"value":"使用令牌创建进程","url":"#使用令牌创建进程","depth":5},{"value":"制作和模拟代币","url":"#制作和模拟代币","depth":5},{"value":"父PID后台处理","url":"#父pid后台处理","depth":5},{"value":"SID历史注入","url":"#sid历史注入","depth":5},{"value":"3.账户操纵","url":"#3账户操纵","depth":4},{"value":"其他云凭据","url":"#其他云凭据-1","depth":5},{"value":"其他电子邮件委派权限","url":"#其他电子邮件委派权限-1","depth":5},{"value":"其他云角色","url":"#其他云角色-1","depth":5},{"value":"SSH授权密钥","url":"#ssh授权密钥-1","depth":5},{"value":"设备注册","url":"#设备注册-1","depth":5},{"value":"其他容器群集角色","url":"#其他容器群集角色-1","depth":5},{"value":"4.启动或登录自动启动执行","url":"#4启动或登录自动启动执行","depth":4},{"value":"注册表运行密钥/启动文件夹","url":"#注册表运行密钥启动文件夹-1","depth":5},{"value":"身份验证包","url":"#身份验证包-1","depth":5},{"value":"时间提供程序","url":"#时间提供程序-1","depth":5},{"value":"Winlogon帮助程序DLL","url":"#winlogon帮助程序dll-1","depth":5},{"value":"安全支持提供商","url":"#安全支持提供商-1","depth":5},{"value":"内核模块和扩展","url":"#内核模块和扩展-1","depth":5},{"value":"重新打开的应用程序","url":"#重新打开的应用程序-1","depth":5},{"value":"LSASS驱动程序","url":"#lsass驱动程序-1","depth":5},{"value":"快捷方式修改","url":"#快捷方式修改-1","depth":5},{"value":"端口监视器","url":"#端口监视器-1","depth":5},{"value":"打印处理器","url":"#打印处理器-1","depth":5},{"value":"XDG自动启动条目","url":"#xdg自动启动条目-1","depth":5},{"value":"活动设置","url":"#活动设置-1","depth":5},{"value":"登录项","url":"#登录项-1","depth":5},{"value":"5.启动或登录初始化脚本","url":"#5启动或登录初始化脚本","depth":4},{"value":"登录脚本（Windows）","url":"#登录脚本windows-1","depth":5},{"value":"登录挂钩","url":"#登录挂钩-1","depth":5},{"value":"网络登录脚本","url":"#网络登录脚本-1","depth":5},{"value":"RC脚本","url":"#rc脚本-1","depth":5},{"value":"启动项目","url":"#启动项目-1","depth":5},{"value":"6.创建或修改系统流程","url":"#6创建或修改系统流程","depth":4},{"value":"启动代理","url":"#启动代理-1","depth":5},{"value":"系统化服务","url":"#系统化服务-1","depth":5},{"value":"Windows服务","url":"#windows服务-1","depth":5},{"value":"启动精灵","url":"#启动精灵-1","depth":5},{"value":"集装箱服务","url":"#集装箱服务-1","depth":5},{"value":"7.域或租户策略修改","url":"#7域或租户策略修改","depth":4},{"value":"组策略修改","url":"#组策略修改","depth":5},{"value":"信任修改","url":"#信任修改","depth":5},{"value":"8.逃到主机","url":"#8逃到主机","depth":4},{"value":"9.事件触发的执行","url":"#9事件触发的执行-1","depth":4},{"value":"更改默认文件关联","url":"#更改默认文件关联-1","depth":5},{"value":"屏幕保护程序","url":"#屏幕保护程序-1","depth":5},{"value":"Windows Management Instrumentation事件订阅","url":"#windows-management-instrumentation事件订阅-1","depth":5},{"value":"Unix外壳配置修改","url":"#unix外壳配置修改","depth":5},{"value":"陷阱","url":"#陷阱-1","depth":5},{"value":"LC_LOAD_DYLIB添加","url":"#lc_load_dylib添加-1","depth":5},{"value":"Netsh帮助程序DLL","url":"#netsh帮助程序dll-1","depth":5},{"value":"辅助功能","url":"#辅助功能-1","depth":5},{"value":"AppCert DLL","url":"#appcert-dll-1","depth":5},{"value":"AppInit DLL","url":"#appinit-dll-1","depth":5},{"value":"应用程序填隙","url":"#应用程序填隙-1","depth":5},{"value":"图像文件执行选项注入","url":"#图像文件执行选项注入-1","depth":5},{"value":"PowerShell配置文件","url":"#powershell配置文件-1","depth":5},{"value":"Emond","url":"#emond-1","depth":5},{"value":"组件对象模型劫持","url":"#组件对象模型劫持-1","depth":5},{"value":"安装程序包","url":"#安装程序包-1","depth":5},{"value":"10.利用特权升级","url":"#10利用特权升级","depth":4},{"value":"11.劫持执行流程","url":"#11劫持执行流程-1","depth":4},{"value":"DLL搜索顺序劫持","url":"#dll搜索顺序劫持-1","depth":5},{"value":"DLL侧面加载","url":"#dll侧面加载-1","depth":5},{"value":"Dylib劫持","url":"#dylib劫持-1","depth":5},{"value":"可执行安装程序文件权限弱点","url":"#可执行安装程序文件权限弱点-1","depth":5},{"value":"动态链接劫持","url":"#动态链接劫持-1","depth":5},{"value":"Path环境变量的路径拦截","url":"#path环境变量的路径拦截-1","depth":5},{"value":"搜索顺序劫持的路径拦截","url":"#搜索顺序劫持的路径拦截-1","depth":5},{"value":"未引用路径的路径拦截","url":"#未引用路径的路径拦截-1","depth":5},{"value":"服务文件权限弱点","url":"#服务文件权限弱点-1","depth":5},{"value":"服务注册表权限弱点","url":"#服务注册表权限弱点-1","depth":5},{"value":"COR_PROFILER","url":"#cor_profiler-1","depth":5},{"value":"内核回调表","url":"#内核回调表-1","depth":5},{"value":"AppDomainManager","url":"#appdomainmanager-1","depth":5},{"value":"12.过程注入","url":"#12过程注入","depth":4},{"value":"动态链接库注入","url":"#动态链接库注入","depth":5},{"value":"便携式可执行程序注入","url":"#便携式可执行程序注入","depth":5},{"value":"线程执行劫持","url":"#线程执行劫持","depth":5},{"value":"异步过程调用","url":"#异步过程调用","depth":5},{"value":"线程本地存储","url":"#线程本地存储","depth":5},{"value":"Ptrace系统调用","url":"#ptrace系统调用","depth":5},{"value":"过程内存","url":"#过程内存","depth":5},{"value":"额外窗口内存注入","url":"#额外窗口内存注入","depth":5},{"value":"工艺空心化","url":"#工艺空心化","depth":5},{"value":"处理Doppelgänging","url":"#处理doppelgänging","depth":5},{"value":"VDSO劫持","url":"#vdso劫持","depth":5},{"value":"ListPlanting","url":"#listplanting","depth":5},{"value":"13.计划任务/作业","url":"#13计划任务作业","depth":4},{"value":"14.有效账户","url":"#14有效账户","depth":4},{"value":"总结","url":"#总结-7","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"ATT&CK学习笔记","datePublished":"2024-06-24T00:00:00.000Z","dateModified":"2024-06-24T00:00:00.000Z","description":"ATT&CK的学习笔记","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/paper/ATTCK","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"基于轨迹加权的混合离线强化学习数据集","date":"2024-06-23T00:00:00.000Z","tags":["paper reading","machine learing"],"draft":false,"summary":"本文提出了一种基于轨迹加权的混合离线强化学习数据集，用于评估混合离线强化学习算法的性能。","layout":"PostSimple","bibliography":"references-data.bib","type":"Blog","readingTime":{"text":"49 min read","minutes":48.945,"time":2936700,"words":9789},"slug":"paper/trajectory-dataset","path":"blog/paper/trajectory-dataset","filePath":"blog/paper/trajectory-dataset.mdx","toc":[{"value":"目录","url":"#目录-14","depth":2},{"value":"摘要","url":"#摘要-2","depth":2},{"value":"1 介绍","url":"#1-介绍","depth":2},{"value":"2 准备工作","url":"#2-准备工作","depth":2},{"value":"3 问题表述","url":"#3-问题表述","depth":2},{"value":"3.1 正偏差方差","url":"#31-正偏差方差","depth":3},{"value":"3.2 离线RL未能有效利用高RPSV数据","url":"#32-离线rl未能有效利用高rpsv数据","depth":3},{"value":"4 方法","url":"#4-方法","depth":2},{"value":"4.1 分析","url":"#41-分析","depth":3},{"value":"4.2 回报加权","url":"#42-回报加权","depth":3},{"value":"4.3 优势加权","url":"#43-优势加权","depth":3},{"value":"5. 实验","url":"#5-实验","depth":2},{"value":"5.1 实验搭建","url":"#51-实验搭建","depth":3},{"value":"5.2 稀疏高回报数据集中的离线强化学习改进","url":"#52-稀疏高回报数据集中的离线强化学习改进","depth":3},{"value":"5.3 混合数据集中的性能提升分析","url":"#53-混合数据集中的性能提升分析","depth":3},{"value":"5.4 高回报轨迹更多的常规数据集结果","url":"#54-高回报轨迹更多的常规数据集结果","depth":3},{"value":"5.5 随机 MDP 中的结果","url":"#55-随机-mdp-中的结果","depth":3},{"value":"6 相关工作","url":"#6-相关工作","depth":2},{"value":"7 讨论","url":"#7-讨论","depth":2},{"value":"总结和经验","url":"#总结和经验","depth":2},{"value":"1. 研究背景","url":"#1-研究背景","depth":3},{"value":"2. 方法和策略","url":"#2-方法和策略","depth":3},{"value":"3. 实验设计","url":"#3-实验设计-1","depth":3},{"value":"4. 实验结果","url":"#4-实验结果","depth":3},{"value":"5. 分析和讨论","url":"#5-分析和讨论","depth":3},{"value":"6. 相关工作","url":"#6-相关工作-1","depth":3},{"value":"7. 实践意义","url":"#7-实践意义","depth":3},{"value":"8. 经验总结","url":"#8-经验总结","depth":3},{"value":"参考文献","url":"#参考文献-3","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"基于轨迹加权的混合离线强化学习数据集","datePublished":"2024-06-23T00:00:00.000Z","dateModified":"2024-06-23T00:00:00.000Z","description":"本文提出了一种基于轨迹加权的混合离线强化学习数据集，用于评估混合离线强化学习算法的性能。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/paper/trajectory-dataset","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"早期网络流量异常检测的无监督深度学习模型","date":"2024-03-20T00:00:00.000Z","tags":["paper reading","machine learing","network security"],"draft":false,"summary":"本文提出了一种名为D-PACK的深度学习模型，结合CNN和无监督自动编码器，用于自动检测网络流量异常。通过早期检查前几个数据包，D-PACK在少量数据上实现了高准确性和低误报率。研究结果表明，这种方法对在线异常检测系统的未来发展具有启示意义。","layout":"PostSimple","type":"Blog","readingTime":{"text":"17 min read","minutes":16.5,"time":990000,"words":3300},"slug":"paper/D-PACK","path":"blog/paper/D-PACK","filePath":"blog/paper/D-PACK.mdx","toc":[{"value":"目录","url":"#目录-11","depth":2},{"value":"摘要","url":"#摘要","depth":2},{"value":"介绍","url":"#介绍","depth":2},{"value":"相关的工作","url":"#相关的工作","depth":2},{"value":"分类和检测的学习策略","url":"#分类和检测的学习策略","depth":2},{"value":"采样网络流","url":"#采样网络流","depth":3},{"value":"自动构建流量模型","url":"#自动构建流量模型","depth":3},{"value":"基于深度学习的无监督异常检测体系结构","url":"#基于深度学习的无监督异常检测体系结构","depth":3},{"value":"调优的超参数","url":"#调优的超参数","depth":3},{"value":"结果评估","url":"#结果评估","depth":2},{"value":"环境","url":"#环境","depth":3},{"value":"指标","url":"#指标","depth":3},{"value":"场景一 训练集：良性流量 测试集：USTC-TFC 2016的良性流量、Mirai-CCU的恶意流量","url":"#场景一-训练集良性流量-测试集ustc-tfc-2016的良性流量mirai-ccu的恶意流量","depth":4},{"value":"场景二","url":"#场景二","depth":4},{"value":"场景三","url":"#场景三","depth":4},{"value":"源代码","url":"#源代码","depth":2},{"value":"疑点难题","url":"#疑点难题","depth":2},{"value":"1. 怎么把类似于下列的 csv 数据输入到模型进行训练","url":"#1-怎么把类似于下列的-csv-数据输入到模型进行训练","depth":3},{"value":"USTC-TFC2016 数据集的处理","url":"#ustc-tfc2016-数据集的处理","depth":4},{"value":"Mirai-RGU数据集的处理","url":"#mirai-rgu数据集的处理","depth":4},{"value":"2. CNN 模型是有监督模型，如何和无监督模型联系起来","url":"#2-cnn-模型是有监督模型如何和无监督模型联系起来","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"早期网络流量异常检测的无监督深度学习模型","datePublished":"2024-03-20T00:00:00.000Z","dateModified":"2024-03-20T00:00:00.000Z","description":"本文提出了一种名为D-PACK的深度学习模型，结合CNN和无监督自动编码器，用于自动检测网络流量异常。通过早期检查前几个数据包，D-PACK在少量数据上实现了高准确性和低误报率。研究结果表明，这种方法对在线异常检测系统的未来发展具有启示意义。","image":"https://pngimg.com/uploads/github/github_PNG80.png","url":"https://blog.mainjay.cloudns.ch/blog/paper/D-PACK","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"随心记","date":"2024-03-06T00:00:00.000Z","tags":["diary"],"draft":false,"summary":"随心记","images":["/static/images/diary/2024-03-06/picture1.JPG"],"layout":"PostBanner","type":"Blog","readingTime":{"text":"6 min read","minutes":5.285,"time":317100,"words":1057},"slug":"diary/2024-03-06","path":"blog/diary/2024-03-06","filePath":"blog/diary/2024-03-06.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"随心记","datePublished":"2024-03-06T00:00:00.000Z","dateModified":"2024-03-06T00:00:00.000Z","description":"随心记","image":"/static/images/diary/2024-03-06/picture1.JPG","url":"https://blog.mainjay.cloudns.ch/blog/diary/2024-03-06","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"随心记","date":"2024-02-06T00:00:00.000Z","tags":["diary"],"draft":false,"summary":"随心记","images":["/static/images/diary/2024-02-06/picture1.jpg"],"layout":"PostBanner","type":"Blog","readingTime":{"text":"3 min read","minutes":2.81,"time":168600,"words":562},"slug":"diary/2024-02-06","path":"blog/diary/2024-02-06","filePath":"blog/diary/2024-02-06.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"随心记","datePublished":"2024-02-06T00:00:00.000Z","dateModified":"2024-02-06T00:00:00.000Z","description":"随心记","image":"/static/images/diary/2024-02-06/picture1.jpg","url":"https://blog.mainjay.cloudns.ch/blog/diary/2024-02-06","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"随心记","date":"2024-02-04T00:00:00.000Z","tags":["diary"],"draft":false,"summary":"随心记","images":["/static/images/diary/2024-02-04/picture1.jpg"],"layout":"PostBanner","type":"Blog","readingTime":{"text":"6 min read","minutes":5.465,"time":327900,"words":1093},"slug":"diary/2024-02-04","path":"blog/diary/2024-02-04","filePath":"blog/diary/2024-02-04.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"随心记","datePublished":"2024-02-04T00:00:00.000Z","dateModified":"2024-02-04T00:00:00.000Z","description":"随心记","image":"/static/images/diary/2024-02-04/picture1.jpg","url":"https://blog.mainjay.cloudns.ch/blog/diary/2024-02-04","author":[{"@type":"Person","name":"mainJayLai"}]}},{"title":"随心记","date":"2024-02-03T00:00:00.000Z","tags":["diary"],"draft":false,"summary":"随心记","images":["/static/images/diary/2024-02-03/picture1.JPG"],"layout":"PostBanner","type":"Blog","readingTime":{"text":"6 min read","minutes":5.025,"time":301500,"words":1005},"slug":"diary/2024-02-03","path":"blog/diary/2024-02-03","filePath":"blog/diary/2024-02-03.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"随心记","datePublished":"2024-02-03T00:00:00.000Z","dateModified":"2024-02-03T00:00:00.000Z","description":"随心记","image":"/static/images/diary/2024-02-03/picture1.JPG","url":"https://blog.mainjay.cloudns.ch/blog/diary/2024-02-03","author":[{"@type":"Person","name":"mainJayLai"}]}}],"initialDisplayPosts":["$3","$d","$1a","$23","$2f"],"pagination":{"currentPage":9,"totalPages":16},"title":"All Posts"}]],null],null]},["$","$L3d",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children","page","children","$3e","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3f",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},["$","$L3d",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children","page","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3f",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},["$","$L3d",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3f",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"en-us","className":"__variable_dd5b2f scroll-smooth","suppressHydrationWarning":true,"children":[["$","head",null,{"children":[["$","link",null,{"rel":"icon","type":"image/png","href":"https://mainjaylai.github.io/favicon.png"}],["$","link",null,{"rel":"manifest","href":"/static/favicons/manifest.json"}],["$","meta",null,{"name":"msapplication-TileColor","content":"#000000"}],["$","link",null,{"href":"https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@200..900&display=swap","rel":"stylesheet"}],["$","link",null,{"href":"https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&family=ZCOOL+QingKe+HuangYou&family=ZCOOL+XiaoWei&display=swap","rel":"stylesheet"}],["$","script",null,{"src":"https://us.umami.is/script.js","async":true}],["$","meta",null,{"name":"theme-color","media":"(prefers-color-scheme: light)","content":"#fff"}],["$","meta",null,{"name":"theme-color","media":"(prefers-color-scheme: dark)","content":"#000"}],["$","meta",null,{"name":"referrer","content":"no-referrer"}],["$","script",null,{"src":"https://cdn.jsdelivr.net/gh/ashishagarwal2023/freegptjs@1.0.2/src/freegpt.min.js"}],["$","link",null,{"rel":"alternate","type":"application/rss+xml","href":"/feed.xml"}]]}],["$","body",null,{"className":"bg-white pl-[calc(100vw-100%)] text-black antialiased dark:bg-gray-950 dark:text-white","suppressHydrationWarning":true,"children":["$","$L40",null,{"children":[["$undefined","$undefined","$undefined",["$","$L41",null,{"async":true,"defer":true,"data-website-id":"bbe21cb3-3de3-4ba7-b6de-453053bc6ae8","src":"https://us.umami.is/script.js"}],"$undefined","$undefined"],["$","section",null,{"className":"mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0","children":["$","div",null,{"className":"flex h-screen flex-col justify-between font-sans","children":[["$","$L42",null,{"kbarConfig":{"searchDocumentsPath":"/search.json"},"children":[["$","header",null,{"className":"flex items-center justify-between py-5","children":[["$","div",null,{"children":["$","$L43",null,{"href":"/","aria-label":"Blog","children":["$","div",null,{"className":"flex items-center justify-between","children":[["$","div",null,{"className":"mr-3","children":["$","$L44",null,{"src":"https://mainjaylai.github.io/favicon.png","width":44,"height":44,"alt":"logo"}]}],["$","div",null,{"className":"hidden h-[44px] text-center text-3xl font-semibold leading-10 sm:block","children":"Blog"}]]}]}]}],["$","div",null,{"className":"flex items-center space-x-4 leading-5 sm:space-x-6","children":[[["$","$L43",null,{"href":"/blog","className":"navbar-item hidden font-medium text-gray-900 dark:text-gray-100 sm:block","children":"Blog"}],["$","$L43",null,{"href":"/tags","className":"navbar-item hidden font-medium text-gray-900 dark:text-gray-100 sm:block","children":"Tags"}],["$","a",null,{"target":"_blank","rel":"noopener noreferrer","href":"https://mainjaylai.github.io","className":"navbar-item hidden font-medium text-gray-900 dark:text-gray-100 sm:block","children":"About"}]],["$","$L45",null,{"aria-label":"Search","children":["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","fill":"none","viewBox":"0 0 24 24","strokeWidth":1.5,"stroke":"currentColor","className":"h-6 w-6 text-gray-900 dark:text-gray-100","children":["$","path",null,{"strokeLinecap":"round","strokeLinejoin":"round","d":"M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"}]}]}],["$","$L46",null,{}],["$","$L47",null,{}],["$","$L48",null,{}],["$","$L49",null,{}]]}]]}],["$","main",null,{"className":"mb-auto","children":["$","$L3d",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3f",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"flex flex-col items-start justify-start md:mt-24 md:flex-row md:items-center md:justify-center md:space-x-6","children":[["$","div",null,{"className":"space-x-2 pb-8 pt-6 md:space-y-5","children":["$","h1",null,{"className":"text-6xl font-extrabold leading-9 tracking-tight text-gray-900 dark:text-gray-100 md:border-r-2 md:px-6 md:text-8xl md:leading-14","children":"404"}]}],["$","div",null,{"className":"max-w-md","children":[["$","p",null,{"className":"mb-4 text-xl font-bold leading-normal md:text-2xl","children":"Sorry we couldn't find this page."}],["$","p",null,{"className":"mb-8","children":"But dont worry, you can find plenty of other things on our homepage."}],["$","$L43",null,{"href":"/","className":"focus:shadow-outline-blue inline rounded-lg border border-transparent bg-blue-600 px-4 py-2 text-sm font-medium leading-5 text-white shadow transition-colors duration-150 hover:bg-blue-700 focus:outline-none dark:hover:bg-blue-500","children":"Back to homepage"}]]}]]}],"notFoundStyles":[],"styles":null}]}]]}],["$","footer",null,{"children":["$","div",null,{"className":"mt-16 flex flex-col items-center","children":[["$","div",null,{"className":"mb-3 flex space-x-4","children":[["$","a",null,{"className":"text-sm !text-gray-500 transition hover:text-gray-600","target":"_blank","rel":"noopener noreferrer","href":"mailto:mainjaylai@outlook.com","children":[["$","span",null,{"className":"sr-only","children":"mail"}],["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 20 20","className":"fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6","children":[["$","path",null,{"d":"M2.003 5.884L10 9.882l7.997-3.998A2 2 0 0016 4H4a2 2 0 00-1.997 1.884z"}],["$","path",null,{"d":"M18 8.118l-8 4-8-4V14a2 2 0 002 2h12a2 2 0 002-2V8.118z"}]]}]]}],["$","a",null,{"className":"text-sm !text-gray-500 transition hover:text-gray-600","target":"_blank","rel":"noopener noreferrer","href":"https://github.com/mainjaylai","children":[["$","span",null,{"className":"sr-only","children":"github"}],["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 24 24","className":"fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6","children":["$","path",null,{"d":"M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"}]}]]}],["$","a",null,{"className":"text-sm !text-gray-500 transition hover:text-gray-600","target":"_blank","rel":"noopener noreferrer","href":"https://gitlab.com/JayMain","children":[["$","span",null,{"className":"sr-only","children":"gitlab"}],["$","svg",null,{"viewBox":"0 0 1024 1024","xmlns":"http://www.w3.org/2000/svg","className":"fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6","width":"200","height":"200","children":["$","path",null,{"d":"M1022.08 579.712l-57.258667-176.426667-113.664-349.397333a19.413333 19.413333 0 0 0-36.992 0L700.501333 403.2H323.498667L209.877333 53.888C204.074667 35.84 178.56 35.84 172.8 53.76L59.136 403.157333 1.877333 579.712a39.424 39.424 0 0 0 14.122667 43.648L512 983.637333l496-360.234666a39.253333 39.253333 0 0 0 14.08-43.690667"}]}]]}],["$","a",null,{"className":"text-sm !text-gray-500 transition hover:text-gray-600","target":"_blank","rel":"noopener noreferrer","href":"https://gitee.com/lmj2001","children":[["$","span",null,{"className":"sr-only","children":"gitee"}],["$","svg",null,{"viewBox":"0 0 1024 1024","xmlns":"http://www.w3.org/2000/svg","className":"fill-current text-gray-700 hover:text-primary-500 dark:text-gray-200 dark:hover:text-primary-400 h-6 w-6","width":"200","height":"200","children":["$","path",null,{"d":"M512 992C246.895625 992 32 777.104375 32 512S246.895625 32 512 32s480 214.895625 480 480-214.895625 480-480 480z m242.9521875-533.3278125h-272.56875a23.7121875 23.7121875 0 0 0-23.71125 23.7121875l-0.024375 59.255625c0 13.08 10.6078125 23.7121875 23.6878125 23.7121875h165.96c13.104375 0 23.7121875 10.6078125 23.7121875 23.6878125v11.855625a71.1121875 71.1121875 0 0 1-71.1121875 71.1121875h-225.215625a23.7121875 23.7121875 0 0 1-23.6878125-23.7121875V423.1278125a71.1121875 71.1121875 0 0 1 71.0878125-71.1121875h331.824375a23.7121875 23.7121875 0 0 0 23.6878125-23.71125l0.0721875-59.2565625a23.7121875 23.7121875 0 0 0-23.68875-23.7121875H423.08a177.76875 177.76875 0 0 0-177.76875 177.7921875V754.953125c0 13.1034375 10.60875 23.7121875 23.713125 23.7121875h349.63125a159.984375 159.984375 0 0 0 159.984375-159.984375V482.36a23.7121875 23.7121875 0 0 0-23.7121875-23.6878125z"}]}]]}]]}],["$","div",null,{"className":"mb-2 flex space-x-2 text-sm text-gray-500 dark:text-gray-400","children":[["$","div",null,{"children":"MainJayLai"}],["$","div",null,{"children":" • "}],["$","div",null,{"children":"© 2025"}],["$","div",null,{"children":" • "}],["$","$L43",null,{"href":"/","children":"MainJayLai Blog"}]]}]]}]}]]}]}]]}]}]]}],null],null],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/c890694439b2475b.css","precedence":"next","crossOrigin":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/1ea5cf861ee12a80.css","precedence":"next","crossOrigin":"$undefined"}]],"$L4a"]]]]
4a:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"MainJayLai Blog"}],["$","meta","3",{"name":"description","content":"A blog created with Next.js and Tailwind.css by MainJayLai"}],["$","meta","4",{"name":"robots","content":"index, follow"}],["$","meta","5",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","6",{"rel":"canonical","href":"https://blog.mainjay.cloudns.ch/blog/page/9"}],["$","link","7",{"rel":"alternate","type":"application/rss+xml","href":"https://blog.mainjay.cloudns.ch/feed.xml"}],["$","meta","8",{"property":"og:title","content":"MainJayLai Blog"}],["$","meta","9",{"property":"og:description","content":"A blog created with Next.js and Tailwind.css by MainJayLai"}],["$","meta","10",{"property":"og:url","content":"https://blog.mainjay.cloudns.ch/blog/page/9"}],["$","meta","11",{"property":"og:site_name","content":"MainJayLai Blog"}],["$","meta","12",{"property":"og:locale","content":"en_US"}],["$","meta","13",{"property":"og:image","content":"https://pngimg.com/uploads/github/github_PNG80.png"}],["$","meta","14",{"property":"og:type","content":"website"}],["$","meta","15",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","16",{"name":"twitter:title","content":"MainJayLai Blog"}],["$","meta","17",{"name":"twitter:description","content":"A blog created with Next.js and Tailwind.css by MainJayLai"}],["$","meta","18",{"name":"twitter:image","content":"https://pngimg.com/uploads/github/github_PNG80.png"}],["$","meta","19",{"name":"next-size-adjust"}]]
1:null
